<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java多线程机制深度剖析</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/202409Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/202409Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="三种方法的区别"><a href="#三种方法的区别" class="headerlink" title="三种方法的区别"></a>三种方法的区别</h1><p>Thread 类、Runnable 接口和线程池是 Java 中实现多线程的三种常见方式，它们各自有不同的特点和使用场景。</p><p> 1、Thread 类：</p><pre><code>     Thread 类是 Java 中的一个内置类，使用 Thread 类实现多线程时，需要继承 Thread 类并重写其 run() 方法，然后创建 Thread 对象并调用其 start() 方法启动线程。这种方式可以实现多线程，但是每个线程都需要创建一个独立的对象，如果线程数量很大，会占用大量的内存空间。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 线程执行的代码逻辑  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">// 创建线程对象  </span></span><br><span class="line">        myThread.start(); <span class="comment">// 启动线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Runnable 接口：</p><pre><code>    Runnable 接口是 Java 中定义的一个接口，它只有一个 run() 方法，用于定义线程执行的代码逻辑。使用 Runnable 接口实现多线程时，需要实现 Runnable 接口并重写其 run() 方法，然后创建一个 Thread 对象并将 Runnable 对象作为参数传递给 Thread 的构造函数，最后调用 Thread 的 start() 方法启动线程。这种方式相比继承 Thread 类更加灵活，因为多个线程可以共享同一个 Runnable 对象，可以节省内存空间。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 线程执行的代码逻辑  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()); <span class="comment">// 创建线程对象并传入Runnable对象  </span></span><br><span class="line">        thread.start(); <span class="comment">// 启动线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、线程池</p><pre><code>    线程池是一种更加高效的多线程实现方式。它通过预先创建一定数量的线程并保存在内存中，避免了频繁地创建和销毁线程对象，提高了线程的复用性。使用线程池实现多线程时，需要创建一个 ExecutorService 对象（可以通过 Executors 类创建），然后调用其 submit() 或 execute() 方法提交任务给线程池执行。这种方式可以更加高效地利用系统资源，减少线程的创建和销毁开销。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 创建一个固定大小的线程池  </span></span><br><span class="line">        executorService.submit(() -&gt; &#123; <span class="comment">// 提交任务到线程池中执行  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task is running on thread &quot;</span> + Thread.currentThread().getName());  </span><br><span class="line">        &#125;);  </span><br><span class="line">        executorService.shutdown(); <span class="comment">// 关闭线程池  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池生命周期管理"><a href="#线程池生命周期管理" class="headerlink" title="线程池生命周期管理"></a>线程池生命周期管理</h1><p>1、任务提交：当任务被提交到线程池时，线程池会首先检查当前是否有可用的线程。如果有，则将任务分派给该线程执行；如果没有，则根据线程池的设置来处理该任务。</p><p>2、判断核心线程数：线程池会判断当前的核心线程数是否已满。如果没有满，则创建一个新的核心线程去执行任务。如果已满，则进入下一个流程。</p><p>3、判断工作队列：如果工作队列未满，则将新提交的任务存储在工作队列里。如果工作队列已满，则进入下一个流程。</p><p>4、判断整个线程池：如果线程池里面的存活线程数已经等于核心线程数，且工作队列已经满了，再会去判断当前线程数是否已经达到最大线程数。如果没有达到，则会创建一个新的非核心线程去执行任务；如果已经达到，则交给饱和策略来处理这个任务。</p><p>5、饱和策略：当队列和线程池都满了的时候，再有新的任务到达，就必须要有一种办法来处理新来的任务。拒绝策略在此时发挥作用。具体的策略包括丢弃任务、抛出异常或阻塞当前任务等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacBook上使用IDEA&amp;docker开发Java</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/</url>
      
        <content type="html"><![CDATA[<h1 id="在MacBook上使用vscode-docker开发C"><a href="#在MacBook上使用vscode-docker开发C" class="headerlink" title="在MacBook上使用vscode&amp;docker开发C++"></a>在MacBook上使用vscode&amp;docker开发C++</h1><p>出发点：</p><ol><li>本地编译非常容易遇到环境问题，经常遇到一个依赖包调半天的尴尬情况，强烈建议使用docker开发，从0开始构建镜像，源码编译，避免依赖问题</li><li>本项目使用了外部提供的webrtc sdk，只有linux版本，没有mac版本，所以只能远程开发</li><li>本机处理能力不强。我的笔记本启动容器或虚拟机非常容易卡顿，其他什么事都干不了</li><li>纯远程开发成本较高。基于vim编辑器组装IDE代价较大，而且很难标准化，代码和IDE维护的成本都比较高</li><li>IDEA版本更新很快，网上的教程基本上都过时了</li></ol><p>所以经过一段时间的调研和实践，这里推荐大家 【 开发机IDEA + 远程docker 】进行主力研发。</p><h2 id="1-开发机安装docker-desktop"><a href="#1-开发机安装docker-desktop" class="headerlink" title="1. 开发机安装docker desktop"></a>1. 开发机安装docker desktop</h2><p>手动下载安装Docker for Mac，不再赘述</p><p>下载链接可能是：<a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></p><h2 id="2-远程主机配置镜像加速"><a href="#2-远程主机配置镜像加速" class="headerlink" title="2. 远程主机配置镜像加速"></a>2. 远程主机配置镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com./">http://hub-mirror.c.163.com。</a></p><p>在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p><p>Linux的SDK不能在Apple 芯片上运行！所以只能使用远程。这里不用配置第2步了</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/so_cannot_runon_macdocker.png" class=""><h2 id="3-远程主机配置信任"><a href="#3-远程主机配置信任" class="headerlink" title="3. 远程主机配置信任"></a>3. 远程主机配置信任</h2><p>示例远程主机：ssh <a href="mailto:&#x72;&#111;&#x6f;&#x74;&#64;&#49;&#x30;&#x2e;&#x32;&#x36;&#46;&#x32;&#x31;&#46;&#51;&#x38;">&#x72;&#111;&#x6f;&#x74;&#64;&#49;&#x30;&#x2e;&#x32;&#x36;&#46;&#x32;&#x31;&#46;&#51;&#x38;</a> 密码Aisearch123</p><ol><li><p>首先在远程主机上配置docker server。（开发机默认已安装）</p></li><li><p>本机生成sshkey ssh-keygen -t rsa -C “<a href="mailto:&#x6e;&#x69;&#x75;&#113;&#105;&#97;&#x6e;&#x67;&#48;&#48;&#x32;&#x40;&#x6b;&#101;&#46;&#x63;&#x6f;&#109;">&#x6e;&#x69;&#x75;&#113;&#105;&#97;&#x6e;&#x67;&#48;&#48;&#x32;&#x40;&#x6b;&#101;&#46;&#x63;&#x6f;&#109;</a>“</p></li><li><p>远程主机添加信任</p><p> 笔记本：cat ~&#x2F;.ssh&#x2F;id_rsa.pub<br> 粘贴内容到远程主机： vim ~&#x2F;.ssh&#x2F;authorized_keys，独立一行</p></li></ol><hr><h2 id="4-开发机切换远程"><a href="#4-开发机切换远程" class="headerlink" title="4. 开发机切换远程"></a>4. 开发机切换远程</h2><ol><li><p>开发机创建context。</p><p> docker context create niuqiang_devon_1020122644 –docker “host&#x3D;ssh:&#x2F;&#x2F;<a href="mailto:&#x6e;&#105;&#x75;&#x71;&#x69;&#x61;&#110;&#x67;&#x30;&#x30;&#50;&#64;&#x31;&#48;&#46;&#50;&#x30;&#x31;&#46;&#50;&#x32;&#x36;&#46;&#x34;&#52;">&#x6e;&#105;&#x75;&#x71;&#x69;&#x61;&#110;&#x67;&#x30;&#x30;&#50;&#64;&#x31;&#48;&#46;&#50;&#x30;&#x31;&#46;&#50;&#x32;&#x36;&#46;&#x34;&#52;</a>:22222”</p></li><li><p>切换context</p><p> docker context use niuqiang_devon_1020122644</p></li></ol><p>有可能需要在vscode中手动指定使用的docker context。按下 ctrl+shift+p 运行 docker contexts use , 选择上面创建的docker context.</p><p>完成验证：</p><pre><code>docker ps 显示远程主机上的docker容器进程。</code></pre><p>然后就可以愉快滴当做本机docker环境来使用了！接下来的第567节，在开发机和远程主机执行效果是一样的，其他镜像和容器操作不再赘述。</p><p>到这里完成了前半部分：使用远程docker。</p><h2 id="5-创建镜像"><a href="#5-创建镜像" class="headerlink" title="5. 创建镜像"></a>5. 创建镜像</h2><p>模仿线上机器环境，总结出一版docker镜像</p><p>从dockerfile构建镜像：</p><pre><code>docker build . -f deploy/Dockerfile -t niuqiang_test_vad_engine_service</code></pre><p>相关操作：</p><pre><code>docker images  # 观察是否创建成功</code></pre><h2 id="6-启动容器"><a href="#6-启动容器" class="headerlink" title="6. 启动容器"></a>6. 启动容器</h2><pre><code>docker run -idt --cap-add sys_ptrace --security-opt seccomp=unconfined -v /etc/localtime:/etc/localtime -v /Users/niuqiang/dockerspace:/home -p 8086:8080 -p 8022:22 --name niuqiang_devtest_ubuntu2204 ubuntu:22.04多端口版本：docker run -itd --cap-add sys_ptrace --security-opt seccomp=unconfined -v /etc/localtime:/etc/localtime -v /home:/home -p 32100-32199:8000-8099 -p 32100-32199:8000-8099/udp -p 38060:8060 -p 38060:8060/udp -p 38006:8006 -p 38006:8006/udp -p 31554:1554 -p 31554:1554/udp --name niuqiang_init_mrcp_20210420 niuqiang_init_unimrcp:20210420</code></pre><p>相关操作：</p><ul><li>docker container ls -a 查看容器列表</li><li>docker ps 查看当前在运行的容器</li><li>docker rm xxxID 删除未在运行的容器</li></ul><h2 id="7-使用容器"><a href="#7-使用容器" class="headerlink" title="7. 使用容器"></a>7. 使用容器</h2><pre><code>docker exec -it xxxID /bin/bash</code></pre><p>相关操作：</p><ul><li>docker stop xxxxx</li><li>docker cp 0a15cf13f589:&#x2F;usr&#x2F;local&#x2F;freeswitch&#x2F;freeswitch_conf.tar ~&#x2F; 在容器和宿主机之间相互拷贝</li><li>docker commit -a “<a href="mailto:&#110;&#105;&#117;&#113;&#x69;&#97;&#x6e;&#x67;&#48;&#48;&#x32;&#x40;&#107;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#110;&#105;&#117;&#113;&#x69;&#97;&#x6e;&#x67;&#48;&#48;&#x32;&#x40;&#107;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>“ -m “自定义unimrcp客户端，支持从文件读取参数” niuqiang_mrcp_centos_0521 jx-bd-hadoop13.zeus.lianjia.com:801&#x2F;speech&#x2F;long_asr&#x2F;lrt_asr:16000_unk_ssc_0.0.4</li><li>docker system prune –all –force –volumes 删除所有缓存</li></ul><hr><h2 id="8-开发机安装IDEA"><a href="#8-开发机安装IDEA" class="headerlink" title="8. 开发机安装IDEA"></a>8. 开发机安装IDEA</h2><p>下载安装IntelliJ IDEA， 不再赘述。</p><blockquote><p>建议使用Ultimate版本，因为Community版本不支持远程运行</p></blockquote><ol><li>安装插件Docker。Ultimate版本默认安装</li></ol><h2 id="9-开发机使用远程！"><a href="#9-开发机使用远程！" class="headerlink" title="9. 开发机使用远程！"></a>9. 开发机使用远程！</h2><p>激动人心的时刻到了！</p><ol><li>打开项目的启动配置，选择Run on SSH (Community版本没有这个选项)<img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/idea_run_on_remote.png" class=""></li><li>提前在容器中完成SSH相关配置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -idt --cap-add sys_ptrace --security-opt seccomp=unconfined -v /etc/localtime:/etc/localtime -v /Users/niuqiang/dockerspace:/home -p 8086:8080 -p 8022:22 --name niuqiang_devtest_ubuntu2204 ubuntu:22.04</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1  apt-get update</span><br><span class="line">2  apt-get upgrade</span><br><span class="line">3  apt-get install curl zip unzip</span><br><span class="line">4  curl -s &quot;https://get.sdkman.io&quot; | bash</span><br><span class="line">6  source &quot;/root/.sdkman/bin/sdkman-init.sh&quot;</span><br><span class="line">7  sdk list java</span><br><span class="line">8  sdk install java 11.0.24-amzn</span><br><span class="line"></span><br><span class="line">10  apt-get install openssh-server</span><br><span class="line">9  apt-get install vim</span><br><span class="line">13  apt-get install less</span><br><span class="line">14  less /etc/ssh/sshd_config</span><br><span class="line">15  vim /etc/ssh/sshd_config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Port 22</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PermitRootLogin <span class="built_in">yes</span></span></span><br><span class="line"></span><br><span class="line">16  /etc/init.d/ssh restart</span><br><span class="line"></span><br><span class="line">19  apt-get install net-tools</span><br><span class="line"></span><br><span class="line">24  passwd root</span><br><span class="line">25  vim /etc/ssh/sshd_config</span><br><span class="line">26  /etc/init.d/ssh restart</span><br><span class="line"></span><br><span class="line">29  which java</span><br></pre></td></tr></table></figure>完成！</li></ol><h2 id="shell-选择"><a href="#shell-选择" class="headerlink" title="shell 选择"></a>shell 选择</h2><p>2021年07月01日14:23:49 windows terminal不堪重用</p><ol><li>退格闪屏</li><li>不能rz、sz</li><li>不能保持连接<br>2021年07月01日14:24:28 windows下最终选择mobaxterm， all in one</li></ol><h3 id="mobaxterm-配置"><a href="#mobaxterm-配置" class="headerlink" title="mobaxterm 配置"></a>mobaxterm 配置</h3><p>2021年07月09日12:05:20 解决使用远程docker时，ssh版本不匹配的问题<br>问题：[niuqiang.DESKTOP-V97ON2U] ➤ docker ps<br>error during connect: Get “<a href="http://docker/v1.24/containers/json">http://docker/v1.24/containers/json</a>“: fork&#x2F;exec C:\Users\niuqiang\DOCUME<del>1\MOBAXT</del>1\slash\bin\ssh.exe: This version of %1 is not compatible with the version of Windows you’re running. Check your computer’s system information and then contact the software publisher.<br>解法：<br>export PATH&#x3D;”&#x2F;drives&#x2F;c&#x2F;Program Files&#x2F;Git&#x2F;usr&#x2F;bin”:$PATH<br>注意删除原来path中的slash目录</p><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>2021年07月12日14:26:39 </p><ol><li>开发还是macbook好使，类unix工具链，不需要折腾。Windows太累了</li><li>Windows安装在macbook上，非常耗电，续航只有macos的1&#x2F;3到1&#x2F;4</li></ol><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>IDEA + docker也不是万能的，可能会有各种各样不得不妥协的场景，这里只是不推荐纯远程开发。</li><li>VPN情况下，开发机似乎无法连接10.26.21.38。SAD</li><li>注意到第四节介绍的是ssh，而第三节配置了信任</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Docker </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习模型部署实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>因为PE平台的智能体和workflow概念已经是业界通行语言，所以如果有智能能力，尽量采用可以在pe平台上线的方式。</p><p>agent的主体必须是大语言模型，所以语音和图像相关的能力需要以http调用的方式对接到workflow。</p><p>而workflow的变量限制文本和段落类型的最大长度，即使从32768扩展到100k级别，仍然不能处理图像和音频数据。</p><p>所以在workflow和模型能力之间需要有一个转接层，用于数据的下载和处理。此外还有以下优势</p><ol><li>增强了干预能力，如果需要对能力做pipeline，这可能是一种比较方便的方式</li><li>可以增加基本的服务可用性保障，如监控、排队等</li></ol><h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>王静提交的mmpretrain可以使用torchserve部署，但是官方没有明确给出性能或易用性等优势，所以暂时不关注，暂时统一使用torchrun方式 </p><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h1 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h1><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h1>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 大模型与多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件系统设计文档模版</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202408%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202408%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h1><h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目背景描述清晰</p><h2 id="竞品调研"><a href="#竞品调研" class="headerlink" title="竞品调研"></a>竞品调研</h2><h1 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h1><p>B点画面</p><h2 id="项目价值"><a href="#项目价值" class="headerlink" title="项目价值"></a>项目价值</h2><p>核心需求分析透彻</p><h2 id="项目范围"><a href="#项目范围" class="headerlink" title="项目范围"></a>项目范围</h2><p>设计目标清晰明确</p><h2 id="关键能力及指标"><a href="#关键能力及指标" class="headerlink" title="关键能力及指标"></a>关键能力及指标</h2><h2 id="重难点问题"><a href="#重难点问题" class="headerlink" title="重难点问题"></a>重难点问题</h2><h2 id="OKR"><a href="#OKR" class="headerlink" title="OKR"></a>OKR</h2><h2 id="达成路径分析"><a href="#达成路径分析" class="headerlink" title="达成路径分析"></a>达成路径分析</h2><p>分析问题全面</p><h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>明确面向的客户，产品的特点</p><h2 id="产品优势"><a href="#产品优势" class="headerlink" title="产品优势"></a>产品优势</h2><h2 id="产品功能"><a href="#产品功能" class="headerlink" title="产品功能"></a>产品功能</h2><p>核心功能图文展示</p><h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><h1 id="项目方案"><a href="#项目方案" class="headerlink" title="项目方案"></a>项目方案</h1><h2 id="视觉设计"><a href="#视觉设计" class="headerlink" title="视觉设计"></a>视觉设计</h2><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>各系统功能概述。解决方案考虑周全：</p><ul><li>考虑多租户（复用）问题；白名单问题；</li></ul><h2 id="交互用例"><a href="#交互用例" class="headerlink" title="交互用例"></a>交互用例</h2><h2 id="数据泳道"><a href="#数据泳道" class="headerlink" title="数据泳道"></a>数据泳道</h2><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h3 id="依赖接口"><a href="#依赖接口" class="headerlink" title="依赖接口"></a>依赖接口</h3><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><h3 id="数据表定义"><a href="#数据表定义" class="headerlink" title="数据表定义"></a>数据表定义</h3><h3 id="限制约束"><a href="#限制约束" class="headerlink" title="限制约束"></a>限制约束</h3><h2 id="需求推演"><a href="#需求推演" class="headerlink" title="需求推演"></a>需求推演</h2><p>提供可扩展空间</p><h1 id="可用性保障"><a href="#可用性保障" class="headerlink" title="可用性保障"></a>可用性保障</h1><h2 id="加强感知"><a href="#加强感知" class="headerlink" title="加强感知"></a>加强感知</h2><h2 id="及时止损"><a href="#及时止损" class="headerlink" title="及时止损"></a>及时止损</h2><h2 id="日常跟进"><a href="#日常跟进" class="headerlink" title="日常跟进"></a>日常跟进</h2><h1 id="下一步行动"><a href="#下一步行动" class="headerlink" title="下一步行动"></a>下一步行动</h1><h2 id="步骤拆解-优先级-排期"><a href="#步骤拆解-优先级-排期" class="headerlink" title="步骤拆解 &amp; 优先级 &amp;排期"></a>步骤拆解 &amp; 优先级 &amp;排期</h2><h2 id="milestone与达成效果"><a href="#milestone与达成效果" class="headerlink" title="milestone与达成效果"></a>milestone与达成效果</h2><h2 id="验收方案"><a href="#验收方案" class="headerlink" title="验收方案"></a>验收方案</h2><p>2022年01月31日09:27:30 需要考虑如何同时支持生产环境和测试环境<br>2024年04月17日18:28:22 需要支持从各个角度验收交付物，最起码需要有测试环境</p><h2 id="风险预案"><a href="#风险预案" class="headerlink" title="风险预案"></a>风险预案</h2><h2 id="进展追踪"><a href="#进展追踪" class="headerlink" title="进展追踪"></a>进展追踪</h2><p>下一步工作计划</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本管理工具使用实战(Git)</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%88%98(Git)/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%88%98(Git)/</url>
      
        <content type="html"><![CDATA[<p>2018年1月26日09:32:02</p><p>来源：Git教程-廖雪峰</p><p>Git是目前世界上最先进的分布式版本控制系统，而SVN是目前用得最多的集中式版本库控制系统。<br>集中式版本控制系统，版本库是集中存放在中央服务器的，而分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，但通常也会有一台“中央服务器”用于交换diff 。</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库。这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所有的版本控制系统，其实只能跟踪文本文件的改动。二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化</p><p>选择一个合适的地方，创建一个空目录（也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的）<br>通过git init命令把这个目录变成Git可以管理的仓库  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> learngit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> learngit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/Users/michael/learngit</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>放入或变动文件</p><p>git add readme.txt 把文件添加到仓库</p><p>git reset xxx 从提交区撤销刚刚添加的更改的文件</p><p>git commit -m “wrote a readme file” 把文件提交到仓库</p><p>git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支</p><p>git status 可以让我们时刻掌握仓库当前的状态<br>git diff 查看difference，显示的格式正是Unix通用的diff格式<br>没有变更的时候使用则没有效果<br>TODO 详解通用diff格式<br>提交修改和提交新文件是一样的两步：git add + git commit</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支<br>每次修改，如果不add到暂存区，那就不会加入到commit中</p><p>git log命令显示从最近到最远的提交日志</p><p>commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示在Git中，用HEAD表示当前版本，也就是最新的提交。上一个版本是head~1回退到上一个版本，可以使用git reset命令</p><p>git reflog 查看命令历史，与历次修改时受影响的commit id.</p><p>git checkout – readme.txt 让这个文件回到最近一次git commit或git add时的状态<br>git reset HEAD readme 把暂存区的修改撤销掉<br>2018年1月30日08:37:35</p><p>git rm test.txt 提交删除到暂存区<br>恢复分两种情况: commit了，这时要reset这个文件的HEAD为head~1，然后checkout<br>没有commit，直接reset这个文件的HEAD为HEAD，然后checkout<br>使用GitHub作为远程仓库</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br>ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#x75;&#x72;&#x65;&#x6d;&#x61;&#105;&#108;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;">&#x79;&#111;&#x75;&#x72;&#x65;&#x6d;&#x61;&#105;&#108;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#109;</a>“</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容<br>第3步：登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库<br>第4步：把本地仓库与之关联 TODO 如何取消关联<br>git remote add origin <a href="https://github.com/ishitbugs/CmakeEx.git">https://github.com/ishitbugs/CmakeEx.git</a></p><p>第5步：把本地库的所有内容推送到远程库上<br>git push -u origin master</p><p>第6步：使用。只要本地作了提交，就可以把本地master分支的最新修改推送至GitHub<br>git push origin master</p><p>第7步：协作。克隆得到一个本地库，并且修改尝试提交。</p><p>git clone <a href="https://github.com/ishitbugs/learngit.git">https://github.com/ishitbugs/learngit.git</a><br>some modify…<br>git add &amp; git rm &amp; so<br>git commit<br>git push origin master<br>只有通过ssh-key或账号验证的用户才能够成功提交</p><p>2018年1月30日09:38:19 origin是远程库的名字，这是Git默认的叫法，也可以改成别的</p><p>分支管理<br>git branch -a 查看所有本地或远程分支</p><p>git branch <name> &lt;origin&#x2F;name&gt; 由远程分支创建本地分支并绑定</p><p>git checkout <name> 切换分支</p><p>git merge –no-ff -m “merge with no-ff” <name> 合并某分支到当前分支。</p><p>只能将更新的分支合并到未更新分支</p><p>解决冲突</p><p>vim conflicting files<br>git add conflicting files<br>git commit (current branch)<br>git branch -d <name> 删除分支</p><p>git branch -D <name> 强行删除分支</p><p>强行删除的分支仍然能够通过git reflog找到</p><p>多人协作<br>当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin</p><p>使用 git remote -v 查看远程仓库信息<br>git push origin master 推送指定分支到指定远程仓库，该指定分支必须已与远程分支绑定<br>首先，可以试图用git push origin branch-name推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>git pull <remote repo> <branch></p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin&#x2F;branch-name。</p><p>######标签管理<br>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p><p>git tag -a tagname (commit id) -m message 默认为HEAD<br>git tag 查看所有标签<br>git show tagname 查看标签详细信息<br>git push origin <tagname> 推送某个标签到远程<br>git push origin –tags 一次性推送全部尚未推送到远程的本地标签<br>删除标签</p><p>git tag -d tagname 先从本地删除<br>git push origin :refs&#x2F;tags&#x2F;tagname 然后从远程删除</p><h2 id="与远程同步fork"><a href="#与远程同步fork" class="headerlink" title="与远程同步fork"></a>与远程同步fork</h2><p>Configuring a remote for a fork<br>给 fork 配置一个 remote<br>使用 git remote -v 查看远程状态。<br>git remote -v</p><p>添加一个将被同步给 fork 远程的上游仓库<br>git remote add upstream <a href="https://github.com/Qihoo360/QConf.git">https://github.com/Qihoo360/QConf.git</a></p><p>再次查看状态确认是否配置成功。<br>git remote -v</p><p>Syncing a fork<br>从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream&#x2F;master<br>git fetch upstream</p><p>切换到本地主分支(如果不在的话)<br>git checkout master</p><p>把 upstream&#x2F;master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。<br>git merge upstream&#x2F;master<br>git merge upstream&#x2F;master</p><p>如果想更新到 GitHub 的 fork 上，直接 git push origin master 就好了。</p><h2 id="使用远程库"><a href="#使用远程库" class="headerlink" title="使用远程库"></a>使用远程库</h2><p>第一步，安装git<br>sudo apt-get install git</p><p>第二步，创建一个git用户，用来运行git服务(可略过，该用户可ssh登陆即可)<br>sudo adduser git</p><p>第三步，创建证书登录<br>收集所有需要登录的用户的公钥，就是他们的id_rsa.pub文件，把所有公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件(如果没有则新建)里，一行一个。</p><p>第四步，初始化Git仓库<br>先选定一个目录作为Git仓库，假定是&#x2F;srv&#x2F;sample.git，在&#x2F;srv目录下输入命令： sudo git init –bare sample.git</p><p>裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。</p><p>然后，把owner改为git(如果未进行第二步，则省略)<br>sudo chown -R git:git sample.git</p><p>第五步，禁用shell登录(如果未进行第二步，则省略)<br>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑&#x2F;etc&#x2F;passwd文件完成。找到该用户所在行，改为：<br>git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</p><p>第六步，克隆远程仓库</p><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><p>git clone ssh:&#x2F;&#x2F;<a href="mailto:&#110;&#x69;&#117;&#113;&#105;&#x61;&#x6e;&#103;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#x31;&#x30;&#x2e;&#50;&#x30;&#57;">&#110;&#x69;&#117;&#113;&#105;&#x61;&#x6e;&#103;&#x40;&#x31;&#x39;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#x31;&#x30;&#x2e;&#50;&#x30;&#57;</a>:20022&#x2F;home&#x2F;niuqiang&#x2F;sample.git</p><p>或者</p><p>git clone ssh:&#x2F;&#x2F;192.168.10.209:20022&#x2F;home&#x2F;niuqiang&#x2F;sample.git</p><p>或者</p><p>git clone ssh:&#x2F;&#x2F;<a href="mailto:&#110;&#x69;&#x75;&#113;&#105;&#97;&#110;&#x67;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#49;&#x30;&#46;&#50;&#x30;&#x39;">&#110;&#x69;&#x75;&#113;&#105;&#97;&#110;&#x67;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#49;&#x30;&#46;&#50;&#x30;&#x39;</a>&#x2F;home&#x2F;niuqiang&#x2F;sample.git</p><p>或者</p><p>git clone ssh:&#x2F;&#x2F;192.168.10.209&#x2F;home&#x2F;niuqiang&#x2F;sample.git ☆</p><p>为了支持端口不在22的ssh协议登陆，可能还需要在.ssh&#x2F;cofig中指定端口</p><p>可能仓库端需要安装openssl-server</p><p>在客户端正常使用和推送。</p><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><p>VSS、CVS、SVN和ClearCase等配置工具的评估和比较<br>1<br>概述</p><p>Visual SourceSafe：微软的版本控制工具，仅支持Windows操作系统。虽然简单好用，但是仅适用于团队级开发，不能胜任企业级的开发工作。</p><p>Clearcase：IBM旗下Rational公司(2003年被IBM收购)的一款重量级的软件配置管理(SCM， SoftwareConfiguration Managemen)工具。与CVS和VSS不同，Clearcase涵盖的范围包括版本控制、建立管理、工作空间管理和过程控制。从最初的软件配置计划，到配置项的确立，从变更控制到版本控制，Clearcase贯穿于整个软件生命周期。 Clearcase支持现有的绝大多数操作系统，但它的安装、配置、使用相对较复杂，并且需要进行团队培训。</p><p>CVS：Concurrent Versions System。CVS 是有着三十年以上的时间的考验。CVS是开放源代码软件世界的一个伟大杰作，由于CVS功能强大，跨平台，支持并发版本控制，而且免费，所以它在全球中小型软件企业中得到了广泛使用。CVS最大的遗憾就是缺少相应的技术支持，许多问题的解决需要自已寻找资料，甚至是研究源代码。CVS是一个典型的服务器&#x2F;客户端软件，有UNIX版本的CVS 、Linux版本的CVS和WINDOWS版本的CVS。CVS支持远程管理，项目组分布开发时一般都采用CVS。</p><p>SVN：Subversion。采用了更先进的分支管理系统，它的设计目标就是取代CVS，CVS纵然易用，但也有一些与生俱来的缺点，比如CVS不支持文件改名，只对文件控制版本而没有针对目录的管理等。之后CVS 的创始人之一在其现任公司的资助下开发了SVN，用以针对CVS 的一些弱点进行改进。</p><p>2<br>主要功能说明CVS纵然是一个老牌的工具产品，并也对开源事业有贡献，但CVS的命令行操作着实让一些使用者头疼。在对一个特定版本的文档Check in的时候，需要输入一长串的路径名、文件名。在操作易用性上与CVS形成对比的是微软家族的VSS。作为微软的产品，在图形界面化操作上自不用多言，但VSS只能适用于小团队的开发工作。VSS是很好的入门级工具，但它的一些功能太过于“入门”，在验证密码、保存密码这些基本功能上处理的不尽人意。适用于大型软件开发的有“中坚级”的Clearcase，用它来管理一些小型的项目管理有些“大材小用”。Clearcase支持目录版本管理、异地团队开发、视图、多服务器等强大功能，所以一些大公司把它做为一、二级产品管理用，但同样它的价格也不菲。CVS是开源的，免费的，更何况它还有一个理想的替代者——SVN。SVN的设计专门针对CVS的问题作了改进,命令的设计更为合理,对二进制文档和目录这样的数据加强了控制能力,并且吸收了VSS的lock-modify-update(release)的模式和modify-merge模式的优点这两种方式在一定程度都支持并作了优化,没有提高使用的复杂度。由于SVN的设计结构很好,所以很容易为它开发客户端,还有WEB模式的,可以远程管理,支持RSS更改订阅。</p><p>功能<br>名称</p><p>Internet网络和远程管理</p><p>并行开发</p><p>跨平台开发</p><p>操作的便利性</p><p>信息安全性</p><p>VSS<br>最新发布版本VSS8.0可支持此功能<br>最新发布版本VSS8.0支持此功能<br>仅支持Windows 操作系统<br>安装、配置、使用均较简单，很容易上手使用<br>安全性不高，基于文件系统共享实现对服务器的访问，需要共享存储目录，这样用户可以对VSS的文件夹执行删除操作。</p><p>CVS<br>支持，速度一般<br>支持<br>支持几乎所有的操作系统<br>安装、配置较复杂，但使用比较简单，只需对配置管理做简单培训即可<br>安全性高，CVS服务器有自己专用的数据库，文件存储并不采用 “共享目录”方式，所以不受限于局域网。</p><p>SVN<br>相比CVS，更加适合基于互联网协作开发的团队，速度也更快<br>相比CVS，能够保证所有的修改都入库生效<br>同上<br>同上<br>同上</p><p>ClearCase<br>速度最快，且不受网络连接带宽的限制、防火墙以及安全问题的影响。<br>支持<br>支持常见的平台<br>安装、配置、使用相对较复杂，需要进行团队培训<br>安全性不高，采用C&#x2F;S模式，需要共享服务器上的存储目录以供客户端访问</p><p>2.1<br>Internet网络访问和远程管理</p><p>VSS、CVS和SVN都提供基于Web的界面，用户可以通过浏览器执行配置管理的相关操作，即通过这样的方法来实现对异地开发的支持。但是相对于CVS，SVN采用统一的二进制差异算法，所以消耗更少的网络带宽，因此更加适合基于互联网（或广域网）进行协作开发的地理上分布的团队，即版本服务器集中、单一；客户端可广泛分布。</p><p>其实上述实现方法有太多的局限性，例如网络（Internet）连接带宽的限制、防火墙以及安全问题等。真正意义上的异地开发支持，是指在不同的开发地点建立各自的存储库，通过工具提供同步功能自动或手动同步。这样做的好处是与网络无关，即便各个开发地点之间没有实时连通的网络，也可以通过E-Mail 附件等其它方式将同步包发给对方，实现手动的同步。而ClearCase就能实现这样的功能。</p><p>值得说明的是，在不同开发点建立各自存储库的方式，主要适用于两个或两个以上位于不同地点的开发团队协作开发的情况。如果仅是采用虚拟团队合作的方式，开发人员以个体的形式散落在不同地方，则更适合通过Internet 直接操作远程的配置管理服务器。<br>2.2<br>并行开发支持</p><p>在团队协作开发过程中，有两种主要的模式：集体代码权和个体代码权。采用集体代码权模式进行开发时，一段代码可能同时会被多个开发人员同时修改；而采用个体代码权模式进行开发时，每一段代码都始终被一个开发人员独享，别人需要修改时也要通过该开发人员完成。<br>而配置管理软件针对这一情况，也采用了不同的策略：Copy-Modify-Merge(拷贝、修改、合并)的并行开发模式、Check ut-Modify-Check in（签出、修改、签入）的独占开发模式。在并行开发模式下，开发人员可以并行开发、更改代码，并能够自动检测到代码冲突，并自动合并，或提示开发人员手动解决。<br>VSS最新发布版本8.0可支持并行开发模式，其它三种工具也都可支持。<br>CVS 采用线性、串行的批量提交，即依次地，一个接一个地执行提交，每成功提交一个文件，该文件的一个新的版本即被记录到版本库中，提交时用户提供的日志信息被重复地存储到每一个被修改的文件的版本历史中。但是当任何原因造成批量操作的中断时（典型原因包括：网络中断、客户端死机等），版本库往往处于一个不一致的状态：原本应该全部入库的文件只有一部分入库，很有可能版本库中的最新版本不能顺利编译，更为严重的是，随着其他的用户执行cvs update 操作，该不一致性将迅速在开发团队中扩散，从而严重影响团队的开发效率，并存在质量隐患。另外，假如该批量提交的中断没有被及时发现，开发团队往往要花更多的时间进行软件调试和排错。<br>SVN彻底消除了CVS的以上弊端。无论批量提交包含多少文件修改，只有当全部文件修改都成功入库，该提交才变得有效，才对其他用户可见；否则，无论任何原因造成中断，SVN 都会自动执行“回滚”（rollback）操作。换一个说法，SVN保证所有的修改要么全部入库生效，要么一个也不入库，即对版本库不作任何的修改。这就是SVN 的原子性提交（atomic commit）。<br>ClearCase可以很容易的产生分支，也可以很容易的将不同分支进行合并。这样一来，即便某一部分的工作被冻结或加锁，开发者仍然可以继续自己的工作（如：在软件集成期）。在这种情况，开发者可以在分支上工作，ClearCase的自动化操作和图形归并工具可以很容易的重新集成新的工作。<br>2.3<br>跨平台开发支持<br>如果企业需要从事多个不同平台下的开发工作，就需要配置管理工具能够对跨平台开发提供支持，否则势必会给开发、测试、发布等各个环节带来不便，将使大量的时间被浪费于代码的手工上传、下载中。<br>VSS仅支持Windows操作系统。<br>CVS、SVN和ClearCase支持几乎所有的操作系统和平台。但是CVS和SVN的服务器端在Unix, Linux环境下运行会更稳定可靠。<br>2.4<br>开发操作使用的便利性VSS安装、配置、使用均较简单，很容易上手使用。<br>CVS和SVN安装、配置较复杂，但使用比较简单，只需对配置管理做简单培训即可。<br>ClearCase安装、配置、使用相对较复杂，需要进行团队培训，需投入成本大概四万元。<br>2.5<br>信息安全性VSS它是基于文件系统共享实现对服务器的访问，需要共享存储目录，这样用户可以对VSS的文件夹执行删除操作，安全性不高。<br>CVS和SVN服务器有自己专用的数据库，文件存储并不采用 “共享目录”方式，所以不受限于局域网。安全性较高。<br>ClearCase采用C&#x2F;S模式，需要共享服务器上的存储目录以供客户端访问，安全性不高。<br>性能详述<br>3.1<br>VSS优点：操作简单，容易掌握；权限划分可到文件夹级，有Read、CheckOut&amp;&amp;CheckIn、Add&#x2F;Rename&#x2F;Delete、Destroy四种权限级别。</p><p>缺点：权限管理基于文件共享形式，只能从文件夹共享的权限设定对整个库文件夹的权限，而且必须要有可写权限；版本管理和分支管理只能靠人为的手工设置；版本发行时，只能手工挑选对应的版本文件进行发布。<br>最新版本VSS8.0主要增加了以下功能：<br>Ø<br>支持并行开发<br>Ø<br>支持基于Internet的远程访问模式<br>Ø<br>分布式团队协作增强<br>3.2<br>CVSCVS 诞生于 1986 年，当时作为一组 shell脚本而出现；1989年3月，Brian Berlinor用C语言重新设计并编写了CVS的代码；1993年前后，Jim Kingdon最终将CVS设计成基于网络的平台，开发者们能从Internet任何地方获得程序源代码。截至目前最新版本是2004年12月13日发布的<br>功能介绍<br>Ø<br>代码统一管理，保存所有代码文件更改的历史记录。对代码进行集中统一管理，可以方便查看新增或删除的文件，能够跟踪所有代码改动痕迹。可以随意恢复到以前任意一个历史版本。并避免了因为版本不同引入的深层BUG。<br>Ø<br>完善的冲突解决方案，可以方便的解决文件冲突问题，而不需要借助其它的文件比较工具和手工的粘贴复制。<br>Ø<br>代码权限的管理，可以为不同的用户设置不同的权限。可以设置访问用户的密码、只读、修改等权限，而且通过CVS ROOT目录下的脚本，提供了相应功能扩充的接口，不但可以完成精细的权限控制，还能完成更加个性化的功能。<br>Ø<br>支持方便的版本发布和分支功能。CVS在服务器端维护代码文档库，不同的开发者在本地机器上建立对应代码树，并利用CVS保持本地代码文档同代码文档库的一致。当由于多个开发者对文件的同时修改造成本地与库中的代码文件冲突时，CVS报告并协助解决冲突代码的合并问题。普通开发者（非管理员）对CVS的使用流程。<br>3.3<br>SVN</p><p>SVN 是一个自由&#x2F;开源版本控制系统，它管理文件和目录可以超越时间。一组文件存放在中心版本库，这个版本库很像一个普通的文件服务器，只是它可以记录每一次文件和目录的修改，这便使你可以取得数据以前的版本，从而可以检查所作的更改。从这个方面看，许多人把版本控制系统当作一种“时间机器”。</p><p>SVN 可以通过网络访问它的版本库，从而使用户可以在不同的电脑上使用。一定程度上可以说，允许用户在各自的地方修改同一份数据是促进协作。由于所有的工作都有历史版本，你不必担心由于失去某个通道而影响质量，如果存在不正确的改变，只要取消改变。<br>SVN的历史：</p><p>早在2000 年，CollabNet,Inc. (<a href="http://www.collab.net/">http://www.collab.net/</a>) 开始寻找CVS 替代产品的开发人员，CollabNet 提供了一个协作软件套件CEE (CollabNet EnterpriseEdition)，它的一个组件是版本控制系统。尽管CEE 在初始时使用CVS 作为其版本控制系统，但是CVS 的局限性在一开始就很明显，CollabNet 知道迟早要找到一个更好的替代品。遗憾的是，CVS成为了开源世界事实上的标准，因为没有更好的产品，至少是没有可以自由使用的。所以CollabNet 决定写一个新的版本控制系统，建立在CVS 思想之上的，但是修正其错误和不合理的特性。</p><p>2000 年2 月，他们联系OpenSource Development with CVS(Coriolis, 1999)的作者Karl Fogel，并且询问他是否希望为这个新项目工作，巧合的是，当时Karl 正在与朋友JimBlandy 讨论设计一个新的版本控制系统。在1995 年，他们两个曾经开办一个提供CVS支持的公司Cyclic Software，尽管他们最终卖掉了公司，但还是天天使用CVS 进行日常工作，在使用CVS 时的挫折最终促使他们认真地去考虑如何管理标记版本的数据，而且他们当时不仅仅提出了“SVN”这个名字，并且做出了SVN 版本库的基础设计。所以当CollabNet 提出邀请的时候，Karl 马上同意为这个项目工作，同时Jim 也得到了他的雇主，RedHat 软件赞助他到这个项目并提供了一个宽松的时间。CollabNet 雇佣了Karl 和Ben Collins Sussman，详细的设计从三月开始，在Behlendorf 、CollabNet、Jason Robbins 和 Greg Stein（当时是一个独立开发者，活跃在WebDAV&#x2F;DeltaV 系统规范阶段）的恰当激励的帮助下，SVN 很快吸引了许多活跃的开发者，结果是许多有CVS 经验的人们很乐于有机会为这个项目做些事情。</p><p>最初的设计小组固定在简单的目标上，他们不想在版本控制方法学中开垦处女地，他们只是希望修正CVS，他们决定SVN 匹配CVS 的特性，保留相同的开发模型，但不复制CVS 明显的缺陷。尽管它不需要成为CVS的继任者，它也应该与CVS 保持足够的相似性，使得CVS 用户可以轻松的做出转换。</p><p>经过14 个月的编码，2001 年8 月31 日，SVN 自己能够“成为服务”了，开发者停止使用CVS 保存SVN 的代码，而使用SVN 本身。</p><p>当CollabNet 开始这个项目的时候，曾经资助了大量的工作（它为全职的SVN 开发者提供薪水），SVN 像许多开源项目一样，被一些激励知识界精英的宽松透明的规则支配着。CollabNet的版权许可证完全符合Debian的自由软件方针，也就是说，任何人可以自由的下载，修改和重新发布，不需要经过CollabNet 或其他人的允许。<br>SVN和CVS功能性对比：<br>一、SVN包含绝大部分CVS功能<br>SVN 作为CVS 的重写版和改进版，其目标就是作为一个更好的版本控制软件，取代目前流行的CVS。SVN 的主要开发人员都是业界知名的CVS 专家。SVN支持绝大部分的CVS 功能&#x2F;命令；SVN 的命令风格和界面也与CVS 非常接近。当然，不同的地方正是对CVS 的改进。<br>二、全局性的版本编号<br>一个新的版本，并得到一个自增量的版本号N+1，该版本号并不针对某个特定的文件，而是全局性的、针对整个版本库的。因此，我们可以将SVN 的版本库看作是一个文件系统或文件目录树的数组。</p><p>从技术的角度来说，在SVN 中，“文件foo.c 的第5 版本”这个说法是错误的；正确的说法应该是：”文件foo.c 在版本库被修改了5 次，即执行5 次commit 后是什么样子？”。显然，在SVN 中，版本库被修改5 次后foo.c 的内容，和被修改了6 次后foo.c 的内容很可能完全一样，因为版本库的第6 次修改很可能只修改了版本库的其他部分，而并没有对foo.c 的进行修改。相反，在CVS 中，文件foo.c 的第1.1 版本和第1.2 版本总是不同的。</p><p>SVN 的全局性版本编号为SVN 带来了诸多的优势：如对目录或文件执行拷贝，无论涉及多少文件，SVN 不需要对单个文件依次执行拷贝命令，仅仅需要建立一个指向相应的全局版本号的一个指针即可。<br>三、目录的版本控制<br>CVS 只能对文件进行版本控制，不能对目录进行版本控制，因此CVS 没有任何关于文件“移动”（move）<br>操作的概念。当人为进行文件移动操作时，CVS 只能注意到，一个文件在一个位置被删除了，而在一个新位置创建了另外一个文件。由于它不会连接两个操作，因此也很容易使文件历史轨迹丢失。设置 CVS 存储库时，必须非常谨慎地为每个文件选择准确的位置，因为在设置之后，几乎就要一直使用这个位置了。</p><p>同样由于CVS 不记录目录的版本历史，CVS 不支持对文件的“重命名”（rename），人为的对文件进行重命名会使得命名前后的文件失去历史联系，而记录历史本来是版本管理的主要目的。</p><p>还有，CVS 不支持对文件的“拷贝”（copy），人为的拷贝对CVS 而言，只能看到新的文件的增加，而不能记录拷贝源文件和目标文件之间的联系。</p><p>综上所述，缺乏对文件“移动”、“重命名”、“拷贝”的支持的根源在于CVS 不能记录目录的版本历史，而这些操作在当前的软件开发过程中经常发生，这正是SVN被开发并取代CVS 的主要原因之一。</p><p>SVN 将目录作为一类特殊的文件来处理（事实上，从文件系统的角度来看，目录确实是一类特殊的文件，当目录中的子目录&#x2F;文件被删除、重命名、或新的子目录&#x2F;文件被创建时，目录的内容将发生改变）。因此，SVN 象记录普通文件的修改历史一样记录对目录的修改历史，当发生文件&#x2F;目录的移动、重命名或拷贝操作时，SVN 能够准确记录操作前后的历史联系。同样，象对文件的不同历史版本进行比较一样，SVN支持对目录的不同历史版本的比较，清晰展现目录的变化历史。<br>四、原子性提交<br>从使用者的角度来看，CVS 和SVN 都支持对多个文件修改的批量提交，但二者在实现方式上存在本质的区别。 CVS 采用线性、串行的批量提交，即依次地，一个接一个地执行提交，每成功提交一个文件，该文件的一个新的版本即被记录到版本库中，提交时用户提供的日志信息被重复地存储到每一个被修改的文件的版本历史中。</p><p>CVS 串行批量提交模式的弊端在于<br>－<br>当任何原因造成批量操作的中断时（典型原因包括：网络中断、客户端死机等），版本库往往处于一个不一致的状态：原本应该全部入库的文件只有一部分入库，很有可能版本库中的最新版本不能顺利编译，更为严重的是，随着其他的用户执行cvs update 操作，该不一致性将迅速在开发团队中扩散，从而严重影响团队的开发效率，并存在质量隐患。另外，假如该批量提交的中断没有被及时发现，开发团队往往要花更多的时间进行软件调试和排错。</p><p>CVS 即使在批量提交不发生中断时也会造成不一致：假设用户A 启动一个需要较长时间才能完成的批量提交；与此同时，用户B 执行cvs update 操作。此时，用户B 很有可能得到一个不一致的更新，即用户B 通过“更新”操作，得到用户A 的部分修改文件。</p><p>SVN 彻底消除了CVS 的以上弊端。无论批量提交包含多少文件修改，只有当全部文件修改都成功入库，该提交才变得有效，才对其他用户可见；否则，无论任何原因造成中断，SVN 都会自动执行“回滚”（rollback）操作。换一个说法，SVN 保证所有的修改要么全部入库生效，要么一个也不入库，即对版本库不作任何的修改。这就是SVN 的原子性提交（atomic commit）。</p><p>由于SVN 的原子性提交特性和全局版本编号方式，当提交成功完成时，一个唯一的、新的全局版本编号产生，而提交时用户提供的日志信息与该新的版本编号关联，只进行一次存储（区别于CVS 的按文件重复存储）。</p><p>五、支持变更集概念<br>由于SVN 的所有提交是原子性的，每次成功提交形成的唯一的全局版本号对应此次批量提交的所有文件修改，也就是说，一个SVN 版本号其实对应了一个逻辑上的变更集（change set），该变更集可能对应于对一个BUG 的修复，或者对应于对一个已有功能的改进，或者对应于一个新功能的实现。可以说，变更集是一个软件开发活动的逻辑结果，该变更集可以通过其对应的版本号在软件开发的其他过程中（如软件合并&#x2F;集成过程，软件发布管理，变更管理系统，缺陷追踪系统）被引用。因此，SVN 将版本管理从单纯的、单个的文件修改的层次通过逻辑上的抽象，上升到更便于理解和交流的开发活动的层次。<br>六、差异化的二进制文件处理<br>由于历史原因，CVS 主要是为早期的程序员设计的，CVS 能够有效处理文本文件（或ASCII文件，源代码文件），可以对文本文件进行差异化的存储、新旧版本的比较，文件合并等；但对于二进制文件，CVS 则明显力不从心。在CVS 的版本库中，对于二进制文件的历史版本，CVS 唯一能做的就是对不同的版本进行独立的、冗余的存储，哪怕版本之间其实只存在微小的差异。举例而言，一个10M<br>的二进制文件（照片、图形文件、机械设计文件、电子设计文件）假如每周修改一次，无论每次修改的大小，一年下来，仅该文件就要消耗500M<br>以上的存储空间。而且，客户端每次获取该文件的新版本都要消耗10M<br>的网络流量。</p><p>对于目前的开发团队，无论是软件开发，Web 站点的开发，手机等电子产品的研发，需要进行版本管理的不仅是源代码等文本文件，还需要管理需求文档、设计文档、测试文档、用户手册，图形图像文件，机械&#x2F;电子设计文件等诸多的二进制文件，CVS 显然不是一个好的选择。</p><p>与CVS 不同，SVN 采用统一的二进制差异算法（binary differencing algorithm），即对文本文件和二进制文件采用相同的差异比较算法，并以相同的方式在版本库中进行存储：每次提交后版本库中只存储相对于先前版本的差异，从而可以节省大量的存储空间。</p><p>该二进制差异算法不仅应用在版本的存储上，更为重要的是，SVN 对二进制文件与文本文件一视同仁，当客户端需要获取新的版本时（如执行svn update），在网络上只有版本的差异被传输，从而大大减少对网络带宽的消耗。更多细节参见“七、双向的差异化－压缩网络传输”。<br>七、<br>双向的差异化－压缩网络传输<br>如上所述，CVS 对二进制文件不能进行有效的差异化处理。对于文本文件，CVS 仅仅支持单向的差异化传输：从CVS 服务器到客户端的传输是差异化的，即执行cvs update 时，只有差异的部分从服务器传输到客户端；而当执行cvs commit 时，无论代码变化多少，CVS 都需要从客户端向服务器完整传输被修改文件的全部内容，不能只传输差异。</p><p>相反，无论是文本文件还是二进制文件，SVN 都进行双向的差异化传输，并且差异化内容还要进行压缩&#x2F;解压缩的过程：在服务器端获取差异显而易见，与CVS 类似；SVN 在客户端获取差异的秘密在于 — SVN 在客户端的工作拷贝中隐含了每个文件的一个“只读的、干净的”副本（该副本隐藏在隐含目录.svn 里，通常不可见，该副本还有更多的妙用，参见“十二、更多的本地&#x2F;离线操作”），通过比较用户在客户端的修改和该隐含的副本，SVN 获取需要真正传送到服务器的差异，并对差异进行压缩后才进行网络传输。</p><p>对CVS 而言，操作的成本（网络带宽消耗是最大的操作成本）与被修改的文件的大小成比例，而与修改本身的大小无关；对SVN 而言，操作成本只与修改本身的大小成比例，而与被修改的文件的大小无关。因此，与CVS 相比，SVN 消耗更少的网络带宽（以客户端的存储空间换取更少的带宽消耗在目前的计算环境下应该是个相当不错的选择！）。SVN 更加适合基于互联网（或广域网）进行协作开发的地理上分布的团队 — 版本服务器集中、单一；客户端广泛分布。<br>八、高效、快捷创建分支和基线<br>CVS 和SVN 都支持分支（branch）和基线（tag），通过分支与合并，可以有效支持大项目的并行开发模式；通过基线管理，可以准确标识一组文件的版本，有效进行软件发布管理和必要时的历史回溯。</p><p>但CVS 和SVN 在实现分支和基线的方式上存在很大的不同。CVS 在创建分支的时候，需要对所有进行分支的文件进行依次的操作，因此分支的建立成本（主要是建立分支所需的时间，或消耗的计算资源）与参与分支的文件数量成比例，项目越大，版本库越大，文件越多，分支的建立成本越高；基线（tag）的建立与此类似。</p><p>SVN 的分支和基线是通过执行“拷贝”来建立的：回想一下在没有引入版本管理工具的时候我们是如何进行所谓的“分支”和“基线”管理的？答案显然是“拷贝” — 我们通过“拷贝”或“备份”来建立基线；同样，为支持多个开发人员可以同时进行开发，我们为每个开发人员创建一份“拷贝”。由此看来，SVN 通过“拷贝”来建立分支和基线显得非常自然，有点“返朴归真”的意思。</p><p>由于SVN 的全局版本号特性，SVN 中分支或基线的创建过程，或SVN中的“拷贝”过程，真正的操作是在版本库中创建一个到某一全局版本号的指针（pointer），不再需要针对众多的单个文件依次执行操作。因此，该操作的成本为一个很小的常数，与项目大小，版本库大小，文件数目的多少无关；并且，分支或基线的建立不需要进行版本的冗余存储，新建立的分支或基线基本不占用版本库空间，分支的后续存储空间的开销也只与修改的大小有关。<br>九、集成Apache Web Server，提供更多的特性<br>SVN 通过与Apache Web Server 的集成，可以提供基于http&#x2F;https 协议的版本库访问机制，从而支持SVN 跨越防火墙的安全访问。除此以外，SVN 还可以利用更多的Apache 特性，包括但不限于：Apache 丰富的用户认证机制（包括通过LDAP服务器如Windows Active Directory 服务器的用户认证），基于目录路径的精细粒度的访问控制，对传输的网络流量进行压缩&#x2F;解压缩，浏览版本库目录结构等等。<br>十、支持WebDAV<br>WebDAV（Web-based Distributed Authoring and Versioning）是一种基于 HTTP 1.1 协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD 等几个HTTP 标准方法以外添加了一些新的方法，使应用程序可直接对Web Server 直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</p><p>Microsoft windows2000&#x2F;XP 及IE, Office 还有Adobe&#x2F;MicroMedia 的DW 等都支持WebDAV，这又大大增强了Web 应用的价值，以及效能。对于需要大量发布内容的用户而言，应用WebDAV 可以降低对CMS 系统的依赖，而且能够更自由的进行创作。上传、下载变得轻松自如。</p><p>SVN 通过与Apache Web Server 的集成，支持WebDAV 协议，使得业务用户（business users）或非技术用户在不安装任何版本管理客户端的情况下轻松访问SVN 版本库，不改变业务用户已有使用习惯，支持分布的业务用户对文档的评审、修改并实现版本控制，真正将软件开发的生命周期从开发&#x2F;技术团队扩展到项目的全部干系人（stakeholder），避免通过电子邮件传递文档的混乱与无序、通过Windows 操作系统共享造成的安全漏洞、病毒攻击、历史版本被覆盖或丢失、审计困难等诸多典型问题。<br>十一、更好的冲突标识与处理<br>CVS 和SVN 都支持通过分支与合并进行并行开发，并可以自动检测到合并时的冲突（conflicts），并在合并结果中以&lt;&lt;&lt;&lt;&lt;&lt; … &gt;&gt;&gt;&gt;&gt;&gt;标识合并的冲突部分。</p><p>在CVS 中，经常会出现由于用户的疏忽（如，没有注意到冲突，或没有完全处理好冲突）而将仍然带有&lt;&lt;&lt;&lt;&lt;&lt; … &gt;&gt;&gt;&gt;&gt;&gt;冲突标识符号的文件直接进行提交（commit），从而在版本库中产生垃圾版本。</p><p>SVN 有效解决了CVS 的以上问题：SVN 记录并保持文件的冲突状态，只有当用户明确执行svn resolved 命令后，该冲突状态标识才被复位，该文件才能被提交，从而大大减少了将仍然带有&lt;&lt;&lt;&lt;&lt;&lt; … &gt;&gt;&gt;&gt;&gt;&gt;冲突标识符号的文件直接进行提交的可能性。<br>十二、<br>更多的本地&#x2F;离线操作<br>众所周知，CVS 客户端的工作拷贝中包含了一个隐含目录CVS，该目录中记录了客户端需要的一些管理信息；与此类似，SVN 的客户端工作拷贝中也包含了一个隐含目录.svn，该目录中同样记录了客户端需要的一些管理信息，如版本库URL，当前访问版本号等。</p><p>与CVS 不同的是，SVN 的.svn 目录中还包含了工作拷贝中每一个文件的一个“只读的、干净的”副本。正是由于该副本的存在，使得SVN 与CVS 相比，可以执行更多的本地&#x2F;离线操作，即某些操作不需要访问版本库服务器，因此不需要存在从客户端到服务器的网络链接，当然也不消耗任何网络带宽，这进一步增强了SVN 对广域网的友好支持。<br>SVN 的以下命令可以进行离线操作：<br>svn status －<br>显示工作拷贝上的本地修改概况；<br>svn diff －显示工作拷贝上的本地修改细节，比较修改前后的内容；<br>svn revert －<br>撤销工作拷贝上的本地修改；<br>十三、<br>对符号链接进行版本管理<br>在Unix 文件系统中，符号链接（symbolic links，包括硬链接和软链接）是一种重要的文件系统元素。CVS 不能对符号链接进行版本管理；SVN 则可以对符号链接进行版本管理。<br>十四、<br>元数据管理<br>与CVS 相比，SVN 增加了元数据（metadata）管理机制。即可以对版本库中的文件或目录附加任意的“属性”（property），并记录属性的变化历史，也就是对元数据进行版本管理。一个SVN 属性是一个“属性名称&#x2F;属性值”的二元组，如“BugNumber&#x3D; 100”就是一个属性，可以将该属性附加到版本N 上，以说明版本N 改正了编号为100的BUG。</p><p>SVN 元数据的目的是提供附件的信息以满足流程或过程自动化的需要，以增强SVN 的管理能力和自动化程度。SVN 自身就通过“属性”来存储一些特殊的信息。一个使用SVN 元数据的例子：可以在一些批处理的脚本程序或SVN的钩子程序（hooks）中创建、访问、修改“属性”元数据来满足流程自动化的要求。<br>非功能性对比：性能、可用性、可扩展性：<br>一、层次化的体系架构<br>尽管CVS 是开放源代码的，但同样由于历史的原因，即使是CVS 的主要开发和维护人员也认为目前CVS 的代码很难进行后续的维护和扩展，而这正是SVN 被重写的主要原因之一。<br>SVN 具备设计良好的三层体系架构<br>－<br>版本库层（Repository Layer），版本库访问层（Repository Access Layer），和客户端层（Client Layer）。 SVN 在层与层之间定义了明确的接口，使之具备更好的扩展性。<br>SVN 的体系架构如下图所示：</p><p>二、可选的后台版本库实现<br>CVS 的版本库以普通的文件系统方式实现；SVN 的版本库支持两种实现方式：以嵌入式的数据库BerkeleyDB 实现，或，采用特定格式的普通文件系统FSFS 方式实现。二者在可扩展性、性能、备份&#x2F;恢复等方面各有特色，用户可以根据自身的实际需求进行灵活的选择。<br>三、更好的性能和可用性<br>由于CVS 主要针对文本文件的版本处理而设计，CVS 在处理大文件时存在性能和可用性问题<br>－ CVS 在执行提交时需要向服务器传输整个文件的内容。一方面，处理文件的大小受制与客户端可用内存的多少；另一方面，大文件的处理将占用服务器的绝大部分资源，可能导致服务器性能严重下降，使得其他用户无法访问和工作，甚至出现服务器宕机。</p><p>SVN 从设计上根本杜绝了CVS 的上述问题。SVN 能够处理任意大小的文件，包括比可用内存还大的文件，并且无论是在客户端还是在服务器端，SVN 始终只需要一个相对小、相对固定的内存开销<br>－ SVN 能够进行双向的差异化&#x2F;压缩的网络传输，而且无论差异的大小，SVN 始终以大小固定的管道方式或流模式（stream）执行网络传输。事实上，由于客户端参与了差异的计算，SVN 让大量的客户端一起分担服务器的处理负荷，从而从整体上提高了SVN 的性能和可用性。<br>四、可解析、格式规范的输出<br>从用户的角度来看，命令行方式下的SVN 的风格与CVS 的风格非常类似，但SVN 还是做了重大的改进：SVN 命令行方式下的输出经过了“认真、仔细”的设计，使得其输出不仅便于“人”的阅读和理解，同样便于程序脚本的自动化解析，或者说，适合“机器”的阅读和理解。因此，在SVN 下编写批量的自动化脚本程序更加容易，脚本工作更加可靠。<br>五、更好的本地化、国际化支持<br>SVN 从一开始就充分考虑到本地化（ Localization ， L10N ）<br>、国际化（Internationalization， I18N）方面的需求，无论是对多字节文件，多字节文件名的版本管理，还是客户端工具的用户界面&#x2F;输出提示信息本地化等，SVN 都比CVS 做得更好。<br>六、丰富的可选组件<br>·SVN 有大量的客户端工具和服务器工具可供选择，主流的SVN 客户端有：<br>·SVN 命令行客户端<br>－<br>支持各种操作系统平台<br>·TortoiseSVN – Windows 下与资源管理器紧密集成的图形界面客户端<br>·Subclipse – SVN 的Eclipse 插件<br>七、支持从CVS到SVN的版本库迁移<br>由于SVN 与CVS 的诸多共性和历史渊源，现有的CVS 版本库可以很方便地转换成（或迁移到）SVN 版本库格式，使得在保留原来的CVS 历史版本信息的同时在SVN 下继续使用。现成的转换工具有：cvs2svn，该转换工具由SVN 的核心开发团队开发和维护。<br>3.4<br>ClearCase优点：功能强大，版本管理和分支管理完全自动化。<br>　　缺点：权限管理只能是基于Windows的用户安全权限管理。<br>随着软件团队人员的增加，软件版本不断变化，时间的紧缺，多种平台的复杂环境，使得 ClearCase所拥有的特殊组件已成为当今软件开发人员（工程人员和管理者）所必须的工具。分布式操作使得基于Client&#x2F;Server的运算结构跨越于网上客户机和服务器，ClearCase的先进功能直接解决了原来开发团队所面临的难以处理的问题。</p><p>软件开发所面临的问题包括：对当前多种产品的开发和维护，保证产品版本的精确，重建先前发布的产品，加强开发政策的统一和对特殊版本需求的处理。通过解决这些问题，ClearCase用资源重用的方法帮助开发团队使他们所有的软件建立得更加可靠。 Rational公司的ClearCase是软件配置领域的先导，它主要基于Windows和UNIX的开发环境。它提供了全面的配置管理──包括版本控制、工作空间管理、建立管理和过程控制，而且无须软件开发者改变他们现有的环境、工具和工作方式。</p><p>ClearCase的核心功能是版本控制，它是对在软件开发进程中一个文件或一个目录发展过程进行追踪的手段。ClearCase对所有文件系统对象（包括文件、目录和链接）增强了版本控制系统功能。可定版本的文件包括源代码、可执行文件、位图文件、需求文档、设计说明、测试计划、和一些ASCII和非ASCII文件。目录的版本记录了整个组织基础资源的发展状况，包括源文件的建立、重新命名、重新构造和删除操作等。 这种版本控制系统提供了先进的版本分支和归并功能用于支持并行开发。</p><p>3.4.1<br>控制任何文件的版本<br>ClearCase可以对每一个软件组件或元件的版本进行维护和控制。ClearCase也可以维护一个非文本文件、目录和工具的版本。正如：它可以管理库文件、编译器、需求文档、<br>测试包和数据库而不仅仅是源代码。</p><p>ClearCase的元件类型可以管理版本内容。用户可以定义自己的元件类型，也可以使用ClearCase中的预定义类型：文本文件、压缩文本文件、文件、压缩文件和二进制增量文件。</p><p>ClearCase可以利用增量算法将文本文件存储在一个特殊结构的文件容器中。ClearCase采用标准的压缩技术和增量算法存储一个压缩文本文件。（这比以往的存储形式节省了50%―70%的存储空间。）<br>　　这种元件类型文件和压缩文件可以被用于控制任何操作系统文件──比如，可执行程序、程序资源库、结构数据库和结构文档文件。二进制增量文件类型可以随时被用于二进制文件格式。<br>3.4.2<br>在版本树中组织元件发展的过程　　在ClearCase中，元件版本的组织体现在版本树结构中。一个版本书的结构可以按目录结构定制，<br>还可以包含多层分支和子分支。<br>　　在一个典型的开发环境中，很多元件的版本树结构最初仅包含一个分支，即，<br>元件的版本排列在同一条线型队列中。随着时间的发展，当用户做一些错误修复、代码的组织、一些实验性修改或指定平台的开发时，它们可以给一些相关元件定义子分支，从而脱离主干进行开发。ClearCase可以支持多级的分支操作，还可以给版本或分支命名。<br>对目录和子目录进行版本控制</p><p>ClearCase可以对目录和子目录进行版本控制，允许开发者对他们数据的组织发展过程进行追踪。目录版本对一些改变进行控制，如：建立一个新文件、修改文件名、<br>建立新的子目录或在目录间移动文件等。</p><p>ClearCase也支持对目录自动进行比较和归并的操作。<br>存储数据在一个可访问的版本对象类中（VOBS）</p><p>ClearCase把所有版本控制的数据存放在一个永久、安全的存储区中，这个存储区被称为版本对象类（Version Object Bases），项目团队（或管理者）可以决定它们所需要的VOBs的数量，可以决定什么样的目录或文件需要被维护。VOBs不仅是一个可连接的文件系统而且也是网上的资源──主机可以连接任何数量的VOBs.</p><p>ClearCase VOBs的组成模式跟UNIX、Windows NT的文件系统和分布式的数据库系统非常类似。ClearCase采用Raima数据管理机制区维护VOB数据库。当在ClearCase中连接和访问时，VOB象一个标准的软件作为目录树的形式出现在客户面前，包含标准的文件对象：目录、文件、符号链接和硬链接。但事实上，文件系统已经有广泛的版本控制组件：它包含目录元素、目录元素版本、文件元素、文件元素版本、VOB动态链接和VOB硬链接。开发者也可以查看和这些文件系统对象相关的数据。这些数据包括事件记录，建立审核以及用户定义的项如：版本标签和属性。<br>3.4.3<br>使用常见的检出&#x2F;编辑&#x2F;检入范例<br>ClearCase的命令可以控制元素的变化，确保存储区有序的繁衍并使数据损坏的程度达到最小。ClearCase采用一种检出&#x2F;编辑后检入的范例，类似于传统的版本控制工具如：RCS和SCCS。ClearCase除了可以进行检出、检入以及非检出操作外，它还可以通过命令设置另外的操作，如：删除版本、建立&#x2F;删除分枝、可按时间顺序排列或结构排列顺序列出版本历史、比较版本间的差异，并且可以归并并行开发的版本。<br>　　当开始对于一个指定的文件进行工作时，该文件具有只读属性──这意味着它不能被编辑或删除。而检出操作可以对该文件的最近版本形成一个可编辑的拷贝。它无须将文件拷贝到另一区域工作。检出的注释可以被提供。当编辑完成后，该文件被检入，于是在版本树中形成一个新的版本并且将可编辑的拷贝删除。为了检验文件的变化，在检入过程中可以填入注释信息。文件一旦被检入，即刻回复到只读状态成为共享数据，可被所有成员使用。</p><p>ClearCase支持两种检出，保留以及非保留。保留检出可以保证版本历史形成的正确范围，并且同时只允许一个人做保留检出的操作。非保留检出无须保证建立一个成功的版本，如果多个用户同时对同一元素执行非保留检出，也企图进行检入操作，那么第一个检入操作被允许，而其他用户必须通过归并操作合并它们的结果。<br>丰富的注释信息和版本数据的报表</p><p>ClearCase存储了和文件系统对象相关又截然不同的信息类。这些信息实际上并不包含在对象中，它是一些额外数据。这些数据可以由ClearCase产生，也可以由用户自己定义。在VOB数据库中存储了所有的数据。</p><p>ClearCase产生的这种数据信息提供了可靠的、面向文件系统的版本注释信息。比如：这些数据可以验证在某一时刻，元素A建立了一个新的版本。用户定义的数据可以用来表达额外的功能──比如：该文件的版本曾被用于构造应用系统的4.31版。</p><p>ClearCase的操作（如：检出、检入、和版本归并）可以建立时间记录，记录数据包含这些操作信息。这些记录被存储在VOB数据库中，主要描述了该操作的属性”谁做的、做什么、什么时候、在哪个地方及为什么”，比如：敲入命令的人员的ID号，操作的种类，操作的时间，主机名称及用户填入的描述。可以通过”lshistory”的命令显示存储在VOB中的事件记录，并且可以通过历史信息浏览器提供的图形接口观察VOB中的事件记录。<br>　　用户可以针对多种目的定义数据，包含分支的名称、版本标签、元素任一版本的注释信息。</p><p>ClearCase数据的另一种应用是形成注释的文本文件。注释命令可以通过行显示的形式列出任何一个版本文本文件的内容，这使得我们可以更容易的看到什么时候在不同的地方做了添加或删除的操作。</p><p>ClearCase也可以针对文件系统对象建立客户报表。而报表的种类可以由用户自己定制输出格式。<br>3.4.4<br>通过分支功能支持并行开发<br>ClearCase支持并行（同时）开发，每一个元素都可以沿着不同的分枝同时发展，即新的版本加到独立的分支上。ClearCase可以很容易的产生分支，也可以很容易的将不同分支进行合并。这样一来，即便某一部分的工作被冻结或加锁，开发者仍然可以继续自己的工作（如：在软件集成期）。在这种情况，开发者可以在分支上工作，我们知道， ClearCase的自动化操作和图形归并工具可以让我们很容易的重新集成新的工作。<br>　　并行开发是非常重要的，因为：<br>　　（1）它允许不同的项目在同一时间使用同一资源树。<br>　　（2）它将目前不可和其他人员共享的修改成果进行隔离。<br>　　（3）它将绝对不可和其他人员共享的修改成果进行隔离（如：已发布版本中的错误修复）。<br>　　（4）它使得在软件集成期间开发工作无需停止，程序员可以先在分枝上开发，以后再集成。<br>　　为了支持并行开发，ClearCase允许进行分支建立，追踪分支的使用，文件比较，自动归并功能。<br>3.4.5<br>自动的比较和版本间的归并　　并行开发的特点是对同一元素的不同版本进行定期比较，也需要对版本间内容进行归并。在ClearCase中，对于元素或文本文件进行比较和归并的操作有两种：基于字符型和图形界面型。其中，diff命令执行多文件比较，不执行归并。而归并命令可以处理32个”成员”，并把它们生成一个独立的文件。 ClearCase可以自动辨认归并选项并实现归并。ClearCase也可以对需要归并的项目元素进行定位。如果所有的”成员”（归并元素）是同一元素的版本，系统会自动确定基础”成员”，通常是最低版本。此外，ClearCase会记录基础版本和某一归并元素版本间的差异。如果，所有的”成员”间差异互不相同，ClearCase会自动建立归并版本。如果两个或多个归并”成员”文件内容部分不同，归并功能会提示开发者选择归并内容。ClearCase也可以实现反向归并――从主分支向子分支归并。</p><p>ClearCase的加归并功能可以在归并其它分支时选择指定的版本（那些在分支上自始至终进行变化的版本）。负归并操作可以删除部分版本差异，从而形成一个新的版本，该版本除了那些被删除的变更外包含所有的改变。</p><p>2020年11月19日11:41:54 解决git log乱码问题<br>export LESSCHARSET&#x3D;utf-8</p><p>2019年12月23日14:20:20 使用git log –author&#x3D;“author” 可以查找某一个作者所有的提交</p><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><table><thead><tr><th>加入时间</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td></td><td>git log -p filename</td><td>可以显示该文件每次提交的diff</td></tr><tr><td>2020年05月06日12:33:26</td><td>git diff c286ea2c1c65d97b679141d936dcab334687f54e HEAD – ‘:!test-input’</td><td>git diff 排除文件</td></tr><tr><td></td><td>git branch -a</td><td>查看全部分支</td></tr><tr><td></td><td>git checkout -b name remote&#x2F;branch</td><td>创建本地分支并切换</td></tr><tr><td></td><td>git push origin test:test</td><td>本地分支推送到远程</td></tr><tr><td></td><td>git pull origin test</td><td>克隆远程分支到本地，不建议</td></tr><tr><td></td><td>git remote update</td><td>更新远程分支到本地</td></tr><tr><td></td><td>git merge test</td><td>尝试快速合并本地分支</td></tr><tr><td></td><td>git branch -d(-D)</td><td>尝试、强制删除本地分支</td></tr><tr><td></td><td>git tag -d xxx</td><td>删除标签</td></tr><tr><td></td><td>git push origin :test</td><td>删除远程分支</td></tr><tr><td></td><td>git remote prune origin</td><td>删除本地仓库中无效的远程分支</td></tr></tbody></table><h2 id="git-lfs"><a href="#git-lfs" class="headerlink" title="git lfs"></a>git lfs</h2><p>因为yum和apt-get经常因为有人污染源配置，导致各种难以修复的问题，无法使用。所以这里建议使用二进制安装的方式</p><p>上传  </p><ol><li>下载 wget <a href="https://packagecloud.io/github/git-lfs/packages/el/7/git-lfs-3.5.1-1.el7.x86_64.rpm/download">https://packagecloud.io/github/git-lfs/packages/el/7/git-lfs-3.5.1-1.el7.x86_64.rpm/download</a> -O git-lfs.rpm</li><li>安装 rpm -i git-lfs.rpm</li><li>初始化 git lfs install –local</li><li>追踪文件，此时会自动产生.gitattributes git lfs track “*.psd”</li><li>注意，一定要首先add .gitattributes git add .gitattributes</li><li>git add file.psd</li><li>git commit -m “Add design file”</li><li>git push origin main</li></ol><p>下载  </p><ol><li>如果你正在克隆包含大量 LFS 文件的仓库，显式使用 git lfs clone 命令可提供更好的性能：git lfs clone <a href="mailto:&#103;&#105;&#x74;&#x40;&#x62;&#x69;&#116;&#98;&#x75;&#x63;&#107;&#101;&#116;&#46;&#111;&#114;&#103;">&#103;&#105;&#x74;&#x40;&#x62;&#x69;&#116;&#98;&#x75;&#x63;&#107;&#101;&#116;&#46;&#111;&#114;&#103;</a>:tpettersen&#x2F;Atlasteroids.git</li><li>或者普通git clone后 git lfs pull</li></ol><h2 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h2><ol><li><p>添加子模块 <code>git submodule add https://github.com/OFA-Sys/Chinese-CLIP.git 20240827_wangyuliang006_clip_score_model/Chinese-CLIP</code></p></li><li><p>使用子模块</p><p>克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行如下命令完成子模块的下载：<br><code>git submodule update --init --recursive</code></p></li></ol><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ol><li>git fetch –all 拉取所有分支</li></ol><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><ol><li>git log –color –graph –pretty&#x3D;format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ci) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date&#x3D;relative | head -n 3</li></ol><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><ol><li>git remote add origin git@{repo}.git</li><li>git remote set-url origin https:&#x2F;&#x2F;{repo}.git</li></ol><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><ol><li>git pull origin {branch}</li></ol><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>git push origin –all</p><h2 id="本地修改尚未-add-想撤销"><a href="#本地修改尚未-add-想撤销" class="headerlink" title="本地修改尚未 add 想撤销"></a>本地修改尚未 add 想撤销</h2><p>2018年12月04日19:17:14 git 丢弃所有本地修改，包括新增删除和修改：git clean -xdf</p><p>2018年12月10日16:43:50 git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态<br>git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。<br>git reset –hard HASH #返回到某个节点，不保留修改。<br>git reset –soft HASH #返回到某个节点。保留修改<br>git clean -xdf 清除未提交的新文件及文件夹</p><ol><li>git add 添加多余文件</li></ol><p>git add 如果添加了错误的文件的话撤销操作</p><p>git status 先看一下add 中的文件</p><p>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了</p><p>git reset HEAD XXX&#x2F;XXX&#x2F;XXX.java 就是对某个文件进行撤销了</p><h2 id="git-commit-撤销"><a href="#git-commit-撤销" class="headerlink" title="git commit 撤销"></a>git commit 撤销</h2><p>如果不小心 弄错了 git add后 ， 又 git commit 了。</p><p>先使用 git log 查看节点</p><p>git reset commit_id （回退到上一个 提交的节点 代码还是原来你修改的）</p><p>git reset –hard commit_id （回退到上一个commit节点， 代码也发生了改变，变成上一次的）</p><h2 id="git-push错误提交"><a href="#git-push错误提交" class="headerlink" title="git push错误提交"></a>git push错误提交</h2><p>使用 git revert还原已经提交的修改</p><p>此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交</p><p>git revert HEAD 撤销前一次 commit</p><p>git revert HEAD^ 撤销前前一次 commit</p><p>git revert commit-id (撤销指定的版本，撤销也会作为一次提交进行保存）</p><p>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。</p><h2 id="git-tag操作"><a href="#git-tag操作" class="headerlink" title="git tag操作"></a>git tag操作</h2><p>git tag -l<br>git tag -a v1.2 9fceb02<br>git show v1.2<br>git push origin v1.2</p><h2 id="ubuntu-下升级git"><a href="#ubuntu-下升级git" class="headerlink" title="ubuntu 下升级git"></a>ubuntu 下升级git</h2><p>1、查看git版本<br>git –version</p><p>2、升级Git<br>sudo apt update  # 更新源<br>sudo apt install software-properties-common # 安装 PPA 需要的依赖<br>sudo add-apt-repository ppa:git-core&#x2F;ppa    # 向 PPA 中添加 git 的软件源<br>sudo apt-get update<br>sudo apt-get install git</p><h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>2024年04月16日11:15:59 github F2A recovery codes。 使用Microsoft Authenticator APP 扫码</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">44696-0c382</span><br><span class="line">f10ae-8a318</span><br><span class="line">62f15-94a5b</span><br><span class="line">7fda9-eb1f1</span><br><span class="line">e3241-b5e23</span><br><span class="line">4fcb9-979d5</span><br><span class="line">e7006-4ab3f</span><br><span class="line">5990f-16889</span><br><span class="line">4fdd4-54992</span><br><span class="line">fb643-a450a</span><br><span class="line">f9a95-11a24</span><br><span class="line">a1d20-e0431</span><br><span class="line">7c3c6-5c269</span><br><span class="line">ecdac-e34b9</span><br><span class="line">b5a18-0df10</span><br><span class="line">25232-4a892</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>2019年04月10日10:20:18 git操作时一定要注意git库是不是在上层目录中，这样会把上层提交</p><p>2019年04月17日19:40:03 git报错 fatal: refusing to merge unrelated histories<br>在你操作命令后面加–allow-unrelated-histories</p><p>2020年03月23日12:28:21 git保留空目录<br>我们可以直接在 logs 里面写一个 .gitignore 文件，内容如下：<br> *<br> !.gitignore<br>然后 git add logs&#x2F;.gitignore</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统及工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang深度剖析</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/202408Golang%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/202408Golang%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串存储与表示"><a href="#字符串存储与表示" class="headerlink" title="字符串存储与表示"></a>字符串存储与表示</h1><p><a href="https://cloud.tencent.com/developer/article/2029043">【Golang】深究字符串——从byte rune string到Unicode与UTF-8</a></p><h2 id="UNICODE"><a href="#UNICODE" class="headerlink" title="UNICODE"></a>UNICODE</h2><ol><li><p>ASCII码<br>通过数字电路的知识，我们知道使用二进制对信息进行编码与度量。最初现代计算机由美国人发明使用，自然而然就考虑把英语进行编码，所以<strong>ASCII码就是英语字符对应的二进制位</strong>，而且一直沿用至今，ASCII码占用1个字节，最高位统一规定为0，所以只使用了7位，一共可以表示27&#x3D;128个字符，包括32个不能打印的字符。</p></li><li><p>Unicode<br>现代计算机早已不是美国一家独大，互联网更是让世界互联互通。但是文字确实多种多样，各个国家拥有一套编码规则，同一个二进制数会被不同编码解释为不同符号。如果每次不把编码方式勾兑清楚，谁也不知道该怎么解码。有没有不需要勾兑的方式？有，就是<strong>抛开各个国家独有的编码方式，统一使用一个编码方式：Unicode</strong></p></li></ol><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><ol start="3"><li>UTF-8<br><strong>Unicode规定了字符的二进制代码，但是却没有规定如何存储</strong>。而且，各个字符占的字节是可能不同的，比如汉字很多都有10几位二进制，可能需要2个字节，3个字节，甚至4个字节。虽有unicode对应，肯定是该多少字节就存多少字节，而不是每个字符都存相同大小字节，毕竟unicode有100多万，全存相同大小字节，肯定浪费空间。但是就有了最终要解决的问题：什么时候该读3个字节以表示1个字符，什么时候该读1个字节以表示字符？</li></ol><p><strong>UTF-8就是存储Unicode的方式</strong>，但不是唯一的，其他还有utf-16,utf-32</p><p>什么时候读1个字节的字符？<br>字节的第一位为0，后面7位为符号的unicode码。所以这样看，英语字母的utf-8和ascii一致。</p><p>什么时候读多个字节的字符？<br>对于有n个字节的字符，（n&gt;1）….其中第一个字节的高n位就为1，换句话说：</p><ol><li>第一个字节读到0，那就是读1个字节  </li><li>第一个字节读到n个1，就要读n个字节  </li><li>然后第一个字高n位后1位设为0，后续其他字节前两位都设为10</li></ol><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>xxxxxxx # 读<span class="number">1</span>个字节</span><br><span class="line"><span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx # 读两个字节</span><br><span class="line"><span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx #读<span class="number">3</span>个字节</span><br><span class="line"><span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx #读<span class="number">4</span>个字节</span><br><span class="line"></span><br><span class="line">Unicode符号范围     |        UTF<span class="number">-8</span>编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span><span class="number">-0000</span> <span class="number">007</span>F | <span class="number">0</span>xxxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0080</span><span class="number">-0000</span> <span class="number">07</span>FF | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0800</span><span class="number">-0000</span> FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span><span class="number">-0010</span> FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是Go 语言中最常用的基础数据类型之一，实际上字符串是一块连续的内存空间，一个由字符组成的数组，既然作为数组来说，它会占用一片连续的内存空间，这片连续的内存空间就存储了多个字节，整个字节数组组成了字符串</p><p>Go语言使用UTF-8编码，为此，Go在代码中引入了一个新术语，称为 rune。rune是int32的类型别名；byte其实是uint8的别名</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>unicode是一种编码方式，任意字符可以使用一个unicode单位表示，即int32，即rune</li><li>字符串由byte数组组成，即utf-8编码存储的unicode</li></ol><p>所以字符串比如“golang字符串”，对应[]rune的size是6+3，对应[]byte的size是6+9</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务系统设计参考</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202203%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/202203%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/201805%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/201805%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="相关技术栈"><a href="#相关技术栈" class="headerlink" title="相关技术栈"></a>相关技术栈</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h2 id="java开发套件"><a href="#java开发套件" class="headerlink" title="java开发套件"></a>java开发套件</h2><h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><h2 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h2><h2 id="hbase"><a href="#hbase" class="headerlink" title="hbase"></a>hbase</h2><h2 id="oozie"><a href="#oozie" class="headerlink" title="oozie"></a>oozie</h2><h2 id="flume"><a href="#flume" class="headerlink" title="flume"></a>flume</h2><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h2 id="kakfa"><a href="#kakfa" class="headerlink" title="kakfa"></a>kakfa</h2><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><h2 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h2><h2 id="flink"><a href="#flink" class="headerlink" title="flink"></a>flink</h2><h2 id="elk"><a href="#elk" class="headerlink" title="elk"></a>elk</h2><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p><a href="https://www.zhihu.com/question/21380122/answer/301323291">我是学Java的，想尝试大数据和数据挖掘，该怎么规划学习？</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iphone使用配置和心得</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>iphone并不是最好的手机，甚至很多时候也是捏着鼻子在用，只是使用习惯了，没有动力和精力迁移罢了</p><ol><li><strong>iphone12仍然是主力机里最薄最小的</strong>，这对我来说是最大的吸引力。现在的小米14也能做到相近的水平，保持关注</li><li>因为日常开发更多使用<strong>MacBook，跟iphone的互联互通最流畅</strong>，所以暂时没有把iphone换掉的动力</li><li>iphone的马达震动质感更强，换过一段时间的华为，总是错过消息。但是现在可以使用手环来补缺，<strong>消息提醒方面华为的手环还是很香的</strong></li><li>在此顺便cue一下<strong>iwatch，基本需要一天一充电</strong>，充完电还经常忘了带，妥妥的电子垃圾</li></ol><h1 id="iphone"><a href="#iphone" class="headerlink" title="iphone"></a>iphone</h1><p>软件配置</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E4%B8%BB%E5%B1%8F.PNG" class="" title="iphone主屏"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E5%89%AF%E5%B1%8F.PNG" class="" title="iphone副屏"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E8%B4%9F%E5%B1%8F.png" class="" title="iphone负屏"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8.png" class="" title="iphone软件列表"><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ol><li><p><strong>备忘录APP</strong>和<strong>提醒事项APP</strong>都是实时同步，很好用。二者配合已经成为我的工作区，备忘录负责维护项目安排工作，提醒事项负责安排具体生活事项的执行时间</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/%E5%A4%87%E5%BF%98%E5%BD%95%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" class="" title="备忘录工作区"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/%E6%8F%90%E9%86%92%E4%BA%8B%E9%A1%B9%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" class="" title="提醒事项工作区"></li><li><p><strong>屏幕使用时间APP</strong>不要全局共享，特别注意全部设备都要关闭，否则会出现不显示app图标的bug</p></li><li><p><strong>日历APP</strong>有一个致命缺陷，不能轻松的管理一个分类的日程，只能按照日期来看，也就是说其实没有办法快速查找和管理日程，比如maybe；schedule不能直接列出来，也就没办法提前做或者调整顺序</p></li></ol><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ol><li><strong>通讯录</strong>只存在于本机，垃圾玩意儿不好用。可以尝试都绑定到微信上</li><li>现在连电动车、手环都可以做到<strong>NFC复制</strong>，垃圾苹果至今没有开放，shame for apple!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iphone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据调度任务技术研究</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="数据地图"><a href="#数据地图" class="headerlink" title="数据地图"></a>数据地图</h1><p><a href="http://factory.data.ke.com/tableSearch">http://factory.data.ke.com/tableSearch</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webRTC开发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="声网"><a href="#声网" class="headerlink" title="声网"></a>声网</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>&#x2F;Users&#x2F;niuqiang&#x2F;Downloads&#x2F;实时多模态大模型X声网RTC-20240701.pdf</p><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><p>最基础版约合403.2元&#x2F;千小时 <img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/202408_shengwang_webrtc_price.png" class="" title="细节"></p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p><a href="https://console.shengwang.cn/overview">https://console.shengwang.cn/overview</a></p><p>水晶球。可以从咱的账号控制台进去，查看通话详情。<br><a href="https://doc.shengwang.cn/doc/analytics/general/landing-page">https://doc.shengwang.cn/doc/analytics/general/landing-page</a></p><p>临时token:<br>007eJxTYJjQs3rPWf2LaU&#x2F;&#x2F;rshgUjLdP7PrybG6eUl6SnH&#x2F;PEsLjDsUGMwNjM0tLc0Mk43MDE2S04wtk9PMDC2TjYHihqaGpua3T91LawhkZOhIM2dhZIBAEJ+FoSS1uISBAQCWlCAK<br>频道名: test<br>Token 将于 September 10, 2024 10:15 AM UTC 过期</p><h2 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h2><p>安卓客户端开发 <a href="https://doc.shengwang.cn/doc/rtc/android/landing-page">https://doc.shengwang.cn/doc/rtc/android/landing-page</a></p><p>iOS<br><a href="https://doc.shengwang.cn/doc/rtc/ios/landing-page">https://doc.shengwang.cn/doc/rtc/ios/landing-page</a></p><p>Android<br><a href="https://doc.shengwang.cn/doc/rtc/android/landing-page">https://doc.shengwang.cn/doc/rtc/android/landing-page</a></p><p>web<br><a href="https://doc.shengwang.cn/doc/rtc/javascript/landing-page">https://doc.shengwang.cn/doc/rtc/javascript/landing-page</a></p><h2 id="服务端开发（虚拟人）"><a href="#服务端开发（虚拟人）" class="headerlink" title="服务端开发（虚拟人）"></a>服务端开发（虚拟人）</h2><p>从rtc 获取音频，pcm&#x3D;&#x3D;vad&#x3D;&#x3D;ars&#x3D;&#x3D;llm&#x3D;&#x3D;tts&#x3D;&#x3D;》 rtc</p><p>服务端 Java SDK文档地址 @郑晓峰<br><a href="https://doc.shengwang.cn/doc/rtc-server-sdk/java/overview/product-overview">https://doc.shengwang.cn/doc/rtc-server-sdk/java/overview/product-overview</a></p><p>go sdk和 demo @魏洪钦<br><a href="https://github.com/AgoraIO-Extensions/Agora-Golang-Server-SDK/tree/main">https://github.com/AgoraIO-Extensions/Agora-Golang-Server-SDK/tree/main</a><br><a href="https://github.com/AgoraIO-Extensions/go-aigc-agent-demo">https://github.com/AgoraIO-Extensions/go-aigc-agent-demo</a></p><p>rtc和rtm的 linux sdk访问声网的rtn哪个端口</p><p>tcp：80，443，1080，8000，8443，9700，25000；<br>udp：53, 1080，8000，8443，8913，9700，25000，4000-4050</p><h2 id="服务端开发（通道管理）"><a href="#服务端开发（通道管理）" class="headerlink" title="服务端开发（通道管理）"></a>服务端开发（通道管理）</h2><p><a href="https://doc.shengwang.cn/doc/rtc/restful/channel-management/operations/post-dev-v1-kicking-rule">服务端 API</a> 看起来是做项目运营管理用的，不是服务端开发</p><h2 id="服务端开发（token服务器）"><a href="#服务端开发（token服务器）" class="headerlink" title="服务端开发（token服务器）"></a>服务端开发（token服务器）</h2><p><a href="https://doc.shengwang.cn/doc/rtc/android/basic-features/token-authentication">https://doc.shengwang.cn/doc/rtc/android/basic-features/token-authentication</a></p><p>golang demo<br><a href="https://github.com/AgoraIO/Tools/blob/master/DynamicKey/AgoraDynamicKey/go/sample/rtctokenbuilder2/sample.go">https://github.com/AgoraIO/Tools/blob/master/DynamicKey/AgoraDynamicKey/go/sample/rtctokenbuilder2/sample.go</a></p><h2 id="RTM"><a href="#RTM" class="headerlink" title="RTM"></a>RTM</h2><p>1对1发送文本信息只能使用另外的RTM通道，现在还没有很好的融合</p><p><a href="https://doc.shengwang.cn/doc/rtm2/homepage">https://doc.shengwang.cn/doc/rtm2/homepage</a></p><h1 id="跟进过程归档"><a href="#跟进过程归档" class="headerlink" title="跟进过程归档"></a>跟进过程归档</h1><p>2024-09-05 16:13:54 技术对接，正常操作的情况下，手动干预一次</p><h1 id="火山"><a href="#火山" class="headerlink" title="火山"></a>火山</h1><h2 id="价格-1"><a href="#价格-1" class="headerlink" title="价格"></a>价格</h2><p>基础版400元&#x2F;千小时</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/202409_valcano_webrtc_price.png" class="" title="基础版"><p>但是有个100万分钟可以薅</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/202409_valcano_webrtc_priceoff.png" class="" title="100万分钟优惠"><h2 id="控制台-1"><a href="#控制台-1" class="headerlink" title="控制台"></a>控制台</h2><p>临时token：<br>00166b5cf21580473015c39df69SQC2pzYCTnzaZs6242YLAHRlc3RDaGFubmVsCABuaXVxaWFuZwYAAADOtuNmAQDOtuNmAgDOtuNmAwDOtuNmBADOtuNmBQDOtuNmIACJ5vmkVa9B9PZN2k+yVBRIg5ilc&#x2F;j6gFlTLRtEHe86pw&#x3D;&#x3D;</p><p>此临时Token将于2024-09-13 11:51到期</p><p>APP_ID &#x3D; “66b5cf21580473015c39df69”;<br>APP_KEY &#x3D; “a97642a1a9d2476d80f3ccba79880c9d”;</p><h2 id="服务端开发（通道管理）-1"><a href="#服务端开发（通道管理）-1" class="headerlink" title="服务端开发（通道管理）"></a>服务端开发（通道管理）</h2><p>火山的<a href="https://www.volcengine.com/docs/6348/69815">服务端 OpenAPI 参考</a> 看起来可以在服务端实现虚拟人，与客户端通信</p><h2 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h2><h2 id="虚拟人开发"><a href="#虚拟人开发" class="headerlink" title="虚拟人开发"></a>虚拟人开发</h2>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生多模态大模型及相关技术研究</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E5%8E%9F%E7%94%9F%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E5%8E%9F%E7%94%9F%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="GPT4o"><a href="#GPT4o" class="headerlink" title="GPT4o"></a>GPT4o</h1><p>发布页 <a href="https://openai.com/index/hello-gpt-4o/">https://openai.com/index/hello-gpt-4o/</a></p><p>接口文档定义 <a href="https://platform.openai.com/docs/guides/chat-completions">https://platform.openai.com/docs/guides/chat-completions</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多模态大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新项目模板</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202409%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202409%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="新项目模板"><a href="#新项目模板" class="headerlink" title="新项目模板"></a>新项目模板</h1><p>来自持续工作的方法和技巧</p><h2 id="简略版"><a href="#简略版" class="headerlink" title="简略版"></a>简略版</h2><ol><li>定义目标和原则。</li><li>展望结果。</li><li>头脑风暴&#x2F;集思广益。</li><li>组织整理。</li><li>明确下一步的行动方案。</li></ol><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><pre><code>概念：是什么，有什么用。概念是一种语言实操：怎么用--&gt; 产出 xxx技术调研落地：有什么优势；有什么限制优化：在场景落地的重难点--&gt; 产出 xxx研发实战架构：怎么做到的八股：直接面向面试（即money）编程--&gt; 产出 xxx深度剖析</code></pre><h2 id="STAR完整版"><a href="#STAR完整版" class="headerlink" title="STAR完整版"></a>STAR完整版</h2><ol><li>Situation<ol><li>项目背景。</li><li>当前最重要的一件事是什么（为什么是它）？</li><li>作用的对象是哪些？</li><li>还需要哪些输入？</li><li>能达成什么效果</li></ol></li><li>Task。<ol><li>自己负责的部分，注意定义边界，</li><li>解决了什么问题，</li><li>目标和任务拆分是什么</li></ol></li><li>Action。<ol><li>如何设计，各模块功能，</li><li>核心算法，技术选型是如何达成的，</li><li>清楚的知道每一个组件的工作流程以及实现原理。</li><li>怎么实现，难点在哪？</li><li>需要哪些团队合作（什么人，需要分别贡献什么）</li></ol></li><li>Result。<ol><li>达成的效果，</li><li>最好有数据能够支撑。</li></ol></li><li>你自己有哪些思考？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程师手册 </tag>
            
            <tag> STAR模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webRTC技术调研</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="音频3A算法"><a href="#音频3A算法" class="headerlink" title="音频3A算法"></a>音频3A算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>手机电脑等智能设备的普及，AI智能、5G等技术的不断发展，<strong>语音通信成为了最方便快捷的远程交流方式</strong>，会议全向麦克风、会议一体化终端等会议系统逐渐成为企业经营中的重要工具。语音质量决定了企业远程沟通协作效果，其中噪音和回声能够严重影响到语音预处理后的质量，从而降低参会人员对另一方语音的接收完整度和准确性。我们知道影响通话质量的主要因素是噪声和回声，其中噪声是语音信号在采集、传输、编码等处理过程中的无用成分，而回声就是在通话过程中从听筒听到自己讲话的声音。噪音和回声的存在令人难以忍受，<strong>如何降低噪声及回声对语音信号的影响至关重要</strong>，而音频3A算法的产生就是为了解决这些问题。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>音频数据的处理过程有个预处理过程，就是在音频数据采集完成之后的一步，音频的预处理就是用的3A处理。啸叫和回声是因为扬声器发出的声音被麦克风再拾取导致的。音频3A算法主要包含以下三个方面：</p><p>(1).声学回声消除（AEC）</p><p>(2).背景噪声抑制（ANS）</p><p>(3).自动增益控制（AGC）</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1、AEC回声消除算法原理</p><p>回声消除（AEC）是指在二线传输的两个方向上同时间、同频谱地占用线路，在线路两个方向传输的信号完全混在一起，本端发信号的回波就成为了本端信号的干扰信号，利用自适滤波器可抵消回波以达到较好的接收信号质量，即为回声消除。<strong>回声消除的原理就是利用接收到的音频与本地采集的音频做对比，添加反相的人造回声，将远端的声音消除</strong>。</p><p>2、ANS背景噪声抑制算法原理</p><p>背景噪声抑制（ANS）指的是将声音中的背景噪声识别并进行消除的处理。背景噪声分为平衡噪声和瞬时噪声，<strong>平稳噪声频谱稳定，频谱能量方差小，利用噪声的特点，对音频数据添加反向波形处理，即可消除噪声。目前，对于平稳的噪声处理已经有很多种简单方法能够进行成功抑制，但是对于生活中常见的一些瞬态噪声却没有过多解决的好办法</strong>。</p><p>瞬态噪声的共同特点就是突发性极强，在时域上呈振荡衰弱的形式出现，持续时间在十几毫秒至上百毫秒不等，在频域上分布很宽，所以在频域上瞬态噪声的频谱基本上都是和正常的语音的频谱混叠在一起的很难进行抑制。</p><p>3、AGC自动增益算法原理</p><p>自动增益控制（AGC）指当直放站工作于最大增益且输出为最大功率时，增加输入信号电平，提高直放站对输出信号电平控制的能力。<strong>其主要用于调整音量幅值，提高语音通信系统在带噪声环境中的性能</strong>。人正常交谈的音量在40-60dB之间，低于25dB的声音听起来很吃力，而超过100dB的声音会让人感到不适，AGC的作用就是将音量调整到人接受的范围。</p><p>音频响度及麦克风拾音控制是保证音视频沟通质量的重要技术手段，一般来说，音频标准、传输条件、人为失误等因素都可能导致音频信号之间出现声音突变或者响度不一致的情况，这时候就需要对音频信号放大或缩小以得到自然清晰的语音通信。</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞定-工作方法与艺术</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202407%E6%90%9E%E5%AE%9A-%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E4%B8%8E%E8%89%BA%E6%9C%AF/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202407%E6%90%9E%E5%AE%9A-%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E4%B8%8E%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式入门</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202408%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202408%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 技术与工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习入门</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202409%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202409%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-26 10:46:39 从韩阳分享开始，入门深度学习。首先是分享时的几个问题：</p><ol><li>为什么首字最慢，后面计算过程是类似的</li><li>第一个字是怎么生成的</li><li>纬度不可能枚举，怎么找到一个字的</li><li>既然都是数值计算，为什么相同输入不是相同输出</li><li>数据量大小具体在哪个位置产生影响</li></ol><p>两本书：</p><ol><li>基于Python的理论与实现 – 深度学习入门</li><li>深入浅出神经网络与深度学习</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 技术与工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灵感书单</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/%E7%81%B5%E6%84%9F%E4%B9%A6%E5%8D%95/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/%E7%81%B5%E6%84%9F%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="未读书单"><a href="#未读书单" class="headerlink" title="未读书单"></a>未读书单</h1><p>第一版按照onedrive中的分类</p><table><thead><tr><th>分类</th><th>书名</th><th>推荐语</th><th>添加时间</th></tr></thead><tbody><tr><td>编程能力</td><td>Head first 设计模式</td><td>了解设计模式和mvc</td><td></td></tr><tr><td></td><td>领域驱动设计</td><td></td><td></td></tr><tr><td></td><td>编程之道</td><td></td><td>2018年5月15日</td></tr><tr><td>公司制度</td><td></td><td></td><td></td></tr><tr><td>行业研究</td><td>深入浅出神经网络与深度学习</td><td></td><td>2023-04-08</td></tr><tr><td>八股</td><td></td><td></td><td></td></tr><tr><td>家庭与我</td><td></td><td></td><td></td></tr><tr><td>通俗文学</td><td>百年孤独</td><td></td><td></td></tr><tr><td>人物传记</td><td></td><td></td><td></td></tr><tr><td>方法论</td><td>思考，快与慢</td><td>尝试发现自己思维的优势与不足，避免无效努力</td><td>2024-06-20</td></tr><tr><td></td><td>进化：快速打开局面的职场丛林法则</td><td>非必选</td><td>2018年5月15日</td></tr><tr><td>理财</td><td>曼昆经济学</td><td></td><td></td></tr><tr><td>政经时闻</td><td>理想国</td><td></td><td>2024-06-20</td></tr><tr><td>文法哲史</td><td>血酬定律，潜规则</td><td>之后看大明王朝</td><td></td></tr><tr><td>人文社科</td><td></td><td>注意社会心理学top10</td><td></td></tr><tr><td>博弈论</td><td></td><td></td><td></td></tr><tr><td>通往奴役之路</td><td></td><td></td><td></td></tr><tr><td>独裁者手册 &amp; 商君书</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>2024年06月24日16:45:51 从豆瓣网页版拷贝，待整理</p><pre><code>宝贵的人生建议2024-02-15把时间当作朋友2023-02-15变态心理学（第6版）2024-06-24社会心理学2024-06-24软件架构基础（影印版）2024-05-26架构整洁之道2024-05-26富妈妈穷妈妈2024-05-26一本书读懂财报2024-05-26财富自由之路2024-05-26投资最重要的事2024-05-26投资中最简单的事2024-05-26彼得·林奇的成功投资2024-05-26聪明的投资者2024-05-26百万富翁快车道2024-05-26穷查理宝典2024-05-26富爸爸，穷爸爸2024-05-26小狗钱钱2024-05-26月亮与六便士2024-04-30给一个未出生孩子的信2024-04-18医生最想让你做的事2024-04-14幸福的家庭2024-04-14通往奴役之路2024-04-14态度改变与社会影响2024-04-13决策与判断2024-04-13影响力2024-04-13亲密关系2024-04-13路西法效应2024-04-13狂热分子2024-04-13社会性动物2024-04-13社会心理学2024-04-13逃避自由2024-04-13与自己和解2024-04-13瓦尔登湖2024-04-05战争与和平2024-04-05论犯罪与刑罚2024-03-30自剖2024-03-23高效能人士的七个习惯2024-03-17详谈：赵鹏2024-03-08权力与繁荣2024-03-07西方哲学史（第9版）2024-03-03与神对话2024-03-03沉思录2024-02-25中国社会各阶层分析报告2024-02-25枪炮、病菌与钢铁2024-02-21乌合之众2024-02-19若干重大决策与事件的回顾（上下卷）2024-02-15东京百年史2024-02-15分布式系统应用设计2024-02-15笔记的方法2024-02-15Redis设计与实现2024-02-15代码整洁之道2024-02-15美丽新世界2024-02-15十日谈：新冠时期故事集2024-02-15十日谈2024-02-15神们自己2024-02-15未来的序曲2024-02-15二十年目睹之怪现状2024-02-15一地鸡毛2024-02-15哲学起步2024-02-15时间从来不语，却回答了所有问题2024-02-15邓小平时代2024-02-15百年孤独2024-02-15高情商沟通2024-02-15人性的弱点2024-02-15浪潮之巅2024-02-15变量2024-02-15曾国藩的正面与侧面2024-02-15亲密关系2024-02-15非暴力沟通2024-02-15心理学与生活（第19版）2024-02-15价值2024-02-15江村经济2024-02-15曾国藩家书2024-02-15唐浩明谈曾国藩齐家之道2024-02-15繁花2024-02-15俞军产品方法论2024-02-15工作、消费主义和新穷人2024-02-15为什么伟大不能被计划2024-02-15沧浪之水2024-02-15繁花2024-02-15认知觉醒2024-02-15北京古迹史话2024-02-15独裁者手册2024-02-15研究的方法2024-02-15学习的方法2024-02-15影响力2024-02-15自我与本我2024-02-15打开心智2024-02-15勤勉的昏君崇祯2023-12-04时间的秩序2023-09-25变量4：大国的腾挪2023-04-27兴盛与危机2023-04-12学会提问 (原书第12版)2023-04-11刀锋2023-04-11爱的艺术2023-04-11批判性思维（原书第5版）2023-04-08沧浪之水2023-03-1521世纪的管理挑战2023-02-27黑客与画家2023-02-27父权制与资本主义2023-02-23公正2023-02-15HBase原理与实践2023-02-15成功，动机与目标2023-02-14中国历代政治得失2023-02-10数据分析之道：用数据思维指导业务实战2023-02-10腾讯传2023-02-10自私的基因2023-02-10华为数字化转型之道2023-02-10华为数据之道2023-02-10数字人文导论2023-02-10王阳明全集2023-02-10逆向管理2023-02-10置身事内2023-02-10TED演讲的秘密2023-02-10向上生长2023-02-10管理的实践2023-02-10影响力2023-02-10卓有成效的管理者2023-02-10要领2023-02-10态度2023-02-10用户体验要素：以用户为中心的产品设计（原书第2版）2023-02-10深层认知2023-02-10见识2023-02-10结构性改革2023-02-10格局2023-02-10联盟2023-02-07领导梯队2023-02-07筚路维艰2022-09-17江村经济2022-09-17万历十五年2022-09-17高塔下的小镇2022-05-14赢2022-03-17钢铁是怎样炼成的2022-03-04永恒的终结2022-03-04包法利夫人2021-12-23影响力2021-11-26最後的問題2021-11-12走出软件作坊2021-10-31人月神话2021-10-31安娜·卡列尼娜2021-10-30资本社会的17个矛盾2020-07-12</code></pre><p>2024年06月24日17:08:59 从onedrive文件夹中直接list，待整理</p><pre><code>├── 方法论│   ├── 35岁前要做的33件事.mobi│   ├── FBI教你破解身体语言（插图版）.mobi│   ├── facebook效应.mobi│   ├── 演讲.docx│   ├── 人件.mobi│   ├── 气场.mobi│   ├── 硬球.mobi│   ├── 面试one.docx│   ├── 影响力.mobi│   ├── 潜规则.mobi│   ├── 打开心智 (李睿秋) (Z-Library).epub│   ├── 尽管去做 ——无压工作的艺术.mobi│   ├── 营销管理(第13版).mobi│   ├── 乌合之众.mobi│   ├── 书读完了.mobi│   ├── 优势谈判.mobi│   ├── 围炉夜话.mobi│   ├── 幸福了吗.mobi│   ├── 醒世恒言.mobi│   ├── 随遇而安_孟非.mobi│   ├── 非暴力沟通 (马歇尔•卢森堡) (Z-Library).epub│   ├── 人性的弱点.mobi│   ├── 心理控制术.mobi│   ├── 麦肯锡方法.mobi│   ├── 演讲与口才.txt│   ├── 我不是教你诈(1－5合集).mobi│   ├── 不生病的智慧.mobi│   ├── 别为小事抓狂.mobi│   ├── 我们如何思维.mobi│   ├── 把时间当朋友.mobi│   ├── 餐巾纸的背面.mobi│   ├── 上班族必懂的office天择定律.mobi│   ├── 宝贵的人生建议 (凯文·凯利) (Z-Library).epub│   ├── 把时间当作朋友(第3版) (李笑来) (Z-Library).epub│   ├── 乔布斯的演讲稿.docx│   ├── 如何阅读一本书.mobi│   ├── 拆掉思维里的墙.mobi│   ├── 遇见未知的自己.mobi│   ├── 免费游戏的陷阱.txt│   ├── 遇见未知的自己.txt│   ├── 好妈妈胜过好老师.mobi│   ├── 怎样说话才打动人.mobi│   ├── 蔡康永的说话之道.mobi│   ├── 按自己的意愿过一生 [王潇]【微信：zsbyg199】.mobi│   ├── 大学生是怎么废掉的.pdf│   ├── 金字塔原理（麦肯锡40年经典培训教材） (芭芭拉·明托) (Z-Library).epub│   ├── 搞定Ⅰ无压工作的艺术(全球工作者都在学习使用的GTD时间管理系统) (戴维·艾伦) (Z-Library).epub│   ├── 每天懂一点色彩心理学.mobi│   ├── 《人性的弱点》完整版.txt│   ├── 当我谈跑步时，我谈些什么.mobi│   ├── 乌合之众——大众心理研究.txt│   ├── 大学只有四年，绝对经不起挥霍.docx│   └── 思考的技术：思考力决定竞争力（节选）.mobi├── 人物传记│   ├── 李鸿章传.mobi│   ├── 王尔德童话.mobi│   ├── 纳兰词笺注.mobi│   └── 乔布斯的魔力演讲.mobi├── 家庭与我│   ├── 中国生育成本报告2022版.pdf│   └── 亲密关系（十周年纪念版） (罗兰·米勒,Rowland S. Miller) (Z-Library).epub├── 政经时闻│   ├── 35岁前要上的33堂理财课.mobi│   ├── Rework － Jason Fried _ Da(和谐)vid Heinemeier Hansson.mobi│   ├── W.钱·金___莫博涅.蓝海战略.mobi│   ├── 价值 (张磊 [张磊]) (Z-Library).epub│   ├── 华尔街.mobi│   ├── 战国策.mobi│   ├── 乡土中国 (费孝通) (Z-Library).epub│   ├── 江村经济 (费孝通) (Z-Library).epub│   ├── 中县干部 (冯军旗) (Z-Library).pdf│   ├── 生育制度 (中学图书馆文库) (费孝通 [费孝通]) (Z-Library).epub│   ├── 《新民说+坐待天明》+作者：许章润.mobi│   ├── 大败局上-吴晓波.txt│   ├── 大败局下-吴晓波.txt│   ├── 万物简史.mobi│   ├── 价格理论.mobi│   ├── 大而不倒.mobi│   ├── 时间简史.mobi│   ├── 浪潮之巅.mobi│   ├── 证券分析.mobi│   ├── 黄金时代.mobi│   ├── 大而不倒.txt│   ├── 浩荡两千年(全文阅读).txt│   ├── 东京百年史.mobi│   ├── 十亿消费者.mobi│   ├── 卢瑟经济学.mobi│   ├── 推销员之死.mobi│   ├── 时代三部曲.mobi│   ├── 浩荡两千年.mobi│   ├── 激荡三十年.mobi│   ├── 贫穷的本质.mobi│   ├── 跌荡一百年.mobi│   ├── 金融的逻辑.mobi│   ├── 推销员之死.txt│   ├── 贫穷的本质.txt│   ├── 跌荡一百年.txt│   ├── 毛泽东选集1-5（全）.rar│   ├── 毛泽东选集_1-5卷.mobi│   ├── 通往奴役之路(全文阅读).txt│   ├── 上帝掷骰子吗.mobi│   ├── 大败局（上）.mobi│   ├── 大败局（下）.mobi│   ├── 富爸爸穷爸爸.mobi│   ├── 通往奴役之路.mobi│   ├── 富爸爸穷爸爸.txt│   ├── 《浪潮之巅》TXT下载（全本）作者：吴军.txt│   ├── 原来这才是春秋.mobi│   ├── 曼昆经济学原理.mobi│   ├── 朱镕基答记者问.mobi│   ├── 牛奶可乐经济学.mobi│   ├── 我们台湾这些年_讲述台湾老百姓自己的故事.mobi│   ├── 中国历代政治得失 (钱穆) (Z-Library).epub│   ├── 历代经济变革得失 - 吴晓波.mobi│   ├── 活着就为改变世界.mobi│   ├── 中国生育成本报告2022版.pdf│   ├── 历史是个什么玩意儿.mobi│   ├── 格雷厄姆论价值投资.mobi│   ├── 谷歌吴军：数学之美.mobi│   ├── 资治通鉴（柏杨版）.mobi│   ├── 毛泽东选集（第一卷）.mobi│   ├── 毛泽东选集（第三卷）.mobi│   ├── 毛泽东选集（第二卷）.mobi│   ├── 毛泽东选集（第四卷）.mobi│   ├── 从总体支配到技术治理_基于中国30年改革经验的社会学分析_渠敬东.caj│   ├── 八次危机中国的真实经验 (温铁军) (Z-Library).epub│   ├── 东京百年史：从江户到昭和-爱德华·赛登施蒂克.txt│   ├── 为什么中国人勤劳而不富有.mobi│   ├── 经济学的思维方式（节选）.mobi│   ├── 置身事内：中国政府与经济发展 (兰小欢) (Z-Library).epub│   ├── 财务自由之路系列（全六册）【全球销量1000万册，连续110周雄居德国图书排行榜榜首！】 (博多·舍费尔) (Z-Library).epub│   ├── 哈耶克作品集：通往奴役之路自由宪章致命的自负 ([英]哈耶克) (Z-Library).mobi│   └── 独裁者手册：为什么坏行为几乎总是好政治（补全版） (布鲁斯·布鲁诺·德·梅斯奎塔,阿拉斯泰尔·史密斯) (Z-Library).epub├── 文法哲史│   ├── MaSiLuo.pdf│   ├── [新世纪万有文库]理想丈夫与不可儿戏-王尔德的两出喜剧.余光中译.辽宁教育出版社(1998).pdf│   ├── [外国名人书话系列]王尔德读书随笔[爱尔兰]王尔德.张介明译.上海三联书店(1999).pdf│   ├── 论语.mobi│   ├── 散文诗.docx│   ├── 巨婴国.mobi│   ├── 叫魂：1768年中国妖术大恐慌.epub│   ├── 食南之徒 (马伯庸) (Z-Library).epub│   ├── 乐府诗集.mobi│   ├── 警世通言.mobi│   ├── 论语全解.mobi│   ├── 社会转型_发展社会学的新议题_孙立平.caj│   ├── 变态心理学.azw3│   ├── 论美国的民主.mobi│   ├── 马斯洛人本哲学 (马斯洛 [马斯洛]) (Z-Library).epub│   ├── 道德经古今正解.mobi│   ├── 郑渊洁童话全集.mobi│   ├── 郑渊洁童话全集.txt│   ├── 对重刑主义的忧思_顾德瑞.caj│   ├── 二十年目睹之怪现状.mobi│   ├── 笔杆子、画笔和毒药[爱尔兰]王尔德.杨东霞、罗汉等译.浙江文艺出版社(2007).pdf│   ├── 作为意志和表象的世界.mobi│   ├── 怪诞行为学（升级版）.mobi│   ├── 两极化刑事政策之批判_黄华生.caj│   ├── 对我国重刑主义的反思_胡学相.caj│   ├── 作为意志和表象的世界_叔本华.txt│   ├── 东京百年史从江户到昭和1867-1989 (爱德华·赛登施蒂克, 谢思远, 刘娜) (Z-Library).epub│   ├── 法家重刑思想的逻辑分析_霍存福.caj│   ├── 崇祯往事：明帝国最后的图景（禁书 崇祯：勤政的亡国君 第一版） (陈梧桐) (Z-Library).epub│   └── 给一个未出生孩子的信（剖心之作，一个女人献给世界上所有女人的书，也是一个女人献给世界上所有“男人”的书 理想国出品） (奥丽娅娜·法拉奇) (Z-Library).epub├── 编程能力│   ├── 1097825528836019620.JPG│   ├── 11936297069687671408.PNG│   ├── 13577974351240529508.JPG│   ├── 2022-故障全流程及处理规范宣讲.pptx│   ├── 20220311——AIT.pptx│   ├── 2022年语音语言技术部质量宣讲.pdf│   ├── 21年至今故障整理-先刚老师.pptx│   ├── 51CTO下载-SQL学习指南(第2版).pdf│   ├── BRPC开发手册.pdf│   ├── C++ Primer Plus（第6版）_中文版_带书签_超清.pdf│   ├── C++ Primer（第5版）_带书签_高清完整版.pdf│   ├── C++ 程序设计语言：第1~3部分（原书第4版）.pdf│   ├── C++ 程序设计语言：第4部分 标准库（原书第4版）.pdf│   ├── C++编程思想（两卷合订本）.pdf│   ├── DevOps软件架构师行动指南@www.java1234.com.pdf│   ├── FunctionalProgrammingForTheRestOfUs.cn.md│   ├── Getting Real － 37signals.mobi│   ├── Go工程效率实践.pptx│   ├── LeetCode 101 - A LeetCode Grinding Guide (C++ Version).pdf│   ├── Linux基础知识体系图│   │   ├── 1 基础篇.png│   │   ├── 2 系统操作篇.png│   │   ├── 3 系统管理篇.png│   │   ├── 4 Shell篇.png│   │   ├── 5 文本操作篇.png│   │   ├── 6 服务管理篇.png│   │   └── 完整版-Linux基础知识体系.png│   ├── Linux多线程服务端编程使用muduo C++网络库 (陈硕 [陈硕]) (Z-Library).epub│   ├── MySQL最佳实践.pdf│   ├── Redis设计与实现 (黄健宏) (Z-Library).epub│   ├── Spring揭秘.pdf│   ├── [代码整洁之道].(美)马丁.扫描版.pdf│   ├── deloitte-cn-innovation-conversational-ai-is-reshaping-the-human-machine-interac.pdf│   ├── designpatterns1.jpg│   ├── designpatterns2.jpg│   ├── game-programmer-zh-cn.pdf│   ├── modern-cpp-tutorial-zh-cn.pdf│   ├── mysql5.7-manual-en.a4.pdf│   ├── zh-google-styleguide-20220529.pdf│   ├── 剑指OFFER  名企面试官精讲典型编程题  第2版.pdf│   ├── 设计模式.jpg│   ├── 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） 周志明.pdf│   ├── 代码整洁之道 (马丁(Robert C. Martin)) (Z-Library).epub│   ├── 【买卖真房源】400语音识别宣导材料-20220222.pptx│   ├── 杂事中的小幸福_傅昆.pptx│   ├── 服务云技术方案评审-0710.pptx│   ├── 小贝训练场用户手册0222.pptx│   ├── 【云课堂】第七期第2讲《顺风车稳定性实践》.pdf│   ├── 服务稳定性建设教科书-贝壳语音.pdf│   ├── 推荐系统总结思维导图.jpg│   ├── 数据密集型应用系统设计 (Martin Kleppmann) (Z-Library).epub│   ├── 家装现场委托标准作业规范_1027.pptx│   └── 凤凰架构：构建可靠的大型分布式系统 (周志明) (Z-Library).epub├── 行业研究│   ├── 银行数字化转型(一部指导银行业进行数字化转型的方法论著作，为银行的数字化转型给出了完整的方案。) (付晓岩 [付晓岩]) (Z-Library).epub│   ├── 神经网络与深度学习 (邱锡鹏) (Z-Library).pdf│   ├── 华为数字化转型之道 (华为公司企业架构与变革管理部) (Z-Library).epub│   └── 俞军产品方法论（互联网产品界里程碑式作品，产品经理进阶读物。字节跳动CEO张一鸣、百度CTO刘建国鼎力推荐。） (俞军 [俞军]) (Z-Library).epub├── 通俗文学│   ├── 围城.TXT│   ├── 孟子.mobi│   ├── 道连·葛雷的画像[爱尔兰]王尔德.荣如德译.上海译文出版社(2006).pdf│   ├── 全宋词.mobi│   ├── 沉思录.mobi│   ├── 钱锺书.宋诗选注.mobi│   ├── 狱中记[爱尔兰]王尔德.孙宜学译.南海出版公司(1998).pdf│   ├── 沧浪之水 (阎真) (Z-Library).epub│   ├── 百年孤独 (根据马尔克斯指定版本翻译,未做任何增删) (加西亚•马尔克斯, 范晔) (Z-Library).epub│   ├── 人类简史.mobi│   ├── 太平广记.mobi│   ├── 浮生六记.mobi│   ├── 浮生六记.txt│   ├── 李嘉诚的7封信.docx│   ├── 曾国藩家书 - 曾国藩.mobi│   ├── 唐诗三百首.mobi│   ├── 病菌与钢铁.mobi│   ├── 社会契约论.mobi│   ├── 王尔德全集.第1卷.小说童话.荣如德、巴金等译.pdf│   ├── 王尔德全集.第2卷.戏剧.王阳等译.pdf│   ├── 王尔德全集.第3卷.诗歌.杨烈、黄杲炘等译.pdf│   ├── 王尔德全集.第4卷.评论随笔.杨东霞、杨烈等译.pdf│   ├── 王尔德全集.第5卷.书信-上.苏福忠、高兴等译.pdf│   ├── 王尔德全集.第6卷.书信-下.常绍民、沈弘等译.pdf│   ├── 王尔德诗选[英]王尔德.袁宪军译.福建教育出版社(2010).pdf│   ├── 灵魂的毁灭[爱尔兰]王尔德.姜允麟译.黑龙江人民出版社(1988).pdf│   ├── 世说新语译注.mobi│   ├── 仓央嘉措诗集.mobi│   ├── 老子白话今译.mobi│   ├── 王尔德喜剧选[爱尔兰]王尔德.张南峰译.海峡文艺出版社(1990).pdf│   ├── 王尔德作品集[爱尔兰]王尔德.黄源深等译.人民文学出版社(2001).pdf│   ├── 唐诗三百首补注.mobi│   ├── 百家讲坛－和珅.mobi│   ├── 百家讲坛－水浒.mobi│   ├── 百家讲坛－老子.mobi│   ├── 假如给我三天光明.mobi│   ├── 百家讲坛－多尔衮.mobi│   ├── 百家讲坛－讲聊斋.mobi│   ├── 百家讲坛－读史记.mobi│   ├── 假如给我三天光明.txt│   ├── 枪炮、病菌与钢铁.txt│   ├── 曾国藩的正面与侧面 完整版.mobi│   ├── 百家讲坛－二战风云.mobi│   ├── 百家讲坛－动物世界.mobi│   ├── 百家讲坛－大师语录.mobi│   ├── 百家讲坛－明十七帝.mobi│   ├── 百家讲坛－清十二帝.mobi│   ├── 百家讲坛－生活保健.mobi│   ├── 百家讲坛－科技之光.mobi│   ├── 百家讲坛－笑书神侠.mobi│   ├── 百家讲坛－艺术漫谈.mobi│   ├── 百家讲坛－教育与成功.mobi│   ├── 百家讲坛－经济与社会.mobi│   ├── 百家讲坛－道德与法律.mobi│   ├── 社会契约论〔法〕卢梭.txt│   ├── 百家讲坛－刘心武谈红楼.mobi│   ├── 百家讲坛－历史与文化篇.mobi│   ├── 百家讲坛－外国文艺欣赏.mobi│   ├── 百家讲坛－金正昆谈礼仪.mobi│   ├── 易中天：先秦诸子百家争鸣.mobi│   └── 谎言的衰落：王尔德艺术批评文选.萧易译.江苏教育出版社(2004).pdf</code></pre>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交互式提示工程入门</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用chatgpt-4omini做测试 <a href="https://chatgpt.com/">https://chatgpt.com/</a></p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-26 11:07:47 最初来自眼镜交互场景。应邹伟要求，沉淀一波，搞个口语交互场景下的prompt经验分享</p><p>2024-08-26 11:08:28 参考资料</p><ol><li><strong>Anthropic：从入门到精通交互式提示工程教程</strong> <a href="https://github.com/anthropics/prompt-eng-interactive-tutorial">https://github.com/anthropics/prompt-eng-interactive-tutorial</a></li><li>发行说明 <a href="https://docs.anthropic.com/en/release-notes/system-prompts">https://docs.anthropic.com/en/release-notes/system-prompts</a></li><li><strong>the art of asking chatgpt for high-quality answers</strong> <a href="https://book.xindoo.xyz/The%20Art%20of%20Asking%20ChatGPT%20for%20High-Quality%20Answ...%20%28Z-Library%29.pdf">https://book.xindoo.xyz/The%20Art%20of%20Asking%20ChatGPT%20for%20High-Quality%20Answ...%20%28Z-Library%29.pdf</a></li><li><strong>ChatGPT 中文调教指南</strong>。各种场景使用指南。学习怎么让它听你的话。 <a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh">https://github.com/PlexPt/awesome-chatgpt-prompts-zh</a></li><li>吴恩达 x Open AI ChatGPT 提示工程教程 <a href="https://www.bilibili.com/list/15467823?sid=3247315&desc=1&oid=783015669&bvid=BV1s24y1F7eq">https://www.bilibili.com/list/15467823?sid=3247315&amp;desc=1&amp;oid=783015669&amp;bvid=BV1s24y1F7eq</a></li><li>尚尔昕的分享资料 how_to_use_chatgpt.pptx</li><li>其他资料。搜索 Prompt engineering</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习部署入门</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="推理部署综述"><a href="#推理部署综述" class="headerlink" title="推理部署综述"></a>推理部署综述</h1><p>模型部署的步骤：</p><ol><li>训练一个深度学习模型；</li><li>使用不同的推理框架对模型进行推理转换；</li><li>在应用平台运行转换好的模型。</li></ol><p><strong>实际应用场景往往需要模型速度与精度能达到一个较好的平衡。因此这就需要在算法（剪枝，压缩等）与底层（手写加速算作）去优化模型。</strong></p><h1 id="模型格式介绍"><a href="#模型格式介绍" class="headerlink" title="模型格式介绍"></a>模型格式介绍</h1><ol><li>PyTorch (.pth&#x2F;.pt): 这种格式是PyTorch的原生格式，主要用于保存和加载PyTorch模型。</li><li>ONNX (Open Neural Network Exchange): 这是一个开放的模型表示格式，允许在不同的深度学习框架之间交换模型，如PyTorch、TensorFlow、Caffe2等。</li><li>TensorRT (TRT): TensorRT是一个深度学习模型优化器和运行时，主要用于加速模型的推理。TRT格式是为NVIDIA GPU优化的，并且经过了量化、层融合和其他优化。<strong>使用TensorRT优化的模型通常在NVIDIA GPU上有更快的推理速度。这是因为TensorRT会进行很多针对性能的优化。</strong></li></ol><p>通常，你可能首先从PyTorch转换为ONNX，然后从ONNX转换为TensorRT格式，尽管也有直接从PyTorch到TensorRT的工具和方法。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ol><li>PyTorch: 由于它是PyTorch的原生格式，所以它与PyTorch高度兼容。</li><li>ONNX: 设计为跨框架的，但<strong>并不是所有的模型和操作都能轻松地转换为ONNX或从ONNX转换</strong>。</li><li>TensorRT: 主要为NVIDIA GPU优化，对于使用不支持的层或操作的模型，可能需要额外的工作来进行转换。</li></ol><h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><p>开放神经网络交换ONNX（Open Neural Network Exchange）是一套表示深度神经网络模型的开放格式，由微软和Facebook于2017推出，然后迅速得到了各大厂商和框架的支持。通过短短几年的发展，<strong>已经成为表示深度学习模型的实际标准，并且通过ONNX-ML，可以支持传统非神经网络机器学习模型，大有一统整个AI模型交换标准</strong>。ONNX定义了一组与环境和平台无关的标准格式，为AI模型的互操作性提供了基础，使AI模型可以在不同框架和环境下交互使用。硬件和软件厂商可以基于ONNX标准优化模型性能，让所有兼容ONNX标准的框架受益，简单来说，ONNX就是模型转换的中间人。</p><h2 id="TensorRT"><a href="#TensorRT" class="headerlink" title="TensorRT"></a>TensorRT</h2><p>NVIDIA TensorRT™ 是用于高性能深度学习推理的 SDK。此 SDK 包含深度学习推理优化器和运行时环境，可为深度学习推理应用提供低延迟和高吞吐量。</p><p>在推理过程中，<strong>基于 TensorRT 的应用程序的执行速度可比 CPU 平台的速度快 40 倍</strong>。借助 TensorRT，您可以优化在所有主要框架中训练的神经网络模型，精确校正低精度，并最终将模型部署到超大规模数据中心、嵌入式或汽车产品平台中。<br>TensorRT 针对多种深度学习推理应用的生产部署提供 INT8 和 FP16 优化，例如视频流式传输、语音识别、推荐和自然语言处理。推理精度降低后可显著减少应用延迟，这恰巧满足了许多实时服务、自动和嵌入式应用的要求。</p><p><strong>模型可以通过onnx格式转换成TensorRT格式后，使用 NVIDIA Triton 推理服务器完成部署</strong></p><h1 id="TensorRT-LLM"><a href="#TensorRT-LLM" class="headerlink" title="TensorRT-LLM"></a>TensorRT-LLM</h1><p>TensorRT-LLM是NV发布的一个推理引擎。llm被编译成TensorRT后与triton服务器一起部署并支持多GPU-多节点推理和FP8。</p><h1 id="LMDeploy"><a href="#LMDeploy" class="headerlink" title="LMDeploy"></a>LMDeploy</h1><p>(<a href="https://github.com/InternLM/lmdeploy">https://github.com/InternLM/lmdeploy</a>)</p><p>LMDeploy 是一个 Python 库，<strong>用于压缩、部署和服务大型语言模型 （LLM） 和视觉语言模型 （VLM）</strong>。 其核心推理引擎包括 TurboMind Engine 和 PyTorch Engine。前者由 C++ 和 CUDA 开发，力求最终优化推理性能，而后者则纯粹使用 Python 开发，旨在为开发人员减少门槛。</p><p>它支持在 Linux 和 Windows 平台上部署 LLM 和 VLM，最低要求 CUDA 版本 11.3。</p><p>LMDeploy允许压缩、部署和服务llm，同时提供高效的推理(持久批处理、阻塞KV缓存、动态分裂和融合、张量并行、高性能CUDA内核)、有效的量化(4位推理性能比FP16高2.4倍)。跨多台机器和GPU部署多模型服务。此外，它还允许分析令牌延迟和吞吐量、请求吞吐量、API服务器和triton推理服务器性能。</p><p>可以很简单的支持server部署，提供类似openai的接口</p><h1 id="VLLM"><a href="#VLLM" class="headerlink" title="VLLM"></a>VLLM</h1><p>vLLM提供LLM推理和服务，<strong>具有SOTA吞吐量，分页注意力，连续批处理，量化(GPTQ, AWQ, FP8)的支持和优化的CUDA内核</strong>。</p><p>支持各种生成式 Transformer 模型。 <a href="https://docs.vllm.ai/en/stable/models/supported_models.html">https://docs.vllm.ai/en/stable/models/supported_models.html</a><br>另外还支持transformer模型的自我定制。 <a href="https://docs.vllm.ai/en/stable/models/adding_model.html">https://docs.vllm.ai/en/stable/models/adding_model.html</a></p><p><strong>暂不支持whisper</strong></p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>从官方文档上可以看出，支持的事常见的大语言模型和多模态大模型，并不支持传统的Torch模型 <a href="https://lmdeploy.readthedocs.io/en/latest/supported_models/supported_models.html">https://lmdeploy.readthedocs.io/en/latest/supported_models/supported_models.html</a></p><h1 id="Chinese-CLIP"><a href="#Chinese-CLIP" class="headerlink" title="Chinese-CLIP"></a>Chinese-CLIP</h1><p>需求的起源是基于Chinese-CLIP训练的模型。产出是Torch类型的模型，所以最差情况下可以直接Torch.run。同时也<strong>支持将各规模的Pytorch模型，转换为ONNX或TensorRT格式</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/deployment.md">https://github.com/OFA-Sys/Chinese-CLIP/blob/master/deployment.md</a></p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-27 19:39:16 原因是有几个图像模型需要上线。经过调研有三种方式：</p><ol><li>交付冯亮，以离线任务封装。优势是可以尝试利用spark集群的CPU资源，劣势是仅有的GPU来自AIT，不确定归还时间。所以作为长期跑大量数据无固定交付时间的的候选方案</li><li>在方阳aistudio（2.0）平台上自建空间。需要有组内独占的GPU资源，因为xyz的GPU卡都由彭一平管理，所以不可行</li><li>交付一平手动部署，隐藏与aistudio交互的细节。然后自建调度任务</li></ol><p>不管哪种方案，都需要了解模型的推理部署框架，以便与部署层沟通。</p><p>2024-08-27 19:53:09 看起来vllm和lmdeploy都不太支持语音模型和传统的图像模型，比如whisper</p><p>2024-08-27 19:57:06 AI模型部署落地综述（ONNX&#x2F;NCNN&#x2F;TensorRT） <a href="https://www.jianshu.com/p/4e74a7c1a6f1">https://www.jianshu.com/p/4e74a7c1a6f1</a></p><p>2024-08-27 20:18:05 TODO 一篇就够：高性能推理引擎理论与实践 (TensorRT) <a href="https://developer.aliyun.com/article/995926">https://developer.aliyun.com/article/995926</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓开发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="按钮高亮效果研究"><a href="#按钮高亮效果研究" class="headerlink" title="按钮高亮效果研究"></a>按钮高亮效果研究</h1><p>主要需求是在按钮获取焦点时，有一个高亮效果，当然动画效果更好 可能有如下几个方案</p><ol><li>使用简单动画<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">alphaAnimation</span> <span class="operator">=</span> AnimationUtils.loadAnimation(<span class="built_in">this</span>, R.anim.btn_alpha_effect);</span><br></pre></td></tr></table></figure>优势是可以不用setBackground，因为有个按钮有三种状态，所以使用setBackground需要进行复杂的状态控制；可以随时绑定和取消；劣势是只能使用简单动画，比如呼吸灯效果，缩放效果</li></ol><h1 id="使用火山引擎的识别和合成能力"><a href="#使用火山引擎的识别和合成能力" class="headerlink" title="使用火山引擎的识别和合成能力"></a>使用火山引擎的识别和合成能力</h1><p>提供了SDK。<br>ASR <a href="https://www.volcengine.com/docs/6561/113642">https://www.volcengine.com/docs/6561/113642</a><br>TTS <a href="https://www.volcengine.com/docs/6561/79834">https://www.volcengine.com/docs/6561/79834</a></p><p>需要注意的是，ASR时如果选择 <code>RECORDER_TYPE_RECORDER</code>(内置录音机)，就不要再用demo里的SpeechStreamRecorder再自行录音并调用Engine.feedAudio，后者对应于 <code>RECORDER_TYPE_STREAM</code> (外部PCM音频流)。也就是说识别的SDK中，硬件和交互本身就是解耦的</p><p>同样，TTS也可以禁止SDK直接使用系统播放器 <code>PARAMS_KEY_TTS_ENABLE_PLAYER_BOOL</code> ，而是获取到录音数据后自行使用播放器播放</p>]]></content>
      
      
      <categories>
          
          <category> 前端与小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macbook电脑配置</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/macbook%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/macbook%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Macbook-iOS"><a href="#Macbook-iOS" class="headerlink" title="Macbook(iOS)"></a>Macbook(iOS)</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>2024年06月30日13:42:52 不要企图使用u盘把mac电脑的资料导出。经常会出现错误弹出，导致u盘损坏。更多的通过网络的方式，比如笔记、onedrive、网盘，兜底的情况下使用smb与Windows连接互传，之后再使用u盘</p><h2 id="软件列表备份"><a href="#软件列表备份" class="headerlink" title="软件列表备份"></a>软件列表备份</h2><p>2024年06月06日11:59:34<br>$ ls -hal &#x2F;Applications&#x2F;</p><pre><code>Another Redis Desktop Manager.appAudacity.appBaiduNetdisk.appClashX.appDocker.appDoubao.appEasyConnect.appGoogle Chrome.appHBuilderX.appIntelliJ IDEA CE.appKeePassium.appLark.appMicrosoft Edge.appMySQLWorkbench.appOneDrive.appPhotoScapeX.appPostman.appPyCharm CE.appQQ.appQQMusic.appSafari.appSmart Countdown Timer.appSourcetree.appTencent Lemon Lite.appTencentMeeting.appThunder.appUtilitiesVisual Studio Code - Insiders.appVisual Studio Code.appWeChat.appWireshark.appdraw.io.appiShot.appiTerm.appsogou_mac_615a.appwechatwebdevtools.appwpsoffice.app抖音.app万年历.app企业微信.app有道云笔记.app网易有道翻译.app</code></pre><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><p>2024年06月27日08:59:13 首先尽量不要使用homebrew，这是一个第三方的包管理工具，可能随着系统升级遇到奇奇怪怪的问题</p><p>2021年04月05日11:58:28 安装homebrew<br><a href="https://github.com/cunkai/HomebrewCN">https://github.com/cunkai/HomebrewCN</a><br>&#x2F;bin&#x2F;zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh</a>)”</p><p>(Mac下Homebrew更新国内源brew update卡死)[<a href="https://cloud.tencent.com/developer/article/1817647]">https://cloud.tencent.com/developer/article/1817647]</a><br>export HOMEBREW_NO_INSTALL_FROM_API&#x3D;1</p><p>2024年06月27日09:12:48 如果 Homebrew 遇到问题，可以先尝试执行以下步骤：</p><ol><li>首先，运行 brew doctor 命令查看问题并按照指示进行修复。</li><li>然后，执行 brew update-reset 将 Homebrew 还原到稳定版本。</li><li>最后，运行 brew update 命令来更新软件包。</li></ol><p>2024年06月28日17:10:01 使用brew安装的软件包：brew install ctags tree wget rename ffmpeg graphviz python3 java cmake vim kcat</p><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><p>2024年06月27日09:15:51 卸载旧node环境</p><ol><li><p>brew uninstall node</p></li><li><p>npm uninstall npm -g</p></li><li><p>强制删除残留</p><pre><code> sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*  sudo rm -rf /usr/local/include/node /Users/$USER/.npm  sudo rm /usr/local/bin/node  sudo rm /usr/local/share/man/man1/node.1  sudo rm /usr/local/lib/dtrace/node.d</code></pre></li></ol><p>2024年06月27日09:14:20 使用nvm工具管理node。</p><ol><li>一行命令即可安装node和npm：curl -o- <a href="https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh">https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh</a> | bash</li><li>nvm install node</li></ol><p>2024-07-03 14:51:40 解决国内npm速度慢的问题</p><ol><li>npm config set registry <a href="https://mirrors.cloud.tencent.com/npm">https://mirrors.cloud.tencent.com/npm</a> 切换腾讯云</li><li>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org</a> 源站备份</li><li>npm config get registry 验证</li></ol><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><strong>mac系统自带vim不支持粘贴板</strong>，可以用vim –version 查看到-clipboard。这个时候使用brew install vim –with-lua –with-override-system-vi –with-python3安装第二个vim，不要动受系统监管的vim。然后使用alias将vim设置别名</p><blockquote><p>2024年07月03日14:05:00 mac自带的vim已支持剪切板</p></blockquote><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>2024-07-04 11:56:14 sh -c “$(curl -fsSL <a href="https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh">https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</a>)”</p><p>2024-07-04 11:57:29 git clone –depth 1 <a href="https://github.com/junegunn/fzf.git">https://github.com/junegunn/fzf.git</a> ~&#x2F;.fzf<br>~&#x2F;.fzf&#x2F;install<br>2. </p><h2 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h2><p>2024-07-03 14:05:38 设置时间格式。偏好设置&gt;高级&gt;输入扩展&gt; 自定义短语设置</p><blockquote><p>#$year-$month_mm-$day_dd $fullhour:$minute:$second<br>移动端好像做不到</p></blockquote><h2 id="密码本app"><a href="#密码本app" class="headerlink" title="密码本app"></a>密码本app</h2><p>2024年07月01日11:17:34 keepassium。使用onedrive中的文件达成多端自动同步</p><ol><li>应用解锁密码 1****6</li><li>文件锁密码 1****6</li></ol><h2 id="倒计时APP"><a href="#倒计时APP" class="headerlink" title="倒计时APP"></a>倒计时APP</h2><p>2024年06月06日10:32:33 我的需求是可以在状态栏显示剩余时间，并且直接操作启停，到时间有弱提醒</p><ol><li>Onigiri。App Store下载，能很好满足需求，但是过一段时间之后就强制购买</li><li><a href="https://github.com/ivoronin/TomatoBar">https://github.com/ivoronin/TomatoBar</a> 不能随意修改倒计时时间，而只能管理工作时间和间隔</li><li>focus work and study timer。只能使用25分钟的计时器，修改间隔另外收费</li><li>tomito。没有任务栏倒计时。</li><li>Timer Rh。没有任务栏倒计时</li><li>Horo。App Store下载，能很好满足需求，稍微美中不足的是很容易同时开启多个</li><li><strong>Smart CountDown Timer</strong>。App Store下载，能很好满足需求，图标比Horo好看，并且很容易复用同一个时钟</li></ol><h2 id="浏览器选择"><a href="#浏览器选择" class="headerlink" title="浏览器选择"></a>浏览器选择</h2><p>2021年11月22日12:23:25 </p><ol><li>【edge】。<strong>工作使用。标签分组，不活动网页省电，多端同步，极速打开</strong></li><li>【safari】，不跨平台；没有太大毛病，但是标签缩略图不如edge的标题好用；苹果系列的默认浏览器，<strong>手机上的标签可以左右滑动是个亮点</strong>，所以生活中临时使用；</li><li>【360chrome】。not bad。serve me well。360可能存在证书欺诈。没有linux版本。mac比较好用的国产浏览器，跟PC端基本一致，但是grafana已经不支持了。<strong>唯一还支持视频独立窗口播放的浏览器</strong></li><li>firefox。有linux版本，可以轻松同步。缺点：简陋，启动慢，页面渲染bug太多了。没有用武之地了</li><li>chrome：浏览器的代表。但是因为不能登录谷歌所以不能同步书签。只能调试用</li><li>世界之窗：速度超快，超简洁。已经许久不更新，不支持插件，内核版本已逐渐不被支持。360的儿子，不支持固定九宫格。简化版的360，不如说是360极速的前身</li></ol><p>2021年11月11日12:03:55 <strong>浏览器统一使用edge</strong>，分组功能非常好用。不能使用360极速了，已经不支持grafana了</p><p>2024年06月19日11:57:02 EDGE插件：</p><ol><li>smartUp手势</li><li>Web Highlights - PDF &amp; Web Highlighter</li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol><li>vs开发Python不要尝试了，不能自动补全、反应速度超慢、intellisense感知不全经常失误，没有pep8</li><li>eclipse + pydev连提示都没有</li><li><strong>IntelliJ Pycharm Community</strong>。最终选用pycharm 社区版，跨平台，可以商用。天下无双。不用再试其他的了</li><li>在官网下载安装到系统 <a href="https://www.python.org/downloads/macos/">https://www.python.org/downloads/macos/</a></li></ol><p>使用Anaconda管理python版本</p><h2 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul><li>visual studio 宇宙最强IDE，Windows下首选。结合远程调试，可以给Linux C++ 提供一种解决方案。</li><li>Visual C++ for Linux 有一个致命问题：项目管理经常崩溃，导致编译时总是找不到文件</li><li>codeblocks在windows下表现与visual C++ 不同，即使调用msvc，也会某些情况下出现编译失败，而且老出前期百怪的问题。。智能提示还好，感知基本没有，语法错误统统不检查；codeblocks只能使用cbp项目文件，不能使用autoconf、make或者cmake的项目文件，而且也没法转换</li><li><strong>现阶段使用vscode+插件可以很好的满足本地和远程开发的情况</strong></li><li>或者eclipse for C++。只能使用gcc编译。而且不是自带gdb。也是一种好的解决方案，但是问题繁多，曲线陡峭<br>CDT的智能感知太弱了，基本不可用的地步</li><li>Clion只支持mingw和cygwin. 只能使用cmake。而且收费</li><li>qt，跨平台C++ IDE。但是对一般性Cpp项目不太友善。qmake毕竟没有cbp通用好懂。没有自带编译环境，需要转接层</li><li>NetBeans和eclipse是基于虚拟机的</li></ul><h3 id="关于vscode"><a href="#关于vscode" class="headerlink" title="关于vscode"></a>关于vscode</h3><p>2018年11月22日09:42:41 配置vscode C++开发环境<br>遇到问题1：只能使用lldb不能使用gdb：<br>问题2：lldb调试不触发断点直接运行结束，可能与这个有关<br>error: No selected frame to use to find the default file.<br>error: No file supplied and no default file available.<br>问题2是因为没有设置编译选项-g</p><h3 id="vscode配置"><a href="#vscode配置" class="headerlink" title="vscode配置"></a>vscode配置</h3><p>2021年10月18日11:08:18 vscode myblog插件配置<br>milkdown<br>Markdown PDF<br>Snazzy Light<br>$ ll &#x2F;Users&#x2F;niuqiang&#x2F;.vscode&#x2F;extensions<br>total 0<br>gera2ld.markmap-vscode-0.0.10<br>loilo.snazzy-light-1.3.0<br>mirone.milkdown-0.0.12<br>yzhang.markdown-all-in-one-3.4.0</p><p>2021年10月18日11:38:11 vscode-insider 插件配置<br>$ ll &#x2F;Users&#x2F;niuqiang&#x2F;.vscode-insiders&#x2F;extensions<br>total 0<br>aaron-bond.better-comments-2.1.0<br>adamhartford.vscode-base64-0.1.0<br>alefragnani.bookmarks-13.2.2<br>alefragnani.project-manager-12.4.0<br>bbenoist.doxygen-1.0.0<br>coenraads.bracket-pair-colorizer-1.0.62<br>cschlosser.doxdocgen-1.3.2<br>eamodio.gitlens-11.7.0<br>foxundermoon.shell-format-7.2.2<br>github.vscode-pull-request-github-0.34.3<br>golang.go-0.30.0<br>golang.go-0.31.0<br>grapecity.gc-excelviewer-4.1.52<br>jeff-hykin.better-cpp-syntax-1.15.10<br>jeff-hykin.better-cpp-syntax-1.15.11<br>mohsen1.prettify-json-0.0.3<br>ms-vscode-remote.remote-containers-0.215.0<br>ms-vscode-remote.remote-containers-0.216.0<br>ms-vscode-remote.remote-ssh-0.70.0<br>ms-vscode-remote.remote-ssh-edit-0.70.0<br>ms-vscode-remote.remote-wsl-0.64.2<br>ms-vscode.cmake-tools-1.9.2<br>ms-vscode.cpptools-1.8.0<br>ms-vscode.cpptools-1.8.3<br>ms-vscode.cpptools-extension-pack-1.1.0<br>ms-vscode.cpptools-themes-1.0.0<br>ms-vsliveshare.vsliveshare-1.0.5273<br>ms-vsliveshare.vsliveshare-1.0.5330<br>ms-vsliveshare.vsliveshare-audio-0.1.91<br>msyrus.go-doc-1.0.1<br>teabyii.ayu-1.0.5<br>twxs.cmake-0.0.17<br>xaver.clang-format-1.9.0</p><h3 id="关于-xcode"><a href="#关于-xcode" class="headerlink" title="关于 xcode"></a>关于 xcode</h3><p>2018年11月25日15:08:27<br>xcode一样需要有专门的工程文件xcodeproject。使用Makefile的原理同vscode，也是调用外部构建工具。但是xcode自身不带有命令行工具<br>clion和pycharm都太占内存CPU了，如非必要尽量不用jetbrains<br>codeblocks可以认为没有mac版本</p><p>2018年12月05日21:57:13  尝试使用xcode管理makefile组织的代码</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>类似nvm之于nodejs，java同样有版本工具<a href="https://sdkman.io/">sdkman</a></p><blockquote><p>SDKMAN是一个用于管理软件开发工具的工具。它允许用户在他们的计算机上安装、管理和切换不同的软件开发工具，如Java、Gradle、Maven、Scala等。SDKMAN提供了一个简单易用的命令行界面，用户可以使用命令来安装、卸载、切换和更新不同的工具版本。SDKMAN还提供了一个广泛的软件工具列表，用户可以从中选择并安装他们所需的工具。<br>简单来说，如果你使用过python的anaconda，那么你可以将这玩意理解成一个java版本的anaconda，可以很方便的管理多个java版本。</p></blockquote><ol><li>所以没有必要再手动下载安装任何java（除了brew可能依赖的版本）</li><li>所以也不必再使用IDEA内置的SDK下载器了</li></ol><p>2024-08-21 10:20:21 截止目前IDE还是使用IntelliJ IDEA最全面靠谱。<a href="../resources/jetbrains_idea.zip">配置文件</a></p><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><ul><li>IntelliJ gogland。但是收费</li><li>现阶段先使用vscode，因为现在写Golang也不多。配置还是略显麻烦了</li><li>现阶段可以先使用fleet，限免期间基本上可以当做Goland用</li></ul><p>版本管理工具gvm<br>它允许您在同一台机器上轻松切换不同版本的 Go</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过curl安装GVM</span></span><br><span class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br></pre></td></tr></table></figure><ol><li>gvm listall</li><li>gvm install go1.16.5</li><li>gvm use go1.16.5 –default</li><li>gvm use go1.16.5</li><li>gvm uninstall go1.16.5</li></ol><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>首先要区分编辑器与IDE</p><ul><li><strong>visualstudiocode</strong>漂亮、启动速度慢。既是编辑器又是IDE。转码最强。不对C&#x2F;C++做语法分析</li><li>jetbrains fleet。对标visualstudiocode的插件式ide，同样有jb家软件高内存的毛病，而且对调试测试的支持还不完善。2024年05月11日</li><li>Atom：启动超级慢，不会自动转码。放弃。超级傻逼的编辑器</li><li>notepad++启动超级快，会自动转码，丑。插件辣鸡。不能跨平台</li><li>Sublime 命令插件自有体系，需要学习成本。跨平台，会自动转码。会对C&#x2F;C++做语法分析，能跳转</li><li>lighttable既不是编辑器又不是IDE的辣鸡。<blockquote><p>编辑器全面转向VSCode，自带功能加插件完爆sublime，而且最漂亮。其他更不在话下。但是真的是太慢了，而且对后端语言的支持比sublime差远了</p></blockquote></li><li>vim不值得深入学习，彻底完全放弃，不要有一丝疑虑。只需要尽量使用spf-13m插件或者simple.vimrc</li></ul><p>现在编辑器的唯一和最终解决方案已经锁死vscode了</p><h3 id="关于sublime"><a href="#关于sublime" class="headerlink" title="关于sublime"></a>关于sublime</h3><p>丰富的插件、漂亮、专业、快捷、高度定制、编辑器的最后解决方案 首先通过注册表把它加到右键菜单 [HKEY_CLASSES_ROOT*\shell\SublimeText3] @&#x3D;”用 SublimeText3 打开” “Icon”&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe,0”<br>[HKEY_CLASSES_ROOT*\shell\SublimeText3\command]<br>@&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe %1”</p><p>[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3]<br>@&#x3D;”用 SublimeText3 打开”<br>“Icon”&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe,0”</p><p>[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command]<br>@&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe %1”</p><p>sublime插件与设置：<br>2018年1月18日11:03:38 prettyjson<br>converttoutf8<br>log highlight</p><p>2018年11月22日11:27:01 sublime要去中文官网下载，外文官网翻墙都打不开</p><h2 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h2><p>2019年10月28日14:16:54 导出spacevim配置</p><pre><code>原位置：~/.SpaceVim.d/init.toml文件名：spacevim.init.toml使用方式：内容复制，保存即可2023年04月16日10:21:41 仅复制vimrc即可，spacevim安装耗时，也没有太大必要</code></pre><p>2019年10月28日14:37:28 导出iterm2配置</p><pre><code>原位置：iTerm2 -&gt; Preferences -&gt; General -&gt; Settings -&gt; Export All Settings and Data文件名：iTerm2Settings.itermexport使用方式：iTerm2 -&gt; Preferences -&gt; General -&gt; Settings -&gt; Import All Settings and Data</code></pre><p>bash</p><pre><code>工作机：develop.zshrc跳板机：jump.bashrc编译测试机：compile.bashrciTerm2配置：iTerm2_Profiles.json</code></pre><p>vscode</p><pre><code>快捷键：vscodekeybindings.json  笔记设置：vscodesettings.json代码设置：vscodesettings2.jsonC++新文件模版配置：vscodetmpl.json  通过preference-&gt; Configure User Sniffets生效</code></pre><p>IDE</p><pre><code>Clion: clion-light.zipGoland: goland-light.zipPycharm: pycharm-light.zip</code></pre><h2 id="其他适配"><a href="#其他适配" class="headerlink" title="其他适配"></a>其他适配</h2><p>2021年03月03日23:09:39 解决macos更新big sur之后，vscode + source code pro显示全黑色的问题</p><ol><li>rm -rf &#x2F;Users&#x2F;didi&#x2F;Library&#x2F;Application\ Support&#x2F;Code\ -\ Insiders</li><li>移除source code pro字体，移除vscode</li><li>安装vscode，安装字体。配置字体</li></ol><p>2020年11月03日10:44:58 安全性与隐私-&gt;启用<strong>文件保险箱</strong><br>C3CO-OT24-OHVJ-TZMX-7P9J-OJGL</p><p>2020年09月16日18:03:11 <strong>ocenaudio</strong>有问题，偶尔会持续失真，表现类似打开错误的采样率，但是实际没错</p><p>2019年08月22日17:38:04 mac中按住control + 方向键上打开任务视图</p><p>2021年04月06日20:11:58 <strong>iterm2无法缩放</strong>，无法拖动<br>Preferences-&gt;Appearance-&gt;Tabs-&gt;勾选 show tab bar even when there is only one tab<br>终端使用iTerm2，选择主题为zenburn，spf13-vim同样。原来vim展示什么样不止取决于主题，也取决于终端主题</p><p>2021年04月12日20:23:23 配置rzsz传递文件<br><a href="https://www.cnblogs.com/limingluzhu/p/4818197.html">https://www.cnblogs.com/limingluzhu/p/4818197.html</a></p><p>2024年05月06日19:33:39 <strong>SourceTree</strong> macbook上 git可视化首选</p><ol><li>GitHubDesktop辣鸡。反应慢，功能少</li></ol><p>2023年04月17日11:29:44 <strong>配置休眠时关闭蓝牙和wifi</strong><br><a href="https://juejin.cn/post/7057723273827581959">https://juejin.cn/post/7057723273827581959</a><br><a href="https://github.com/Mintimate/SleepAndAutoBluetoothAndWifi">https://github.com/Mintimate/SleepAndAutoBluetoothAndWifi</a></p><p>2021年04月07日10:22:08 <strong>cherry mx 1.0 键盘 &amp; thinkplus M80 鼠标</strong></p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>2024-07-19 15:18:19 合盖休眠时自动关闭蓝牙，避免耳机自动连接合盖的电脑<br><a href="https://github.com/odlp/bluesnooze">https://github.com/odlp/bluesnooze</a></p><h1 id="Linux-Ubuntu-CentOS"><a href="#Linux-Ubuntu-CentOS" class="headerlink" title="Linux(Ubuntu&#x2F;CentOS)"></a>Linux(Ubuntu&#x2F;CentOS)</h1><p>ubuntu是最适合作为桌面操作系统的linux，但是服务端常用的是centos<br>Ubuntu和centos以及其他Linux发行版，他们的唯一区别在于包管理方式不同，使用的内核都是linus工作组在维护的内核，区别在于通常Ubuntu的内核版本比较高，而centos的内核版本比较低。Ubuntu 16.04&#x3D;3.8.0，centos7（1611build）&#x3D;3.1.0</p><p>ubuntu:<br>好吧，第一次更新系统后提示出现错误只能重启，重启后无限卡在登录页面也桌面环境之间。遂放弃</p><p>最终选用CentOS 7 Everything，其他版本不再考虑</p><pre><code>安装时选择安装设备，具体请搜索选择everything镜像，直接用UltraISO制作(不要用ultraiso preuim)，不要用UUI会有格式转换。选择安装develop station安装。此时请使用模拟声卡的声音接口内置了中文输入法、播放器等尽量尝试使用应用商店。应用商店其实就是yum源的可视化方式使用pkgs.org提供的rpm安装chrome，此后可以在网页使用云端工具了配置yum源，最少要有epel、rpmforgeyum upgrade ，升级系统</code></pre><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="自动关机"><a href="#自动关机" class="headerlink" title="自动关机"></a>自动关机</h2><p>@echo off<br>sc config Schedule start&#x3D;AUTO&gt;nul 2&gt;nul<br>net start Schedule<br>at 21:00 &#x2F;every:M,T,W,Th,F,S,Su cmd &#x2F;c Start %systemroot%\system32\shutdown.exe &#x2F;s &#x2F;f<br>at 22:00 &#x2F;every:M,T,W,Th,F,S,Su cmd &#x2F;c Start %systemroot%\system32\shutdown.exe &#x2F;s &#x2F;f<br>at 23:00 &#x2F;every:M,T,W,Th,F,S,Su cmd &#x2F;c Start %systemroot%\system32\shutdown.exe &#x2F;s &#x2F;f<br>windows 添加自动关机任务，最终的唯一的方式</p><h2 id="VMWare"><a href="#VMWare" class="headerlink" title="VMWare"></a>VMWare</h2><p>需求：模拟服务的发布，达到可以在不同主机的情况下访问。 解决方案：1.把服务用Windows系统发布 2.在虚拟机中同时运行多个虚拟主机，并组成不同网络 考虑到以后可能需要把Kubernetes等分布式应用工具先部署到测试环境，所以这里采用了2。 虚拟机三种组网方式 注意到：桥接方式可以认为虚拟出一台物理机在子网上，所以不能用于MAC绑定的子网（公司就是mac绑定的）；NAT方式可以实现主机虚拟机双向通信，但是虚拟机之间不能通信。那就只能用主机发布，相当于方案1.所以只能使用主机模式。 主机模式主机也有一块虚拟网卡，和虚拟机的网卡一起连接在虚拟交换机上组成子网。但是这个子网是绝缘的，只能与主机上的其他虚拟子网相连。<br>在VMware workstation Pro 12上，以下步骤应该能解决问题。如果不能，请直接移步VMware文档中心不用百度了<br>步骤：<br>1.右键需要组网的虚拟机，在配置》网络适配器中选择主机模式。然后在主机中使用配置有线网也好、命令行也好，保证ip变到主机模式的网段！！！（三种模式的网段在 编辑》虚拟网络编辑器 里可以看到）<br>2.在主机上控制面板里，配置VMnet1可共享，并且共享给VMnet8（为什么是这个虚拟网卡我也不知道，当时瞎选的）<br>3.这个时候如果虚拟机里的ipv4是DHCP自动，应该就可以了。反正最终效果是主机、虚拟机*n在同一子网中！<br>4.这时应该是能相互ping通了。在某个虚拟机中把服务发布，然后在其他机器访问试试？是不是会出现no route to host ？ 这是因为作为服务器的虚拟机的防火墙拒绝访问。centos7的防火墙服务是firewalld.service。<br>5.如果服务写的对，而且发布没有问题的话，这个时候就能正常访问了。<br>6.需要的时候逆向以上1、2，不然虚拟机不能上网。</p><h2 id="windows其他适配"><a href="#windows其他适配" class="headerlink" title="windows其他适配"></a>windows其他适配</h2><p>2018年1月16日09:53:52 如果安装了Visual Studio，务必修改注册表，在右键菜单里删除打开方式</p><p>2018年1月16日09:53:54 Win7版本，安装MacType，并且选用LCD。pycharm对于LCD和non-LCD屏的支持不同，如果不支持LCD，那么就会出现显示字符被截断的问题</p><p>2018年1月16日09:53:57 安装vsix.双击打开。卸载呢？在visualstudio里 工具》扩展与更新》已安装》选择该项》卸载</p><p>2018年1月16日09:54:33 添加任务计划。开始》程序》附件》系统工具》任务计划<br>2018年1月16日09:55:04 输出目录下所有文件目录树。tree loveit &#x2F;f &gt;&gt; output.txt</p><p>2018年1月16日09:55:17 Windows 查看命令手册。help 命令</p><p>2018年1月16日09:55:28 启动MySQL。作为系统服务需要在计算机》管理》服务和应用程序》服务 中开启，其他系统服务也是</p><p>2018年1月16日09:55:53 在浏览器中禁用stackoverflow的js可以明显加快速度</p><p>2018年1月16日09:55:56 禁用百度知道的js就可以避免日报的侵扰</p><p>2018年1月16日09:55:58 PowerShell中获取本机已安装软件列表 Get-WmiObject -Class Win32_Product</p><p>2018年1月16日09:56:03 添加和删除右键菜单<br>控制文件右键菜单的注册表项在HKEY_CLASSES_ROOT*\shell\ 。 注意添加command文件夹<br>控制文件夹右键菜单的注册表项在HKEY_CLASSES_ROOT\Directory\shell\ 。 注意添加command文件夹</p><p>2018年1月11日15:45:25 废止使用Visual Studio 2017作为Linux C++开发工具，目前尚不稳定</p><p>2018年1月16日10:05:27 <install> PicPick</p><p>2018年1月16日14:13:25 <install> [depracated]搜狗鼠标手势</p><p>2018年1月16日10:07:39 linux虚拟机跟windows主机之间拷贝东西就可能引起文件数据异常，典型的如压缩文件损坏，更好的方式是使用xshell的rz与sz命令</p><p>2018年1月18日15:25:48 安装tortoiseSVN和tortoiseGit时务必勾选命令行</p><p>2024年05月06日19:34:09 TortoiseGitgit可视化首选</p><p>reStructText富文本标记语言<br>使用终极编辑器Visualstudio。其他编辑器都不能完美展示reStructText<br>Markdown 过于简单了<br>ESET<br>JJmatch公司自带的杀毒软件。默认在用户登录时进行全盘扫描，极占CPU，甚至导致开机卡机。需要在ESET面板&gt;工具&gt;计划任务修改该项<br>Navicat 确实没有mysqlworkbench好使</p><p>远程调试通常是通过ftp或samba或git把源码同步到目标机，然后借助gdb远程调试技术，使用gdbserver调试，支持的ide有clion、vs、eclipse。但是这条路没有必要深入，只需要走通即可。可以在虚拟机中开发，然后在目标机上测试运行。如果需要，使用上述方式调试。所有对远程开发并调试的尝试就此打住。<br>绝不尝试vim开发+gdb原生调试<br>Foxmail 不能导出，所有东西都不能导出。不能同步<br>Dreammail 非常强大。可以备份<br>网易邮箱大师 功能太弱了。可以同步</p><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><p>2018年4月19日11:00:42</p><p>打开cmd命令行或PowerShell</p><p>查看端口占用情况</p><p>netstat -aon|findstr port</p><p>最后一列是pid</p><p>查看pid对应的进程详细情况</p><p>tasklist|findstr pid</p><p>同时得到进程映像名</p><p>根据pid或进程影响名杀死进程</p><p>taskkill &#x2F;f &#x2F;t &#x2F;im pid或程序名</p><p>&#x2F;im选项可能要改为&#x2F;pid选项</p><h2 id="软件及配置"><a href="#软件及配置" class="headerlink" title="软件及配置"></a>软件及配置</h2><p>2018年3月16日14:06:30 PDF桌面阅读使用福昕阅读器。注意首先在设置中将广告推送取消，然后在视图-页面设置中选择&lt;连续&gt;</p><p>2018年3月30日09:56:27 调整visual studio 配置以配色</p><blockquote><p>不再使用visual assist X</p></blockquote><p>2018年4月3日11:16:27 实现Windows CMD复制粘贴功能：</p><blockquote><p>Windows 命令行默认是不能选定的</p><ul><li>首先在窗口右键，选择编辑-&gt;标记</li><li>标记完成后回车确认</li><li>此时内容已在剪贴板。右键窗口选择粘贴</li></ul><p>在任何情况下都不能实现直接通过ctrl+cv复制粘贴</p></blockquote><p>2018年4月18日17:24:50 勾选cmd命令行的快速编辑模式和插入模式，可以实现选择之后右键快速复制，再右键快速粘贴</p><p>2018年4月3日17:39:21 使用clion三部曲：</p><blockquote><ul><li>配置toolchains。在settings&gt;Build,Execution,Deployment中配置Toolchains。注意如果是拷贝的配置，配置export时将toolchains清空，否则会导致导入时不能更改</li><li>配置Cmake。在settings&gt;Build,Execution,Deployment中配置cmake profiles</li><li>配置run configuration。如果前两部能正常完成，在打开了工程的情况下，第三步可自动完成。</li></ul></blockquote><p>2018年5月30日16:23:58 发现Clion的编译提示和变量类型、值提示没有VS完整</p><p>2018年8月3日15:34:54 windows上的mysql无法区分大小写！尽可能直接使用linux mysql</p><p>2019年12月23日19:06:00 按住option键，然后从窗口的下边缘开始缩放，这样上边缘也会同步缩放，以解决filezilla初始化窗口无法显示的问题</p><p>2020年02月24日10:11:41 破解beyondcompare作为文本对比工具</p><h1 id="跳板机"><a href="#跳板机" class="headerlink" title="跳板机"></a>跳板机</h1><p>2019年04月15日18:31:00 跳板机上的脚本都是sh脚本，使用个人登录凭证逐个登录到各机器<br>~&#x2F;lighttpdfinder 找到哪个集群的lighttpd在为某个端口转发<br>~&#x2F;logfilter 日志过滤器</p><p>2019年05月14日14:20:47 .bashrc<br>快速进入测试机</p><hr><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-22 11:02:49 很久以前还考虑过如何用Windows主机做开发机，选用什么系统，配置什么环境，现在基本上 macbook + docker + （vscode）统一天下了</p><h2 id="开发机"><a href="#开发机" class="headerlink" title="开发机"></a>开发机</h2><ul><li>Windows所见即所得确实厉害，软件丰富，优化不错，但是只能远程测试C++</li><li>Linux常作为服务端系统。但是不太友好<br>  因此除C++外其余在Windows。仅保留LInux Ultimate虚拟机和实验性真机<blockquote><p>最终选用 centos7 workstation版本，可定制化程度高，界面支持好，管理方便，大部分软件包都默认安装。Ubuntu根本不堪一击<br>2018年11月11日15:31:44 Ubuntu on Windows目前还漏洞百出，安装c++工具链遇到各种奇怪的问题无法解决</p></blockquote></li></ul><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><p>2020年12月09日14:14:16 源码安装</p><ol><li><p>vim8.1:</p><p>  .&#x2F;configure –with-features&#x3D;huge –enable-multibyte –enable-rubyinterp –enable-pythoninterp –with-python-config-dir&#x3D;&#x2F;usr&#x2F;lib64&#x2F;python3.4&#x2F;config –enable-luainterp –with-lua-prefix&#x3D;&#x2F;usr&#x2F;bin –enable-perlinterp –enable-gui&#x3D;gtk2 –enable-cscope –prefix&#x3D;&#x2F;home&#x2F;niuqiang&#x2F;vim81</p></li><li><p>cgdb</p></li><li><p>cmake</p></li><li><p>ffmpeg-static</p></li></ol><p>2020年12月10日11:15:20 源码安装python、golang<br>2020年01月06日23:24:36 源码安装python无法安装依赖的问题however the ssl module in Python is not available.</p><pre><code>    yum install openssl-devel    cd Python-3.6.2    ./configure    make altinstall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> macbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo快速入门</title>
      <link href="/hexo_quick_start/"/>
      <url>/hexo_quick_start/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>首先自行安装nvm、node.js、npm工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v  </span><br></pre></td></tr></table></figure><h3 id="Initialize-Book"><a href="#Initialize-Book" class="headerlink" title="Initialize Book"></a>Initialize Book</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p iBook &amp;&amp; <span class="built_in">cd</span> iBook</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo server -o</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Initialize-Github-Pages"><a href="#Initialize-Github-Pages" class="headerlink" title="Initialize Github Pages"></a>Initialize Github Pages</h3><p>创建一个名为{用户名}.github.io的仓库</p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>首先把通过git工具把生成的静态页面推送到github的流程，配置到站点配置文件；安装deployer</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题快速入门</title>
      <link href="/butterfly_quick_start/"/>
      <url>/butterfly_quick_start/</url>
      
        <content type="html"><![CDATA[<h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h1 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h1><p>修改主站配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>拷贝主题配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r themes/butterfly/_config.yml ./_config.butterfly.yml</span><br></pre></td></tr></table></figure><p>Hexo会自动合并主题中的_config.yml和 _config.butterfly.yml ，如果存在同名配置，会优先使用_config.butterfly.yml的配置</p><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><p>2024-08-15 11:28:12 butterfly主题设置参考：<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">https://blog.csdn.net/mjh1667002013/article/details/129290903</a></p><blockquote><p>主要是修改主题配置，需要配合安装npm包</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-lazyload-image --save</span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h1 id="下一步工作"><a href="#下一步工作" class="headerlink" title="下一步工作"></a>下一步工作</h1><p>2024-08-15 11:28:22 魔改与美化未配置</p>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp开发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408uniapp%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408uniapp%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>需求里至少三大模块：录音、webrtc传入传出音频、播放音频。其他的都是展示模块，没有技术难点</p><h1 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h1><h1 id="webrtc"><a href="#webrtc" class="headerlink" title="webrtc"></a>webrtc</h1><h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p>可以参考github搜索 vue+chat，实现相对复杂的功能</p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-28 10:31:24 TODO uni-app实现录音及播放功能 <a href="https://blog.csdn.net/a18792627168/article/details/109853394">https://blog.csdn.net/a18792627168/article/details/109853394</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端与小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用环境管理工具</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>Anaconda是一个用于科学计算的Python发行版，Anaconda支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。</p><p>Anaconda利用工具&#x2F;命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。在这里解释下conda、anaconda这些概念的差别：Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。</p><p>conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。</p><p>其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。Anaconda和Python的区别是：<br>1、安装包大小不同python自身缺少numpy、matplotlib、scipy、scikit-learn等一系列包，需要安装pip来导入这些包才能进行相应运算。Anaconda(开源的Python包管理器)是一个python发行版，包含了conda、Python等180多个科学包及其依赖项。包含了大量的包，使用anaconda无需再去额外安装所需包。<br>2、内置不同IPython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。而Anaconda Prompt 是一个Anaconda的终端，可以便捷的操作conda环境。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>macbook使用安装器安装 <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/macos.html">https://docs.conda.io/projects/conda/en/latest/user-guide/install/macos.html</a></p><p>安装后首先更新国内源，解决所有命令太慢的问题。编辑~&#x2F;.condarc为以下内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show_channel_urls: true</span><br><span class="line">remote_connect_timeout_secs: 30.0</span><br><span class="line">remote_read_timeout_secs: 60.0</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><p>安装后，首先更新工具自身，避免各种奇奇怪怪的问题</p><ol><li>conda update conda</li><li>conda update anaconda</li><li>pip install –upgrade pip</li></ol><h2 id="命令实操"><a href="#命令实操" class="headerlink" title="命令实操"></a>命令实操</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. conda init</span><br><span class="line">2.1. conda create -n niuqiang_llama_0413 -- <span class="built_in">clone</span> llama  <span class="comment"># 根据已有环境创建</span></span><br><span class="line">2.2. conda create --name condamainpython python=3.12.4 <span class="comment"># 新建环境。2024-08-22最新版本</span></span><br><span class="line">2.3. conda create python=3.10 --prefix=/mnt/cfs/guestmodel/runtime</span><br><span class="line">3. <span class="built_in">source</span> activate condamainpython</span><br><span class="line">4. conda activate condamainpython</span><br><span class="line">5. python --version &amp;&amp; python3 --version</span><br><span class="line">6. conda list python</span><br><span class="line">7. conda search python</span><br><span class="line">8. conda info --envs</span><br><span class="line">9. conda remove --name python27 --all</span><br></pre></td></tr></table></figure><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><h3 id="静默安装anaconda"><a href="#静默安装anaconda" class="headerlink" title="静默安装anaconda"></a>静默安装anaconda</h3><p>wget <a href="https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh">https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh</a><br>bash Anaconda3-2021.05-Linux-x86_64.sh<br>source ~&#x2F;anaconda3&#x2F;bin&#x2F;activate</p><p>2024-08-22 14:16:43 anaconda部分的主要内容来自<br>作者：python小达<br>链接：<a href="https://www.zhihu.com/question/353409585/answer/1662315835">https://www.zhihu.com/question/353409585/answer/1662315835</a><br>来源：知乎  </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graalvm+spring3快速入门</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/graalvm+spring3_quick_start/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/graalvm+spring3_quick_start/</url>
      
        <content type="html"><![CDATA[<p>2024-08-21 15:06:17 TODO 在读完</p><ol><li>Spring揭秘2023-02-23</li><li>深入理解Java虚拟机（第3版）2023-02-17</li></ol><p>之后，使用graalvm和spring3升级在使用的spring框架。</p><h1 id="快速试用"><a href="#快速试用" class="headerlink" title="快速试用"></a>快速试用</h1><ol><li>spring初始化 <a href="https://start.spring.io/">https://start.spring.io/</a></li><li><img src="/graalvm+spring3_quick_start/spring3_initializr.png" alt="选项"></li><li>项目初始化完成后，根目录会出现一个HELP.md文件对构建过程做简单指引，备份到 <a href="graalvm+spring3_quick_start/HELP">HELP.md</a></li><li>使用idea调通demo，可以直接启动，与其他spring应用没有区别</li><li>help.md里有介绍，额外两种构建方式<ol><li><code>./mvnw native:compile -Pnative</code> 生成本地可执行程序</li><li><code>./mvnw spring-boot:build-image -Pnative</code> 生成镜像。但是没有调试成功，暂时先放这</li></ol></li></ol><h1 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h1><p>graalvm原生支持的 build pack有点奇怪。在生产部署的时候，怎么能保证有可以用来执行构建命令的环境呢，所以需要在docker中执行，那么问题来了，既然在docker环境中，又怎么产出另一个docker呢？所以这个功能适用于直接推送镜像的场景，而这种操作正是需要避免的，所以更实用的还是生成本地可执行或者jar</p><p>回到贝壳，使用dockerfile构建支持，需要从dockerfile开始从零构建</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><ol><li>使用最新的ubuntu:24.04，升级的目的就是技术上不要落后，所以当然也要使用最新的lts了。这里不使用centos，因为包管理太落后了</li><li>更新apt到国内源遇到问题，出现不适配的问题。推测是版本太新了，国内支持比较弱，所以暂时没有更换国内源</li><li>设置 DEBIAN_FRONTEND&#x3D;noninteractive的作用是避免apt-get命令执行时，个别依赖包要求的交互</li><li>安装java环境的时候不要使用sdkman，下载网速非常慢，几乎不可行。所以使用直接下载jdk的方式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installing script cli archive...</span><br><span class="line">* Downloading...</span><br><span class="line">curl: (56) Failure when receiving data from the peer</span><br><span class="line"></span><br><span class="line">&#x27;curl --fail --location --progress-bar &quot;$&#123;SDKMAN_SERVICE&#125;/broker/download/sdkman/install/$&#123;SDKMAN_VERSION&#125;/$&#123;SDKMAN_PLATFORM&#125;&quot; &gt; &quot;$sdkman_zip_file&quot;&#x27;: command failed with exit code 56.</span><br><span class="line">The command &#x27;/bin/sh -c curl -s &quot;https://get.sdkman.io&quot; | bash&#x27; returned a non-zero code: 56</span><br></pre></td></tr></table></figure></li><li>基础镜像构建完成后上传到harbor.intra.ke.com&#x2F;speech&#x2F;base。因为云平台构建可以依赖到harbor，但是直接使用ubuntu:24.04就会报超时错误<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-08-23 16:48:11   #3 [internal] load metadata for docker.io/library/ubuntu:latest</span><br><span class="line">2024-08-23 16:48:11   #3 sha256:8c6bdfb121a69744f11ffa1fedfc68ec20085c2dcce567aac97a3ff72e53502d</span><br><span class="line">2024-08-23 16:48:49   #3 ERROR: failed to copy: httpReadSeeker: failed open: failed to do request: Get &quot;https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/ed/edbfe74c41f8a3501ce542e137cf28ea04dd03e6df8c9d66519b6ad761c2598a/data?verify=1724405893-6d9Q6dfHh0eXukAhn06q1Pstn38%3D&quot;: dial tcp 31.13.90.19:443: i/o timeout</span><br><span class="line">2024-08-23 16:48:49   ------</span><br><span class="line">2024-08-23 16:48:49    &gt; [internal] load metadata for docker.io/library/ubuntu:latest:</span><br><span class="line">2024-08-23 16:48:49   ------</span><br><span class="line">2024-08-23 16:48:49   ubuntu:latest: failed to copy: httpReadSeeker: failed open: failed to do request: Get &quot;https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/ed/edbfe74c41f8a3501ce542e137cf28ea04dd03e6df8c9d66519b6ad761c2598a/data?verify=1724405893-6d9Q6dfHh0eXukAhn06q1Pstn38%3D&quot;: dial tcp 31.13.90.19:443: i/o timeout</span><br></pre></td></tr></table></figure></li><li>提前创建日志目录&#x2F;data0&#x2F;www&#x2F;logs，线上日志采集会用，不创建启动前会crash</li><li>构建模块不再使用容器内下载代码的方式了，而是直接拷贝，避免不一致</li><li>现在的构建还是使用maven打包成jar，打包native image的方式暂时没有时间验证，等以后有时间吧</li><li>目前以这种方式终于算是阶段性完成了通路，待上线验证</li></ol><h2 id="官方镜像"><a href="#官方镜像" class="headerlink" title="官方镜像"></a>官方镜像</h2><p>2024-08-23 14:09:52 注意graalvm官方提供了打包好对应版本graalvm的镜像，可以直接依赖。但是问题是基础镜像是Oracle Linux Server，很可能是slim版本，没有包管理工具，也就是说完全没有可控性可言，所以尽量不要使用</p><blockquote><p>docker run -idt –name graalvm21 –entrypoint &#x2F;bin&#x2F;bash ghcr.io&#x2F;graalvm&#x2F;native-image-community:21</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash-5.1# cat /etc/os-release</span><br><span class="line">NAME=&quot;Oracle Linux Server&quot;</span><br><span class="line">VERSION=&quot;9.3&quot;</span><br><span class="line">ID=&quot;ol&quot;</span><br><span class="line">ID_LIKE=&quot;fedora&quot;</span><br><span class="line">VARIANT=&quot;Server&quot;</span><br><span class="line">VARIANT_ID=&quot;server&quot;</span><br><span class="line">VERSION_ID=&quot;9.3&quot;</span><br><span class="line">PLATFORM_ID=&quot;platform:el9&quot;</span><br><span class="line">PRETTY_NAME=&quot;Oracle Linux Server 9.3&quot;</span><br></pre></td></tr></table></figure><h2 id="Macbook"><a href="#Macbook" class="headerlink" title="Macbook"></a>Macbook</h2><p>2024-08-23 16:03:59 不要尝试在MacBook上构建镜像，会遇到各种各样奇奇怪怪的问题！，比如国内镜像源没有同步arm系列的依赖包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E: Failed to fetch http://mirrors.ustc.edu.cn/ubuntu/dists/noble/main/binary-arm64/Packages  404  Not Found [IP: 202.141.160.110 80]</span><br></pre></td></tr></table></figure><h1 id="构建启动"><a href="#构建启动" class="headerlink" title="构建启动"></a>构建启动</h1><p>构建过程同java8</p><ol><li>.&#x2F;mvnw -U clean package -Dmaven.test.skip&#x3D;true # 用于构建传统jar包模式</li><li>使用传统方式启动： java -jar xxx.jar</li></ol><p>方案2：</p><ol><li>.&#x2F;mvnw native:compile -Pnative # 用于构建native镜像</li><li>.&#x2F;target&#x2F;interact-universal-graalvm21 –gc&#x3D;G1 –pgo –strict-image-heap -march&#x3D;native -Dspring.profiles.active&#x3D;test<br>native image的方式同样支持-D等传入参数，需要重新整理start.sh</li></ol><h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><ol><li>首先在云平台创建环境</li><li>尝试直接把java8项目直接升级pom、maven、java版本，但是遇到各种奇奇怪怪的问题遥遥无期，所以最好还是反向迁移</li><li>先把graalvm21版本在云平台跑起来</li></ol>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程面试模板</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/202407%E5%B7%A5%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%A8%A1%E6%9D%BF/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/202407%E5%B7%A5%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>2024年06月重新入职贝壳后，整个七月份安排了将近20场面试。</p><p>在面试的过程中发现自己其实缺少面试的方法，每次都重新准备问题，或者被人选的简历细节带着走，所以萌生了总结面试模板的想法。</p><p>换个角度想，自己作为人选时也需要考虑清楚这些问题，所以就有了这篇文章。</p><p>文章适用的对象是初级和中级的后端业务研发工程师。在现在这个资源高度发达的时代，几乎所有做业务的研发都需要具备的基本技能。</p><h1 id="面试模板"><a href="#面试模板" class="headerlink" title="面试模板"></a>面试模板</h1><ol><li>基本情况<ol><li>公司业务。目前是否在职 ；职级<br> 1. </li><li>换工作的原因<br> 1. </li><li>对自己工作方向的规划；对大模型和多模态的了解<br> 1. </li><li>面试进度</li></ol></li><li>项目经历<br> 1. </li><li>项目背景 S<ol><li>为什么要做这件事</li><li>受益对象是哪些；用户量和访问量</li><li>需要什么投入&amp;输入</li></ol></li><li>自己负责的部分 T<ol><li>职责边界在哪里<br> 1. </li><li>解决了什么问题；痛点问题及原因</li><li>达成了什么效果<ol><li></li></ol></li></ol></li><li>方案设计 A<ol><li>在整体中的位置</li><li>各模块的功能  – 你们项目的架构是什么样的，可以说一下数据流向和请求流向吗？</li><li>核心算法</li><li>技术选型；组件选型的考量，有什么优势和限制；无限制的情况下如何重新选型</li><li>每一个组件的工作流和实现原理</li><li>难点在哪；技术上最大的挑战和困难  – 列举一些你在项目中做的比较有挑战的事情或者业务，比如具体的技术细节体现，如何攻坚某个难点，怎么做技术选型的（几乎每个组件都要问一下，问什么要用这个组件，而不是其他的）？<br> 1. </li><li>需要哪些团队协作；有什么问题</li></ol></li><li>达成的效果 R<ol><li>性能测试<br> 1. </li><li>可用性保障和故障排查<ol><li>限流手段<br> 1. </li><li>分布式一致性如何实现<br> 1. </li><li>自动扩缩容策略</li><li>熔断降级策略</li></ol></li><li>项目最终体现的价值</li></ol></li><li>自己有什么思考</li><li>设计一款多模态交互产品的后端架构</li></ol><h1 id="问题环节"><a href="#问题环节" class="headerlink" title="问题环节"></a>问题环节</h1><ol><li>业务层面<ol><li>团队的使命和愿景</li><li>部门的工作横向纵向展开</li></ol></li><li>技术层面围<ol><li>核心能力</li><li>团队情况</li></ol></li></ol><h1 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h1><ol><li>发现候选人特长</li><li>根据贝壳职级标准给出评语</li><li>学习能力</li><li>沟通能力</li><li>团队协作</li><li>思考</li></ol><h1 id="技术工具"><a href="#技术工具" class="headerlink" title="技术工具"></a>技术工具</h1><ol><li>Java：虚拟机（内存管理）、容器、多线程、异常、网络框架线程和内存机制、ORM<ol><li>golang八股文速查 <a href="https://blog.csdn.net/qq_43716830/article/details/124405506">https://blog.csdn.net/qq_43716830/article/details/124405506</a></li><li>c++八股 onedrive中的 亮白风格-C++八股文-小贺-v1.0.pdf</li><li>Python 八股 <a href="https://blog.csdn.net/qq_37085158/article/details/126821933">https://blog.csdn.net/qq_37085158/article/details/126821933</a></li></ol></li><li>分布式原理。相关话题：一致性、高可用、故障恢复<ol><li>说一下 raft 的基本原理，有什么作用？</li><li>了解 zk 的 zab 协议吗？</li><li>paxos 之类的了解吗？</li></ol></li><li>mysql、redis、MongoDB、ES、Base<ol><li>它们的组件都有哪些，如何实现的，流程是怎么样的？</li></ol></li><li>mysql八股 <a href="https://mp.weixin.qq.com/s/L26rI11OV8hrfJVy5Yu78g">https://mp.weixin.qq.com/s/L26rI11OV8hrfJVy5Yu78g</a><ol><li>锁类型与使用</li><li>sql的执行过程</li><li>sql和库表优化</li><li>多副本数据同步方式、故障恢复</li><li>如何分库分表，以及如何解决跨表跨库查询的问题。如何分页</li><li>MySQL 中的事务你介绍下，隔离级别都有啥，怎么实现的？</li><li>MVCC 你说一下怎么实现的，如何解决幻读？</li><li>你们的数据库表是如何设计的？如何设计索引，索引的实现有哪几种方式，为什么要用 B+ 树？</li><li>说一说你项目中的反范式的设计，为什么要用反范式？</li><li>说一说你在使用 MySQL 过程中遇到的坑？</li></ol></li><li>redis八股 <a href="https://mp.weixin.qq.com/s/8-Lf5KiyclW77uQwrYDTCw">https://mp.weixin.qq.com/s/8-Lf5KiyclW77uQwrYDTCw</a><ol><li>zset数据结构的实现</li><li>缓存穿透的成因，危害和解决方案</li><li>redis实现分布式锁的方案和问题</li><li>Redis 的数据结构以及源码深究，为何高性能和快速？</li><li>数据一致性方案是怎么做的？如何做持久化？AOF 重写机制怎么做的？过期策略是怎么样的？</li><li>主从同步的流程是啥样的，什么情况下会触发全量和增量同步？如何解决？</li><li>如何利用 Redis 的数据结构设计一个符合业务需求的数据模型？</li><li>哨兵机制介绍一下？</li><li>I&#x2F;O 模型是啥样的？Redis 是单线程还是多线程？</li><li>如何解决大 Key、冷 Key、热 Key 的问题？</li><li>etcd 是用来干嘛的？怎么实现的？为什么选用 etcd 而不是 Redis？</li></ol></li><li>kafka八股 <a href="https://mp.weixin.qq.com/s/8UNtMIllJ03ULZwE9WtVdg">https://mp.weixin.qq.com/s/8UNtMIllJ03ULZwE9WtVdg</a><ol><li>消息队列的使用场景</li><li>rebalance机制</li><li>如何防止重复消费，如何处理消息丢失</li><li>如何避免消息积压以及挤压如何处理</li></ol></li><li>配置中心、消息队列、负载均衡、监控中心。相关话题：配置中心的同步机制、消息队列的partition机制、负载均衡的路由机制、监控中心的采点聚合机制<ol><li>Prometheus 是怎么做监控告警的？有哪些组件，实现流程是怎么样的？</li></ol></li><li>Http、quic、ws、rpc、graphql。相关话题：rpc的序列化、ws的开关机制、graphql的原理<ol><li>RPC 框架如何实现的，如果是你的话，你会怎么设计 RPC 框架？</li><li>GORM 框架中事务和迁移的实现，Hooks 如何实现？</li><li>你对 Jaeger 和 OpenTracing 怎么理解的？那你怎么理解 TraceID 和 SpanID 的定义的？Jaeger 的实现原理是怎么样的？</li></ol></li><li>测试分析工具</li><li>你如何使用copilot、GPT<ol><li>gpt技巧。</li></ol></li><li>如何做到可读性、可维护性和健壮性</li><li>Mvc和三层架构的区别，ddd的实践<ol><li>Ddd相对来说比较契合，有统一的格式输出</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 职业规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用awscli操作存储服务，非常好用！</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%A4%96%E5%AD%98/aws3/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%A4%96%E5%AD%98/aws3/</url>
      
        <content type="html"><![CDATA[<h1 id="awscli"><a href="#awscli" class="headerlink" title="awscli"></a>awscli</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>您可以使用 pip（一种适用于 Python 的程序包管理器）在大多数 Linux 发行版上安装 AWS Command Line Interface 及其依赖项。</p><blockquote><p>pip install awscli –upgrade</p></blockquote><p>Linux &amp; macOS详见：<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-linux.html">https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-linux.html</a></p><p>Windows 详见：<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-windows.html">https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-windows.html</a></p><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>AWS CLI 提供两个层级的命令来访问 Amazon S3。</p><p>第一个层级名为 s3，由高级别命令构成，这些命令用于频繁使用的操作，如创建、操作和删除对象及存储桶。</p><p>第二个层级名为 s3api，用于公开所有 Amazon S3 操作，包括修改存储桶访问控制列表 (ACL)、使用跨源的资源共享 (CORS) 或日志记录策略。它允许您执行单凭高级别命令无法完成的高级操作。</p><p>要获得每个层级中提供的所有命令的列表，请在 aws s3 或 aws s3api 命令中使用 help 参数：</p><blockquote><p>aws s3 help</p></blockquote><p>或者</p><blockquote><p>aws s3api help</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先进行配置</p><blockquote><p>aws configure</p></blockquote><p>输入如下</p><pre><code>AWS Access Key ID [None]: xxxAWS Secret Access Key [None]: yyyDefault region name [None]: cn-north-1Default output format [None]: json</code></pre><p><strong>在贝壳，生产环境和测试环境都需要使用生产的ak&amp; sk</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>endpoint选项</p><blockquote><p>生产环境：<a href="http://storage.lianjia.com/">http://storage.lianjia.com</a><br>测试环境：<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a></p></blockquote><p>上传单个文件</p><blockquote><p>aws s3 cp –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> &#x2F;Users&#x2F;niuqiang&#x2F;Documents&#x2F;demo.docx s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;demo.docx<br>或者<br>aws s3api –endpoint-url&#x3D;<endpoint> put-object –bucket&#x3D;test –key&#x3D;test.jpeg –body&#x3D;.&#x2F;test.jpeg</p></blockquote><p>上传目录</p><blockquote><p>aws s3 sync –endpoint-url&#x3D;<endpoint> . s3:&#x2F;&#x2F;test&#x2F;test-folder</p></blockquote><p>查看文件列表</p><blockquote><p>aws s3 ls –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;</p></blockquote><p>下载目录</p><blockquote><p> aws s3 sync –endpoint-url&#x3D;<a href="http://storage.lianjia.com/">http://storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F; .&#x2F;</p></blockquote><p>删除文件</p><blockquote><p>aws s3 rm –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;demo.docx</p></blockquote><p>预签名</p><blockquote><p>aws s3 presign –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;E1Ydb0j5Jkg8f3838ab3c7b5bb714c2bcb3a4eb74aeb.docx</p></blockquote><h1 id="某壳实战"><a href="#某壳实战" class="headerlink" title="某壳实战"></a>某壳实战</h1><p>某次收到一个求助，通过aws s3 ls命令获取到的文件列表，最大只能获取到1000行，那么如何才能遍历一个bucket内的所有key</p><p>在网上经过一通调研，发现最终都指向list_objects_v2这个api  </p><ol><li><a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/client/list_objects_v2.html">aws的boto3.ListObjectsV2文档</a></li><li><a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/paginator/ListObjectsV2.html">aws的boto3.Paginator.ListObjectsV2文档</a>  </li><li><a href="https://help.aliyun.com/zh/oss/developer-reference/listobjectsv2">阿里云对象存储的listobjectsv2文档</a></li></ol><p>但是某壳的s3并不支持’ContinuationToken’和’NextContinuationToken’字段，这两个字段一直都是空字符串，而是通过’StartAfter’字段支持分页。秀！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;StartAfter&#x27;</span> <span class="keyword">in</span> response:  <span class="comment"># 通过StartAfter来分页，遍历所有的objects</span></span><br><span class="line">    start_after = response[<span class="string">&#x27;StartAfter&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(response[<span class="string">&#x27;Contents&#x27;</span>]) &lt; maxkey <span class="keyword">or</span> <span class="built_in">len</span>(start_after) == <span class="number">0</span>:  <span class="comment"># 终止条件</span></span><br><span class="line">    has_more_objects = <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库与外存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp技术调研</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202407uniapp%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202407uniapp%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信&#x2F;支付宝&#x2F;百度&#x2F;头条&#x2F;飞书&#x2F;QQ&#x2F;快手&#x2F;钉钉&#x2F;淘宝）、快应用等多个平台。</p><p>DCloud的初心是什么？</p><pre><code>为开发者提供免费、高效的开发工具，让天下没有难做的应用改进应用形态，让用户更方便地获取数字服务</code></pre><p><strong>DCloud也再次承诺不会对uni-app、HBuilderX等工具收费</strong>，感谢数百万开发者的一路陪伴，也请一直监督我们不忘初心！</p><blockquote><p>但是使用过程中，打包环节强行要求与dcloud账号绑定，即使未来出现某种形式的收费也不意外</p></blockquote><h1 id="uni-app组成和跨端原理"><a href="#uni-app组成和跨端原理" class="headerlink" title="uni-app组成和跨端原理"></a>uni-app组成和跨端原理</h1><h1 id="基本语言和开发规范"><a href="#基本语言和开发规范" class="headerlink" title="基本语言和开发规范"></a>基本语言和开发规范</h1><p>uni-app代码编写，基本语言包括js、vue、css。以及ts、scss等css预编译器。</p><p>为了实现多端兼容，综合考虑编译速度、运行性能等因素，uni-app 约定了如下开发规范：</p><pre><code>页面文件遵循 Vue 单文件组件 (SFC) 规范，即每个页面是一个.vue文件组件标签靠近小程序规范，详见uni-app 组件规范接口能力（JS API）靠近小程序规范，但需将前缀 wx、my 等替换为 uni，详见uni-app接口规范数据绑定及事件处理同 Vue.js 规范，同时补充了应用生命周期及页面的生命周期如需兼容app-nvue平台，建议使用flex布局进行开发</code></pre><p>uni-app分编译器和运行时（runtime）。uni-app能实现一套代码、多端运行，是通过这2部分配合完成的。</p><p>编译器将开发者的代码进行编译，编译的输出物由各个终端的runtime进行解析，每个平台（Web、Android App、iOS App、各家小程序）都有各自的runtime。</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器运行在电脑开发环境。一般是内置在HBuilderX工具中，也可以使用独立的cli版。<br>开发者按uni-app规范编写代码，由编译器将开发者的代码编译生成每个平台支持的特有代码</p><p>编译器支持条件编译，即可以指定某部分代码只编译到特定的终端平台。从而将公用和个性化融合在一个工程中。</p><h1 id="uni-app-runtime"><a href="#uni-app-runtime" class="headerlink" title="uni-app runtime"></a>uni-app runtime</h1><p>包括3部分：基础框架、组件、API。</p><h2 id="基础框架："><a href="#基础框架：" class="headerlink" title="基础框架："></a>基础框架：</h2><p>包括语法、数据驱动、全局文件、应用管理、页面管理、js引擎、渲染和排版引擎等<br>在web和小程序上，不需要uni-app提供js引擎和排版引擎，直接使用浏览器和小程序的即可。但app上需要uni-app提供<br>App的js引擎：App-Android上，uni-app的js引擎是v8，App-iOS是jscore<br>App的渲染引擎：同时提供了2套渲染引擎，.vue页面文件由webview渲染，原理与小程序相同；.nvue页面文件由原生渲染，原理与react native相同</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>runtime中包括的组件只有基础组件，如&lt;view&gt;、&lt;button&gt;等。扩展组件不包含在uni-app的runtime中，而是下载到用户的项目代码中。（这些组件都是vue组件）<br>为了降低开发者的学习成本，uni-app的内置基础组件命名规范与小程序基本相同。<br>这几十个组件不管在哪个平台，已被处理为均有一致表现。<br>在小程序端，uni-app基础组件会直接转义为小程序自己的内置组件。在小程序的runtime中不占体积。<br>在web和android、iOS端，这几十个组件都在uni-app的runtime中，会占用一定体积，相当于内置了一套ui库。<br>组件的扩展：<br>有了几十个基础组件，大多数扩展组件也都是基于这些基础组件封装的。比如官方提供的扩展ui库uni ui。<br>在web平台，for web的各种ui库（如elementUI）也可以使用，但这些库由于操作了dom，无法跨端在app和小程序中使用。<br>在App平台，uni-app也支持使用原生编程语言来自行扩展原生组件，比如原生的地图、ar等。<br>uni-app同时支持将微信自定义组件运行到微信小程序、web、app这3个平台。注意微信自定义组件不是vue组件。  </p><h2 id="API："><a href="#API：" class="headerlink" title="API："></a>API：</h2><p>uni-app runtime内置了大量常见的、跨端的 API，比如联网(uni.request)、读取存储(uni.getStorage)<br>同时uni-app不限制各端原生平台的API调用。开发者可以在uni-app框架中无限制的调用该平台所有能使用的API。即，在小程序平台，小程序的所有API都可以使用；在web平台，浏览器的所有API都可使用；在iOS和Android平台，os的所有API都可以使用。<br>也就是说，使用uni-app的标准API，可以跨端使用。但对于不跨端的部分，仍可以调用该端的专有API。由于常见的API都已经被封装内置，所以日常开发时，开发者只需关注uni标准API，当需要调用特色端能力时在条件编译里编写特色API调用代码。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>一个uni-app工程，默认包含如下目录及文件：</p><pre><code>┌─uniCloud 云空间目录，支付宝小程序云为uniCloud-alipay，阿里云为uniCloud-aliyun，腾讯云为uniCloud-tcb（详见uniCloud）│─components 符合vue组件规范的uni-app组件目录│ └─comp-a.vue 可复用的a组件├─utssdk 存放uts文件├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源都应存放于此目录├─uni_modules 存放uni_module 详见├─platforms 存放各平台专用页面的目录，详见├─nativeplugins App原生语言插件 详见├─nativeResources App端原生资源目录│ ├─android Android原生资源目录 详见| └─ios iOS原生资源目录 详见├─hybrid App端存放本地html文件的目录，详见├─wxcomponents 存放小程序组件的目录，详见├─unpackage 非工程代码，一般存放运行或发行的编译结果├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期├─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见├─AndroidManifest.xml Android原生应用清单文件 详见├─Info.plist iOS原生应用配置文件 详见└─uni.scss 内置的常用样式变量</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>注意事项，如果static里有一些没有使用的废文件，也会被打包到编译包里，造成体积变大。</p><p>另外注意，static目录支持特殊的平台子目录，比如web、app、mp-weixin等，这些目录存放专有平台的文件，这些平台的文件在打包其他平台时不会被包含。</p><p>非 static 目录下的文件（vue组件、js、css 等）只有被引用时，才会被打包编译。</p><p>css、less&#x2F;scss 等资源不要放在 static 目录下，建议这些公用的资源放在自建的 common 目录下。</p><h1 id="页面内容构成"><a href="#页面内容构成" class="headerlink" title="页面内容构成"></a>页面内容构成</h1><p>uni-app 页面基于 vue 规范。一个页面内，有3个根节点标签：</p><pre><code>模板组件区 template脚本区 script样式区 style</code></pre><p>在vue的选项式（option）规范中，script下包含 export default {}。除了选项式，还有 组合式 写法。</p><p>页面级的代码大多写在 export default {} 中。写在里面的代码，会随着页面关闭而关闭。</p><h2 id="export-default-外的代码"><a href="#export-default-外的代码" class="headerlink" title="export default 外的代码"></a>export default 外的代码</h2><p>写在 export default {} 外面的代码，一般有几种情况：</p><pre><code>引入第三方 js/ts 模块引入非 easycom 的组件（一般组件推荐使用easycom，无需导入注册）在 ts/uts 中，对 data 进行类型定义定义作用域更大的变量</code></pre><p>开发者应谨慎编写 export default {} 外面的代码，这里的代码有2个注意事项：</p><pre><code>影响应用性能。这部分代码在应用启动时执行，而不是页面加载。如果这里的代码写的太复杂，会影响应用启动速度，占用更多内存。不跟随组件、页面关闭而回收。在外层的静态变量不会跟随页面关闭而回收。如果必要你需要手动处理。比如 beforeDestroy 或 destroyed 生命周期进行处理。</code></pre><h2 id="export-default-里的代码"><a href="#export-default-里的代码" class="headerlink" title="export default 里的代码"></a>export default 里的代码</h2><p>export default {} 里的内容，是页面的主要逻辑代码。包括几部分：</p><p>data：template模板中需要使用的数据。具体 另见<br>页面生命周期：如页面加载、隐藏、关闭，具体 见下<br>methods方法，如按钮点击、屏幕滚动</p><h2 id="style样式区"><a href="#style样式区" class="headerlink" title="style样式区"></a>style样式区</h2><p>style的写法与web的css基本相同</p><h2 id="页面加载时序介绍"><a href="#页面加载时序介绍" class="headerlink" title="页面加载时序介绍"></a>页面加载时序介绍</h2><p>接下来我们介绍onLoad、onReady、onShow的先后关系，页面加载的详细流程。</p><ol><li><p>uni-app框架，首先根据pages.json的配置，创建页面<br>所以原生导航栏是最快显示的。页面背景色也应该在这里配置。</p></li><li><p>根据页面template里的组件，创建dom。<br>这里的dom创建仅包含第一批处理的静态dom。对于通过js&#x2F;uts更新data然后通过v-for再创建的列表数据，不在第一批处理。</p></li><li><p>触发onLoad<br>此时页面还未显示，没有开始进入的转场动画，页面dom还不存在。</p></li></ol><p>所以这里不能直接操作dom（可以修改data，因为vue框架会等待dom准备后再更新界面）</p><p>onLoad比较适合的操作是：接受上页的参数，联网取数据，更新data。</p><p>手机都是多核的，uni.request或云开发联网，在子线程运行，不会干扰UI线程的入场动画，并行处理可以更快的拿到数据、渲染界面。</p><p>但onLoad里不适合进行大量同步耗时运算，因为此时转场动画还没开始。</p><ol start="4"><li><p>转场动画开始<br>新页面开始进入的转场动画，动画默认耗时300ms，可以在路由API中调节时长。</p></li><li><p>页面onReady<br>第2步创建dom是虚拟dom，dom创建后需要经历一段时间，UI层才能完成了页面上真实元素的创建，即触发了onReady。</p></li></ol><p>onReady后，页面元素就可以自由操作了，比如ref获取节点。同时首批界面也渲染了。</p><p>注意：onReady和转场动画开始、结束之间，没有必然的先后顺序，完全取决于dom的数量和复杂度。</p><p>如果元素排版和渲染够快，转场动画刚开始就渲染好了；</p><h2 id="getApp"><a href="#getApp" class="headerlink" title="getApp()"></a>getApp()</h2><p>getApp() 函数用于获取当前应用实例，一般用于获取globalData。也可通过应用实例调用 App.vue methods 中定义的方法。</p><p>不要在定义于 App() 内的函数中，或调用 App 前调用 getApp() ，可以通过 this.$scope 获取对应的app实例<br>通过 getApp() 获取实例之后，不要私自调用生命周期函数。<br>当在首页nvue中使用getApp()不一定可以获取真正的App对象。对此提供了const app &#x3D; getApp({allowDefault: true})用来获取原始的App对象，可以用来在首页对globalData等初始化</p><h2 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a>getCurrentPages()</h2><p>getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，数组中的元素为页面实例，第一个元素为首页，最后一个元素为当前页面。</p><p>getCurrentPages() 仅用于展示页面栈的情况，请勿修改页面栈，以免造成页面状态错误。</p><p>**navigateTo, redirectTo 只能打开非 tabBar 页面。<br>switchTab 只能打开 tabBar 页面。  **<br>&#96;reLaunch&#96;&#96; 可以打开任意页面。<br>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。<br>不能在首页 onReady 之前进行页面跳转。</p><h2 id="页面通讯"><a href="#页面通讯" class="headerlink" title="页面通讯"></a>页面通讯</h2><p>uni.$emit(eventName,OBJECT)<br>触发全局的自定义事件。附加参数都会传给监听器回调。</p><p>uni.$on(eventName,callback)<br>监听全局的自定义事件。事件可以由 uni.$emit 触发，回调函数会接收所有传入事件触发函数的额外参数。</p><p>uni.$once(eventName,callback)<br>监听全局的自定义事件。事件可以由 uni.$emit 触发，但是只触发一次，在第一次触发之后移除监听器。</p><p>uni.$off([eventName, callback])<br>移除全局自定义事件监听器。</p><p>uni.$emit、 uni.$on 、 uni.$once 、uni.$off 触发的事件都是 App 全局级别的，跨任意组件，页面，nvue，vue 等<br>使用时，注意及时销毁事件监听，比如，页面 onLoad 里边 uni.$on 注册监听，onUnload 里边 uni.$off 移除，或者一次性的事件，直接使用 uni.$once 监听</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>uni-app 有两种页面路由跳转方式：使用navigator组件跳转、调用API跳转。</p><p>页面返回时会自动关闭 loading 及 toast, modal 及 actionSheet 不会自动关闭。<br>页面关闭时，只是销毁了页面实例，未完成的网络请求、计时器等副作用需开发者自行处理。</p><p>uni-app 支持在 template 模板中嵌套 template 和 block，用来进行 条件渲染 和 列表渲染。</p><h1 id="js-语法支持"><a href="#js-语法支持" class="headerlink" title="js 语法支持"></a>js 语法支持</h1><h2 id="标准js和浏览器js的区别"><a href="#标准js和浏览器js的区别" class="headerlink" title="标准js和浏览器js的区别"></a>标准js和浏览器js的区别</h2><p>uni-app的js代码，h5端运行于浏览器中。非h5端（包含小程序和App），Android平台运行在v8引擎中，iOS平台运行在iOS自带的jscore引擎中，都没有运行在浏览器或webview里。</p><p>所以uni-app的非H5端，一样支持标准js，支持if、for等语法，支持字符串、数字、时间、布尔值、数组、自定义对象等变量类型及各种处理方法。仅仅是不支持window、document、navigator等浏览器专用对象。</p><h2 id="APP端"><a href="#APP端" class="headerlink" title="APP端"></a>APP端</h2><ol><li>Android<br>JS脚本运行在独立Google V8引擎中，版本与Chrome83一致，因此支持的语法与Android系统版本无关</li></ol><p>vue页面渲染在系统Webview中，受Android系统版本影响，在Android低端机上存在css浏览器兼容性问题，太新的css语法在低版本不支持<br>2. IOS<br>JS脚本运行在iOS操作系统提供的JavaScriptCore 引擎，因此支持的语法与iOS系统有关，跟iOS系统的Safari浏览器一致</p><p>vue页面渲染在系统WKWebview中，受iOS系统版本影响，兼容性与iOS系统的Safari浏览器一致</p><h1 id="页面样式与布局"><a href="#页面样式与布局" class="headerlink" title="页面样式与布局"></a>页面样式与布局</h1><p>uni-app 有 vue 页面、nvue 页面、uvue页面。<br>vue 页面是 webview 渲染的</p><h2 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h2><p>框架组件上支持使用 style、class 属性来控制组件的样式。</p><p>style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</p><p>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>目前支持的选择器有：</p><table><thead><tr><th>选择器</th><th>样例</th><th>样例描述</th></tr></thead><tbody><tr><td>.class</td><td>.intro</td><td>选择所有拥有 class&#x3D;”intro” 的组件</td></tr><tr><td>#id</td><td>#firstname</td><td>选择拥有 id&#x3D;”firstname” 的组件</td></tr><tr><td>element</td><td>view</td><td>选择所有 view 组件</td></tr><tr><td>element, element</td><td>view, checkbox</td><td>选择所有文档的 view 组件和所有的 checkbox 组件</td></tr><tr><td>::after</td><td>view::after</td><td>在 view 组件后边插入内容，仅 vue 页面生效</td></tr><tr><td>::before</td><td>view::before</td><td>在 view 组件前边插入内容，仅 vue 页面生效</td></tr></tbody></table><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>2024年07月03日20:06:57 官方给的hello uni-app可以直接h5和weapp启动，并且提供了组件模版，快速开发就它了</p><h2 id="Recorder-core"><a href="#Recorder-core" class="headerlink" title="Recorder-core"></a>Recorder-core</h2><p>2024-08-05 10:08:27 跨平台Recorder录音插件：支持多种格式、音频可视化、实时上传、语音识别 <a href="https://ext.dcloud.net.cn/plugin?name=Recorder-UniCore">https://ext.dcloud.net.cn/plugin?name=Recorder-UniCore</a></p><blockquote><p>在安卓端试用时疑似有音爆问题。时间上也来不及，所以暂时先用android native实现<br><img src="/./resources/uniapp-recordercore%E5%9C%A8android%E7%AB%AF%E5%BD%95%E9%9F%B3%E9%9F%B3%E7%88%86%E9%97%AE%E9%A2%98.png"></p></blockquote><h2 id="uniapp集成android原生sdk"><a href="#uniapp集成android原生sdk" class="headerlink" title="uniapp集成android原生sdk"></a>uniapp集成android原生sdk</h2><p>2024-08-05 10:12:21 TODO 需要探索的路径，估计有很多模块都需要这么实现 <a href="https://blog.csdn.net/cuper_/article/details/127993632">https://blog.csdn.net/cuper_/article/details/127993632</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>2024-07-12 14:59:06 什么是uni-app <a href="https://uniapp.dcloud.net.cn/">https://uniapp.dcloud.net.cn/</a></p><blockquote><p>比较有用的选型指南，解答为什么使用uniapp的问题</p></blockquote><p>2024-07-15 09:56:56 基础概念和学习vue3 <a href="https://uniapp.dcloud.net.cn/tutorial/vue3-basics.html">https://uniapp.dcloud.net.cn/tutorial/vue3-basics.html</a></p><blockquote><p>vue3的内容比较丰富，可能需要经常回顾，就不往这个文档里摘抄了</p></blockquote><p>2024-07-15 09:57:12 小程序转uniapp指南 <a href="https://ask.dcloud.net.cn/article/35786">https://ask.dcloud.net.cn/article/35786</a></p><p>2024-07-15 09:57:28 uniapp官方教程 <a href="https://ke.qq.com/course/3169971#term_id=103296764">https://ke.qq.com/course/3169971#term_id=103296764</a></p><blockquote><p>没有太多有效的内容</p></blockquote><p>2024-07-15 10:01:43 vue3官方简明教程 <a href="https://cn.vuejs.org/guide/introduction.html">https://cn.vuejs.org/guide/introduction.html</a></p><p>2024-08-01 15:12:36 使用vscode开发 uniapp<br><a href="https://ask.dcloud.net.cn/article/36286">https://ask.dcloud.net.cn/article/36286</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端与小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
