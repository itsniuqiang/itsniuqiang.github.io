<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>待整理</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/readme/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/readme/</url>
      
        <content type="html"><![CDATA[<p>2022年01月07日17:57:35 系统设计<br>第一步根据需求确定系统边界，确定服务承诺和调用约束。最终形成接口文档<br>第二步确定功能模块和实现流程。最终形成泳道图<br>第三步确定实体和调用关系。最终形成C4和数据库设计<br>第四步拆解可复用模块或函数。最终形成可单元测试的代码</p><p>2021年12月31日15:36:19 TODO 分享<br>￼mrcp协议，框架，研发，部署<br>￼brpc httpclient剖析及实践建议<br>￼mvc架构设计<br>￼贝壳自动化部署运维实践<br>￼语音领域任务系统设计<br>￼设计模式实践</p><p>2022年05月12日15:41:31 TODO 设计模式在智能语音领域的实践<br>基础篇——几种设计模式的介绍与分析<br>拔高篇——MVC的介绍、分析与实践<br>进阶篇——领域驱动设计的实践</p><p>2022年05月12日15:49:59 </p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li>插件模式</li><li>观察者模式</li></ol><p>2022年12月31日11:54:17 无锁编程(五) - RCU(Read-Copy-Update)<br>对于被RCU保护的共享数据结构，读操作不需要获得任何锁就可以访问，但写操作在访问它时首先拷贝一个副本，然后对副本进行修改，最后在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。<br><a href="https://blog.csdn.net/linux_bug/article/details/48685403">https://blog.csdn.net/linux_bug/article/details/48685403</a></p><h2 id="通用设计原则"><a href="#通用设计原则" class="headerlink" title="通用设计原则"></a>通用设计原则</h2><p>2023年01月29日18:29:08 对一个系统来说，建立一个简单可靠的业务模型，不但能大大简化系统的设计，而且能以较少的代码实现一个稳定运行的系统，最大限度地减少各种难以预测的错误。</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 待整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD vs MVC</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202409_mvc_vs_ddd/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202409_mvc_vs_ddd/</url>
      
        <content type="html"><![CDATA[<p>MVC即Model、View、Controller即模型、视图、控制器。MVC要实现的目标是将软件用户界面和业务逻辑分离以使代码可扩展性、可复用性、可维护性、灵活性加强。</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p>View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。所以Controller中的内容能少则少，这样才能提供最大的灵活性。</p><h1 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h1><p>不知道大家知不知道另外一种软件开发模式三层架构，它和MVC相似之处是也分为三层，分别是UI层表示用户界面，BLL层表示业务逻辑，DAL层表示数据访问。三层架构曾经红极一时，MVC大行其道之后它就销声匿迹了， 可现在看来， 它似乎只是改头换面， 装扮成MVC的样子</p><h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>现在MVC这种方式也已经不再使用了，而主流的是前后端分离，不再需要View这个模块了，不需要再关注于前端了，我们只要约定好接口，写好后端即可，所以，对于后端，也有了一种新的分层方式，就是三层架构，分为以下三层：</p><pre><code>表现层：展示数据结果，和接收用户的请求业务逻辑层：负责处理业务逻辑数据层：负责存储和管理数据</code></pre><p>按照这样的层次划分，Spring MVC 站在后端的角度上，就将代码分成了：</p><pre><code>Controller 层：控制层，用来接收前端发来的请求，在Service 层中选择对应的处理逻辑，并且给前端进行响应Service 层：业务逻辑层，对发来的请求进行具体的逻辑处理Dao 层：数据访问层，负责访问数据库，进行增删查改的操作</code></pre><h1 id="三层架构和MVC的关系"><a href="#三层架构和MVC的关系" class="headerlink" title="三层架构和MVC的关系"></a>三层架构和MVC的关系</h1><p>从概念上来讲，两者都是软件工程中的架构模式，并且两者也是非常相似的，就如下面这张图：</p><p>三层架构的“表现层”也就是对应着MVC的 View层 和 Ctroller层，因为它们都是用来展示数据和接收请求的，所以，站在后端人员的角度上看，其实， 表现层也可以看成是视图层，三层架构中的业务逻辑层和数据层对应的就是MVC中的model层，都是用来处理业务逻辑的。二者只不过是从不同角度上进行了抽象，MVC它强调的是数据和视图的分离，将数据的展示和数据的处理分开。通过控制器对两者进行结合。三层架构强调的是从不同纬度上对数据进行处理，以达到“高内聚，低耦合”</p><p>高内聚：一个模块中各个元素之间的联系的紧密程度，如果各个元素之间的联系程度越高，则内聚性越高，即“高内聚”。</p><p>低耦合：项目中，各个层或者模块间的依赖关联程度越低越好，不会因为修改一处代码，造成很多的代码都需要改动。</p><h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h1><p>2024年06月17日09:34:27 目前来看ddd与现在流行的mvc并没有本质区别，存在着对应关系，所以代码结构上也是参照ddd的划分，而不是单纯的ddd或mvc</p><p>2024年06月17日09:56:59 TODO 深入学习ddd模式</p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024年06月17日09:55:46 尝试学习了一下，目前还没有发现与intelli-platform-service的显著区别 <a href="https://wiki.lianjia.com/pages/viewpage.action?pageId=826714185">DDD最佳实践-理解领域驱动设计中的聚合</a></p><h1 id="跟进记录归档-1"><a href="#跟进记录归档-1" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024年06月13日17:50:21 学习什么是MVC，以及演化后的新三层架构。现在spring代码基本都是新三层 <a href="https://blog.csdn.net/Shine0115/article/details/138645524">什么是MVC？什么是SpringMVC？什么是三层架构？</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mvc </tag>
            
            <tag> DDD </tag>
            
            <tag> 后端架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研发基础镜像构建脚本</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E5%9F%BA%E7%A1%80%E7%A0%94%E5%8F%91%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E5%9F%BA%E7%A1%80%E7%A0%94%E5%8F%91%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu C++研发版</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONIOENCODING utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> TERM=xterm-<span class="number">256</span>color</span><br><span class="line"><span class="keyword">ENV</span> LANG=C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新依赖源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g /etc/apt/sources.list &amp;&amp;</span></span><br><span class="line">        sed -i s/security.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g /etc/apt/sources.list &amp;&amp;</span><br><span class="line">        rm -rf /var/lib/apt/lists/* &amp;&amp;</span><br><span class="line">        apt list --upgradable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装系统依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp;</span></span><br><span class="line">        apt-get install -y apt-utils supervisor cron rsync git g++ make cmake build-essential automake autoconf libtool pkg-config libssl-dev zlib1g-dev libbz2-dev gfortran texinfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install git-lfs -y &amp;&amp; git lfs install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装环境依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y <span class="built_in">sudo</span> curl net-tools clang-format tree gdb cgdb vim wget valgrind screen ctags cppcheck</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装C++依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y libboost-all-dev uuid-dev libjsoncpp-dev libgflags-dev libunwind-dev libgoogle-glog-dev libgtest-dev libgoogle-perftools-dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装语音依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y libass-dev libfreetype6-dev libsdl2-dev libtheora-dev libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev</span></span><br><span class="line">    apt install -y libavformat-dev libavcodec-dev libswresample-dev libswscale-dev libavutil-dev libsdl1.<span class="number">2</span>-dev libmp3lame-dev</span><br></pre></td></tr></table></figure><p>Centos7 C++研发版</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:centos7.<span class="number">8.2003</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> niuqiang niuqiang@didiglobal.com</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/niuqiang</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基本工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install epel-release</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install initscripts git rsync openssh-server openssh-clients net-tools wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install automake autoconf libtool make cmake</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y groupinstall -y <span class="string">&quot;Development Tools&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install gcc gcc-c++ gcc-go python3 gdb gdb-gdbserver cgdb</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y update gdb</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install zlib-devel openssl-devel</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install redis mysql</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> --depth 1 https://github.com/junegunn/fzf.git ~/.fzf &amp;&amp; ~/.fzf/install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装golang</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> rpm --import https://mirror.go-repo.io/centos/RPM-GPG-KEY-GO-REPO</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -s https://mirror.go-repo.io/centos/go-repo.repo | <span class="built_in">tee</span> /etc/yum.repos.d/go-repo.repo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install golang</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装vim8.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum remove vim-* -y &amp;&amp; wget -P /etc/yum.repos.d/  https://copr.fedorainfracloud.org/coprs/lbiaggi/vim80-ligatures/repo/epel-7/lbiaggi-vim80-ligatures-epel-7.repo &amp;&amp; yum  install vim-enhanced <span class="built_in">sudo</span> -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动sshserver</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/run/sshd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;root:d486d275&#x27;</span> | chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/PermitRootLogin prohibit-password/PermitRootLogin yes/&#x27;</span> /etc/ssh/sshd_config</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m clion &amp;&amp; <span class="built_in">yes</span> d486d275 | passwd clion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span> <span class="number">7777</span> <span class="number">8096</span> <span class="number">8098</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /usr/sbin/sshd -D</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. build</span></span><br><span class="line"><span class="comment"># docker build . -f Dockerfile -t niuqiang_test_centos7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. run</span></span><br><span class="line"><span class="comment"># docker run -itd --cap-add sys_ptrace -p 8022:22 -p 8096:8096 --name niuqiang_test_wenet continuumio/anaconda3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. login</span></span><br><span class="line"><span class="comment"># ssh root@localhost -p 8022 # test</span></span><br><span class="line"><span class="comment"># docker exec -it mycentos-0.2 /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. start sshd</span></span><br><span class="line"><span class="comment"># /usr/sbin/sshd -D</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作相关的命令行工具</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>cat notqiedan20190226.log | awk ‘{match($0,&#x2F;(.<em>)induce][result:(.</em>)][sid:(.*)&#x2F;,a);print a[2]}’ &gt; notqiedan-result-20190226.txt</p><p>sudo tcpdump -vvv -X -s0 “tcp and host 10.86.90.23 and port 8060”</p><p>valgrind –tool&#x3D;memcheck –leak-check&#x3D;full –track-origins&#x3D;yes –leak-resolution&#x3D;high –show-reachable&#x3D;yes –log-file&#x3D;attention_memcheck.log –vex-guest-max-insns&#x3D;25 .&#x2F;bin&#x2F;speech-asr-attention</p><p>curl -H “Content-Type:application&#x2F;json” -d ‘{“uid”:”0000001”, “raw_text”: “查天气”}’ “10.85.128.81:30379&#x2F;ds”</p><p>netstat -nlp  | grep port</p><p>ps -ef | grep process</p><p>ls -hal &#x2F;proc&#x2F;12345</p><p>netstat -nlp</p><p>ctrl + z 可以将一个正在前台执行的命令放到后台，并且暂停<br>然后 jobs -l 可以看到这个进程已经变成了一个任务<br>然后bg %任务号 可以在后台暂停的命令，变成继续执行<br>或者fg %任务号 将后台中的命令调至前台继续运行<br>杀死这种进程必须kill -9 pid</p><p>sudo chown -R niuqiang:niuqiang .   递归修改目录下的文件权限，只能root权限执行</p><p>使用命令帮助：whatis info man which whereis<br>在只记得部分命令关键字的场合，我们可通过man -k来搜索；<br>需要知道某个命令的简要说明，可以使用whatis；而更详细的介绍，则可用info命令；<br>查看命令在哪个位置，我们需要使用which；<br>而对于命令的具体参数及使用方法，我们需要用到强大的man；<br>whereis：locate the binary, source, and manual page files for a command<br>$man 3 printf  查看库函数中prinf的手册<br>TODO：alias给命令和文件设置别名。如何知道一个别名的正名</p><p>文件及目录管理：<br>文件管理，目录的创建、删除、查询、管理: mkdir rm ls mv cp<br>目录切换 cd pwd<br>查看文件内容：less&gt;more&gt;cat|head|tail，diff<br>改变文件的拥有者 chown；改变文件读、写、执行等属性 chmod<br>TODO：ln设置硬链接和符号链接<br>管道和重定向: ; | &amp;&amp; || &gt;。连接执行，使用 |，；串联执行 ;&amp;&amp;前面成功，则执行后面一条，否则，不执行；|| 前面失败，则后一条执行；<br>启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；TODO:各级profile的加载顺序<br>$ls -lat 按修改时间排序列表式展示所有<br>$ls -lat | cat -n<br>$tail -f file 可以动态显示文本的追加<br>$chown -R tuxapp source&#x2F; 递归修改目录的拥有者<br>$ls  proc&#x2F;*.c &amp;&gt; list  将标准输出和标准错误重定向到同一文件；<br>$: &gt; a.txt 清空文件</p><p>磁盘管理：df du tar gzip gunzip bzip2 bunzip2<br>查看参数文件所在磁盘空间利用大小:df -h，如果没有参数，则列出所有<br>查看参数文件所占空间大小:du -sh，如果没有参数，则递归列出所有文件夹<br>打包是将多个文件归并到一个文件:tar -cvf etc.tar &#x2F;etc<br>解包：tar -xvf demo.tar<br>-z 解压gz文件<br>-j 解压bz2文件<br>-J 解压xz文件<br>$du -sh <code>ls</code> | sort  查看当前目录下所有子文件夹排序后的大小<br>$tar –exclude ‘*.svn’ -cvf - &#x2F;path&#x2F;to&#x2F;source | ( cd &#x2F;path&#x2F;to&#x2F;target; tar -xf -)  用tar实现文件夹同步，排除部分文件不同步.TODO：括号的含义<br>$tar -zcvf new.tar .&#x2F;xxx .&#x2F;yyy  以gzip形式打包</p><p>运行时管理<br>(2)top指定查看PID<br>[root@6 ~]# top -p 21538,31117,31116,31115,31114</p><p>2018年12月28日16:50:01 可以的话使用zsh代替bash，然后安装oh-my-zsh</p><p>2019年01月08日18:10:55 在pidfile的目录下查看进程的启动位置<br>每个进程启动之后在 &#x2F;proc下面有一个于pid对应的路径<br>例如：ps -ef|grep python<br>显示：oracle    4431  4366  0 18:56 pts&#x2F;2    00:00:00 python Server.py<br>4431就是进程号<br>到&#x2F;proc&#x2F;4431下，ls -l 会看到：<br>总用量 0<br>-r–r–r–    1 oracle   oinstall        0 12月 29 18:58 cmdline<br>lrwxrwxrwx    1 oracle   oinstall        0 12月 29 18:58 cwd -&gt; &#x2F;XXX&#x2F;ultserver_aa<br>-r——–    1 oracle   oinstall        0 12月 29 18:58 environ<br>lrwxrwxrwx    1 oracle   oinstall        0 12月 29 18:58 exe -&gt; &#x2F;usr&#x2F;bin&#x2F;python2.4<br>dr-x——    2 oracle   oinstall        0 12月 29 18:58 fd<br>-r——–    1 oracle   oinstall        0 12月 29 18:58 maps<br>-rw——-    1 oracle   oinstall        0 12月 29 18:58 mem<br>-r–r–r–    1 oracle   oinstall        0 12月 29 18:58 mounts<br>lrwxrwxrwx    1 oracle   oinstall        0 12月 29 18:58 root -&gt; &#x2F;<br>-r–r–r–    1 oracle   oinstall        0 12月 29 18:58 stat<br>-r–r–r–    1 oracle   oinstall        0 12月 29 18:58 statm<br>-r–r–r–    1 oracle   oinstall        0 12月 29 18:58 status<br>注意cwd，即是你要查找的进程所在路径。 ……</p><p>linux shell 脚本编写好要经过漫长的调试阶段，可以使用sh -x 执行。但是这种情况在远程调用脚本的时候，就有诸多不便。</p><p>又想知道脚本内部执行的变量的值或执行结果，这个时候可以使用在脚本内部用 set -x 。</p><p>set去追踪一段代码的显示情况，执行后在整个脚本有效</p><p>set -x 开启<br>set +x关闭<br>set -o 查看<br>${file:-my.file.txt} ：假如$file 沒有設定或為空值，則使用my.file.txt 作傳回值。(非空值時不作处理)</p><p>filename.gz</p><p>gunzip -c filename.gz &gt; filename # 如果不指定解压后保存，那么会输出到当前命令行</p><p>清空文件内容</p><p>truncate -s 0 filename</p><p>Linux 命令其实就是一堆注册在&#x2F;usr&#x2F;bin&#x2F;的快捷方式</p><p>使用man xxx可以查看详细手册</p><p>1.可执行程序或shell命令<br>ps &#x3D; processes snapshot，进程快照。资源管理器使用top命令<br>ps -ef |axu #详细查看所有进程 ps axjf #所有进程列成目录树<br>mkdir &#x3D; make directories<br>rm &#x3D; remove<br>rm -rfv #强制删除文件夹并输出详细信息<br>source #在当前的bash环境中执行指定的文件。bash自带命令，而不是系统命令<br>systemctl #control the systemd system and service manager<br>systemctl enable nginx.service # 设置服务开机启动<br>pwd &#x3D; print the full filename of the current working directory # 查看当前全路径<br>whereis &#x3D; locate the binary,source,and manual pages for a command in PATH &amp;MANPATH<br>which &#x3D; the path of commands in PATH<br>stat &#x3D; display file or file system status。查看文件在磁盘上的信息<br>file -i #determine file type，查看文件详细信息。<br>less &#x3D; file filter for crt viewing。基于more命令和vi并提供更强大的功能<br>G 从尾部开始查看<br>more # 分页显示可读文件。<br>nl &#x3D; number lines of file #带行号的查看文件<br>head<br>tail<br>2.系统调用<br>3.编程库调用<br>4.特殊文件<br>5.文件格式和转换<br>6.游戏<br>7.杂项<br>8.系统管理<br>rpm &#x3D; redhat package manager，类redhat系统的包管理体系<br>rpm -qa #查看所有已经安装的程序<br>ss &#x3D; socket statistics，netstat的替代<br>ss -ap #会列出所有正在使用的端口及关联的进程&#x2F;应用 &#x3D; netstat -nap<br>lsof &#x3D; list open file 查看所有打开的“文件”，设备和进程等也是以文件存在的<br>lsof -i #i &#x3D; Internet，查看端口占用情况<br>Unclassified<br>rz afile # 发送文件到服务器<br>sz afile # 从服务器接收文件<br>vimdiff<br>uname -a # 查看系统信息<br>top 实时查看资源管理器</p><p>2022年01月12日19:38:41 ps -ef 和 netstat -nlp 看到的进程号不同是什么情况，而且netstat看到的准确</p><p>2018年7月13日17:10:30 学习rsync工具，未果</p><p>2018年7月13日18:37:17 linux下使用zip压缩解压</p><blockquote><ol><li>zip -r &#x2F;home&#x2F;niuqiang&#x2F;Document&#x2F;include.zip &#x2F;usr&#x2F;include</li><li>unzip -o &#x2F;home&#x2F;niuqiang&#x2F;Document&#x2F;include.zip -d &#x2F;usr&#x2F;include</li></ol></blockquote><p>2018年7月13日18:40:39 linux查看磁盘占用</p><blockquote><p>du -s -h .</p></blockquote><p>2019年09月23日11:11:29 linux合并文件夹</p><ol><li>cp -frap new&#x2F;* old&#x2F;</li><li>rsync -av new&#x2F;* old&#x2F;</li></ol><p>2019年12月10日19:35:55 rsync -av会覆盖旧文件，但是保留不被覆盖的旧文件，所以尽量代替rm -rf output&#x2F;</p><p>2020年10月10日17:33:31 通过rename命令，统一修改日记文件的命名格式<br>rename ‘s&#x2F;(.<em>)-(.</em>)-(.*).md&#x2F;$1年$2月$3日.md&#x2F;‘ *.md</p><h1 id="find-命令常见用法"><a href="#find-命令常见用法" class="headerlink" title="find 命令常见用法"></a>find 命令常见用法</h1><ol><li>使用find和sed递归重命名文件<br>for i in <code>find . -type f -name &#39;*.aar&#39;</code> ; do mv $i <code>echo $i | sed &#39;s/aar/zip/&#39;</code> ; done</li><li>当文件过多时使用ls、mv、rm等命令会报 “Argument list too long”，使用find代替之<br>for num in <code>find . -name  &quot;*.wav&quot;</code>;do;file&#x3D;${num%.*};$(ffmpeg -i ${file}.wav -f s16le -ar 16000 -ac 1 -acodec pcm_s16le ${file}.pcm);done</li><li>求目录下所有文件的md5<br>find . -type f -print0 | xargs -0 md5sum | sort &gt;md5.txt</li><li>grep如何递归目录并在指定类型文件中查找  <ol><li>find . -name “*.c” | xargs grep “aaa”</li><li>rgrep key_word *.c *.h</li><li>find   &#x2F;root   -name   ‘*.h’   -exec   grep   ‘aaa’   {}   ;</li></ol></li><li>删除所有日志<br>find . -name “*.log” -exec rm {} ;  </li><li>查看所有配置文件<br>find conf -type f -exec cat {} ;</li><li>批量移动文件<br>find . -name “*_test.go” -exec mv {} test&#x2F;unittest ;</li><li>文件的查询和检索: find locate。find是实时查找，如果需要更快的查询，可试试locate；updatedb会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库:locate是直接在全盘范围内查询，find默认在当前路径下递归</li><li>find . -size +50M  # 查找给定大小限制的文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件操作 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/journaling/%E5%85%B3%E4%BA%8E%E6%88%91/202405%E4%B8%89%E5%8D%81%E5%B9%B4%E6%A2%A6%E6%83%B3%E6%89%8B%E5%86%8C/"/>
      <url>/journaling/%E5%85%B3%E4%BA%8E%E6%88%91/202405%E4%B8%89%E5%8D%81%E5%B9%B4%E6%A2%A6%E6%83%B3%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>2024年04月17日16:02:07 暂时搁置。找到新工作后再规划小目标计划</p><p>2024年05月13日18:28:05 根据《财务自由之路》指导，将小目标计划升级为梦想手册</p><p>2024年06月24日14:34:38 从孙建伟的反省，你是不是真的想成功？大部分人不是的，需要一些刺激条件，负面的或正面的。我也需要找到自己的足额刺激条件 TODO</p><hr><h1 id="三十年目标（人生目标）"><a href="#三十年目标（人生目标）" class="headerlink" title="三十年目标（人生目标）"></a>三十年目标（人生目标）</h1><p>2024年05月06日22:26:46 一次做三十年的职业规划；逃无可逃，并突破时代对个人的局限性</p><p>2024年06月03日08:03:36 终极目标：</p><ol><li>让每个（相信我的）中国人都能够有被动收入。理财+保险</li><li>让每个（相信我的）中国人都能健康活到九十岁。健身房，教练模式，上市</li></ol><p>子子孙孙无穷匮，理财可能需要大量的数学基础，可能已经不是我能达成的了，必要的时候托付给其他人继续。但是此生我也应该作出全力的努力。</p><p>这两项都是营销能力大于业务能力，首先需要积累足够的业务能力，然后集中攻克营销难题</p><h2 id="被动收入"><a href="#被动收入" class="headerlink" title="被动收入"></a>被动收入</h2><p>2024年06月03日08:06:14 首先要求我有一定的理财能力。需要了解理财和保险</p><h2 id="保持健康"><a href="#保持健康" class="headerlink" title="保持健康"></a>保持健康</h2><p>2024年06月03日08:10:23 首先需要我有一定的健身基础。健身教练证首先必不可少，长期积累开健身房的经验</p><p>2024年06月03日08:18:08 始于新馨苑六号地块的一楼商铺出售。如果我能拿下这个项目，我会做什么。便利店+健身房，便利店可以取名叫 友家</p><p>2024年06月03日08:18:51 健身房的新模式可以是这样：国家只给颁发教练证，但是我们可以模仿大众点评的方式，建立自己的评价体系，可以对健身房和健身教练评分，这是第一层；对健身老手在具体项目上评分，评分越高，与客户的分差越高，要求陪练的费用越高。这样就可以实现老带新，每个参与健身的人也都能盈利，平台对盈利抽成，这是第二层；健身房开放次卡和时卡，用于普惠，这是第三层</p><p>2024年06月03日08:22:31 但是这个模式的有两个明显问题：</p><ol><li>需要避免传销，有老带新环节。这里需要作出限制，比如出课总时长</li><li>需要严格计算次卡和时卡的定价，否则可能入不敷出</li></ol><hr><h1 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h1><table><thead><tr><th></th><th>2024</th><th>2026</th><th>2030</th><th>2034</th><th>2054(终极)</th></tr></thead><tbody><tr><td>健康</td><td>开始</td><td>拿到教练证</td><td>有比较全面的业务能力积累</td><td>有一定的知名度</td><td>全面铺开</td></tr><tr><td>理财</td><td>开始</td><td>完成转行</td><td>拿到金融学学位</td><td>有一定的知名度</td><td>全面铺开</td></tr><tr><td>财富</td><td>开始</td><td>开始进行投资</td><td>一千万</td><td>三千万</td><td>一个亿</td></tr></tbody></table><p>2024年05月06日22:27:30 第一个里程碑一千万，显然就不是打工可以取得的了。先找个工作深入产业，再看看有没有什么好机会。<br>2024年6月16日08:52:13 一个人要积累真正的财富只有一条道路：必须建立起自己的企业。可以先假定五年内。TODO具体调研<br>2024年6月16日08:52:30 你所有的决定都应该向着这个目标看齐——3年后成为你所在领域的专家<br>2024年06月03日08:26:50 可以选做个取名 bitwise比特智慧 的公众号，用于扩大在计算机应用方面的影响力</p><p>2024年06月17日10:22:32 TODO 结合财务自由之路的指导，细化里程碑和行动列表</p><ol><li>每月结识一个领域专家</li><li>三年内如何成为一个领域专家</li><li>五年内如何创建一个企业</li></ol><h1 id="财富计划"><a href="#财富计划" class="headerlink" title="财富计划"></a>财富计划</h1><p>2024年02月24日17:50:55 2024年度计划抽象到更高远的人生计划就是 —— 一个小目标</p><ol><li><p>三千万用于买朱辛庄别墅</p></li><li><p>两千万用于两个子女教育</p></li><li><p>剩余五千万用于日常开销和养老 TODO 计算只靠利息生存需要多少养老金</p></li><li><p>屁股<br> <img src="/../../resource/images/%E6%A2%A6%E6%83%B3%E6%89%8B%E5%86%8C/2010thesufferingdays.jpg" alt="2010thesufferingdays"></p><p> <img src="/../../resource/images/%E6%A2%A6%E6%83%B3%E6%89%8B%E5%86%8C/2015thelovelydays.jpg" alt="2015thelovelydays"></p></li></ol><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统常用工具</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>2023年03月09日18:37:51 放弃使用shell，万事皆可python<br>2024年02月24日22:01:34 除非20行内可以实现，否则建议使用python代替shell</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><a href="https://cloud.tencent.com/developer/article/1589827">超详细的网络抓包神器 Tcpdump 使用指南</a><br>必选：<br>-s0 : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。<br>-v : 使用 -v，-vv 和 -vvv 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。<br>-X 表示同时使用十六进制和 ASCII 字符串打印报文的全部数据。这两个参数不能一起使用。</p><p>GET:sudo tcpdump -vv -X -s0 ‘dst port 8092 and (tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] &#x3D; 0x504f5354)’ -w ucenter.pcap<br>POST:sudo tcpdump -vv -X -s0 ‘dst port 8092 and (tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] &#x3D; 0x47455420)’ -w ucenter.pcap</p><p>sudo tcpdump -vv -X -s0 dst host 10.88.128.15 -w ucenter.pcap</p><p>sudo tcpdump -vv -X -s0 ‘dst test-bella.aicloud.ke.com’ -w tcp.pcap</p><p>使用wireshark打开该文件，分析http请求的具体内容</p><p>api instal tcpdump &amp;<br>抓TCP的网络包并打印到标准输出 tcpdump -Annps256 -i eth0 tcp port 12383 and host 10.200.13.245</p><h2 id="goreplay"><a href="#goreplay" class="headerlink" title="goreplay"></a>goreplay</h2><p>wget “<a href="https://github.com/buger/goreplay/releases/download/1.3.3/gor_1.3.3_amd64.deb">https://github.com/buger/goreplay/releases/download/1.3.3/gor_1.3.3_amd64.deb</a>“ # 下载</p><p>sudo dpkg -i gor_1.3.3_amd64.deb &amp;&amp; dpkg -c gor_1.3.3_amd64.deb # 安装</p><p>sudo -i &#x2F;home&#x2F;odin&#x2F;niuqiang&#x2F;goreplay –input-raw :80 –http-allow-url &#x2F;asr –output-file&#x3D;requests.gor  # 导出文件</p><p>2019年04月06日12:52:08 goreplay复制的流量中，每个请求以三个特殊字符分隔&lt;U+1F435&gt;&lt;U+1F648&gt;&lt;U+1F649&gt;，所以可以编辑流量文件，以复现单个请求</p><p>sudo -i &#x2F;home&#x2F;odin&#x2F;niuqiang&#x2F;goreplay –input-raw :8095 –output-http&#x3D;”<a href="http://10.90.67.16:8095|1%">http://10.90.67.16:8095|1%</a>“  # 直接复制</p><p>sudo -i &#x2F;home&#x2F;odin&#x2F;niuqiang&#x2F;goreplay –input-file&#x3D;&#x2F;home&#x2F;niuqiang&#x2F;goreplay&#x2F;asr-requests201901091700.gor –output-http&#x3D;”<a href="http://localhost:8097/">http://localhost:8097</a>“ –output-http-timeout 30s –output-http&#x3D;”<a href="http://10.164.3.42:8095|200%">http://10.164.3.42:8095|200%</a>“ –stats –output-http-stats # 文件回放</p><h1 id="sed-awk"><a href="#sed-awk" class="headerlink" title="sed&amp;awk"></a>sed&amp;awk</h1><p>比如有一个数据文件test.txt，只有一列（在之前可以通过各种手段过滤出只有数字这一列），比如操作的响应时间</p><p>1、求和</p><p>sed ‘&#x2F;^$&#x2F;d’ test.txt|awk ‘{sum+&#x3D;$1} END {print “Sum &#x3D; “, sum}’<br>2、求平均</p><p>sed ‘&#x2F;^$&#x2F;d’ test.txt|awk ‘{sum+&#x3D;$1} END {print “Average &#x3D; “, sum&#x2F;NR}’<br>3、求最大值</p><p>sed ‘&#x2F;^$&#x2F;d’ test.txt|awk ‘BEGIN {max &#x3D; 0} {if ($1&gt;max) max&#x3D;$1 fi} END {print “Max&#x3D;”, max}’<br>4、求最小值（min的初始值设置一个超大数即可）</p><p>sed ‘&#x2F;^$&#x2F;d’ test.txt|awk ‘BEGIN {min &#x3D; 100} {if ($1&lt;min) min&#x3D;$1 fi} END {print “Min&#x3D;”, min}’</p><h2 id="统计文件里面特定字符串出现次数"><a href="#统计文件里面特定字符串出现次数" class="headerlink" title="统计文件里面特定字符串出现次数"></a>统计文件里面特定字符串出现次数</h2><p>1.第一种方法：使用grep命令进行统计<br>grep -o ‘字符串’ file |wc -l</p><p>2.第二种方法：使用awk命令进行统计<br>awk -v RS&#x3D;”@#$j” ‘{print gsub(&#x2F;字符串&#x2F;,”&amp;”)}’ file</p><p>3.第三种方法：另一种使用awk命令进行统计的方法<br>awk  ‘{s+&#x3D;gsub(&#x2F;字符串&#x2F;,”&amp;”)}END{print s}’ file</p><p>2020年03月06日11:00:32 不打开文件全局替换并备份文件：sed -i.bak ‘s&#x2F;foo&#x2F;bar&#x2F;g’</p><h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><h4 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h4><p>1、查看哪个二进制文件生成core文件，及其生成时间<br>file core core.*</p><h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><p>set args help<br>就能加上可执行文件需要的参数，如果要看argc[1]到argc[N]的参数，只需要<br>(gdb) show args</p><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><ol><li>多个源文件时指定breakpoint的位置<br>当有多个源文件的时候，用dir命令把你所想加入的文件的目录指定出来，然后指定源文件设置断点：<br>break filename:linenum</li><li>watch div1&#x3D;&#x3D;div2当变量div1yu div2相等时进入中断。</li></ol><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol><li><p>p命令中加参数以不同形式打印变量的值</p></li><li><p>使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：<br>x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; <addr><br>n、f、u是可选的参数。</p></li><li><p>(gdb) whatis i<br>即可知道i是什么类型的变量</p></li><li><p>设置变量<br>set 变量 &#x3D; 新值 &#x2F; print var&#x3D;value</p></li><li><p>gdb打印C++ std::vector 元素<br>打印多个元素 print *(your_vector._M_impl._M_start)@your_vector_size</p></li></ol><p>#打印单个元素[n指下标] print *(u._M_impl._M_start+n)</p><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ol><li>attach： process-id: 在GDB状态下，开始调试一个正在运行的进程，其进程ID为process-id</li></ol><p>detach: 停止调试当前正在调试有进程，与attach配对试用</p><p><strong>使用attach可以发现coredump中可能不会保存的信息</strong><br>2. kill<br>如果想不退出GDB而对当前正在调试的应用程序重新编译、链接，可以在GDB中执行kill杀掉子进程，等编译、链接完后，再重新执行run，GDB便可加载新的可执行程序启动调试<br>3. 多线程程序调试相关：</p><p>（1）thread threadno：切换当前线程到由threadno指定的线程<br>（2）info threads：查看GDB当前调试的程序的各个线程的相关信息<br>（3）thread apply [threadno] [all] args：对指定（或所有）的线程执行由args指定的命令<br>4. step<br>比较常见的应用场景：在函数func被调用的某行代码处设置断点，等程序在断点处停下来后，可以用step命令进入该函数的实现中，但前提是该函数编译的时候把调试信息也编译进去了，否则step会跳过该函数。<br>5. next [count]: 如果没有指定count, 单步执行下一行程序<br>6. continue [ignore-count] 唤醒程序，继续运行，至到遇到下一个断点，或者程序结束。<br>7. finish: 继续执行程序，直到当前被调用的函数结束，如果该函数有返回值，把返回值也打印到控制台<br>（2）return [expression]: 中止当前函数的调用，如果指定了expression，把expresson值当做当前函数的返回值；如果没有，直接结束当前函数调用</p><h4 id="执行位置"><a href="#执行位置" class="headerlink" title="执行位置"></a>执行位置</h4><ol><li>查看堆栈信息<br>(gdb)bt<n> n代表查看n层堆栈信息<br>bt &#x2F; backtrace &#x2F; bt full</li><li>frame <n> 进入第n层堆栈</li><li>查看当前栈层的信息<br>(gdb)info f<br>⑴ 向上移动n层，不加n，默认一层<br>(gdb)up<br>⑵ 向下移动n层，不加n，默认一层<br>(gdb)down</li><li>打印当前函数的参数及其值<br>(gdb)info args</li><li>打印当前frame所有变量的值<br>(gdb)info locals</li><li>打印当前函数的异常处理信息<br>(gdb)info catch</li></ol><h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>推荐且只推荐spacevim，不要尝试其他vimrc了<br>2019年12月10日18:27:17 安装spacevim<br>curl -sLf <a href="https://spacevim.org/cn/install.sh">https://spacevim.org/cn/install.sh</a> | bash<br>curl -sLf <a href="https://spacevim.org/install.sh">https://spacevim.org/install.sh</a> | bash -s – –uninstall</p><p>2021年06月16日09:10:40 vimproc_linux64.so未找到<br>命令模式执行:VimProcInstall</p><p>2020年03月23日15:03:43 每次打开文件时都显示<br>all databases has been cleared!<br>Press ENTER or type command to continue<br>这是因为cscope模块加载，删掉该模块</p><p>2019年10月23日16:53:23 vim中文件编码<br>查看文件编码：set fileencoding<br>设置文件编码：set fileencoding&#x3D;utf-8<br>查看换行格式：set fileformat?<br>设置换行格式：set fileformat&#x3D;unix</p><p>2019年10月28日14:26:00 自动折行 是把长的一行用多行显示 , 不在文件里加换行符用<br>:set wrap 设置自动折行<br>:set nowrap 设置不自动折行</p><p>2019年10月29日10:58:20 设置自动折行<br>vim ~&#x2F;.SpaceVim&#x2F;vimrc 添加一行<br>set wrap</p><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><p>查看进程精确的启动时间<br>ps -eo pid,lstart,etime,cmd</p><p>告警内容：监控看板：  <a href="https://insight.ke.com/d/HHM3WMO7k/yu-yin-zhi-liang-jian-kong?orgId=1">https://insight.ke.com/d/HHM3WMO7k/yu-yin-zhi-liang-jian-kong?orgId=1</a></p><p>查看僵尸进程：ps -A -ostat,ppid,pid,cmd | grep -e ‘^[Zz]’</p><p>2022年10月28日11:45:43  curl post上传文件</p><p>curl -X PUT -F “upload&#x3D;@bloom-7B.log” <a href="http://10.36.224.229:8080/tools/sample/put">http://10.36.224.229:8080/tools/sample/put</a></p><h2 id="kafkacat-kcat"><a href="#kafkacat-kcat" class="headerlink" title="kafkacat&#x2F;kcat"></a>kafkacat&#x2F;kcat</h2><p>源码构建安装<br>&#x2F;nfs&#x2F;v100-022&#x2F;niuqiang002&#x2F;bellaspace&#x2F;tools&#x2F;bin&#x2F;kcat -C -v -b ‘common-queue04-matrix.zeus.lianjia.com:9092,common-queue05-matrix.zeus.lianjia.com:9092,common-queue06-matrix.zeus.lianjia.com:9092,kafka116-online.zeus.ljnode.com:9092’ -t speech-asr-notify-msg -f ‘Topic %t [%p] at offset %o: key %k: #%s\n’ -o -1 -c 3</p><p>cat test_send.txt | kcat -P -v -b ‘kafka121-online.zeus.ljnode.com:9092,kafka122-online.zeus.ljnode.com:9092,kafka123-online.zeus.ljnode.com:9092,kafka124-online.zeus.ljnode.com:9092,kafka125-online.zeus.ljnode.com:9092’ -t bella_aistudio_log2fast</p><p>2018年1月26日14:39:43 Linux压缩文件：tar -zcvf 【压缩包名.tar.gz】 【源文件】</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>重命名命令 alias ll&#x3D;’ls -hal –color&#x3D;auto’</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态模型部署研发实战</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202304%E8%B4%9D%E5%A3%B3%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E4%B8%93%E9%A1%B9/202304%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202304%E8%B4%9D%E5%A3%B3%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E4%B8%93%E9%A1%B9/202304%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>需求是 <a href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/">大数据任务调度研发实战</a></p><p>这个需求同样涉及把相关的模型部署起来</p><h1 id="原始模型位置"><a href="#原始模型位置" class="headerlink" title="原始模型位置"></a>原始模型位置</h1><p>通过跟算法同学确认，首先统一放到nfs中</p><ol><li>申请堡垒机权限，登录<code>ssh niuqiang002@relay.ke.com</code>后选择10.232.1.211</li><li>登录后切换用户<code>sudo su</code></li><li>登录开发机<code>ssh 10.232.64.46</code></li><li>模型和demo暂时放在&#x2F;mnt&#x2F;cfs&#x2F;xyz-data-tj&#x2F;inference&#x2F;</li></ol><p>10.232.64.46用来训练了，按帅江指导，切换到10.201.102.13。堡垒机可以直接登录</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>因为模型部署之后，最终交付spark调用跑批任务，所以至少有两种部署方案：</p><ol><li><strong>无状态服务化部署，提供接口，每次处理一条</strong></li><li>同样是服务化部署，但是多条作为一个任务，一次同时处理多条，结果同时返回</li><li>同样是服务化部署，多条作为多个任务，多次返回或写入共享存储</li></ol><p>这里首先采用方案1。</p><ul><li>保持推理服务的简单无状态，方便后续使用其他推理框架直接替换</li><li>方案2优化了网络传输，但是需要支持队列，处理部分失败的情况，这部分工作可以在调度层做</li><li>方案3的离线交付方式本质同2</li></ul><p>受智能架构部的部署方案启发，可以尝试fastapi部署。所以无状态服务化部署同样有几种方案：</p><ol><li>使用原生torch.run</li><li>使用fastchat等成熟框架</li></ol><p>因为这个需求中产出的模式是mmpretrain框架训练得到的，目前除了转onnx或tensorrt使用triton部署外，没有更成熟高效的方式；而且是个多模态模型，处理的是图像数据，所以暂时使用原生torch.run的方式部署<br>而且看文档和应用，除llm外也无法使用fastchat</p><p>所以在这种情况下，也没必要像bella-api一样对部署框架做融合，只需要拉分支快速部署即可。也可以因此规避融合时的环境和版本问题</p><blockquote><p>所以最终方案是：</p><ol><li>每个模型对应一个分支。避免环境问题</li><li>模型直接做无状态服务化部署，提供接口，每次处理一条。方便中后期应用推理加速框架</li><li>使用原生torch.run，因为可能涉及到多种模态，并且有传统框架的模型</li></ol><p>架构简单清晰，易于升级或者扩展；多模型的框架融合可能会存在比较大的工作量，但是融合的诉求不是很强烈</p></blockquote><h1 id="中期工作规划"><a href="#中期工作规划" class="headerlink" title="中期工作规划"></a>中期工作规划</h1><ol><li>通过gitlab ci&#x2F;cd的方式，把模型更新到构建的过程自动化。核心卡点是开发机能否提供端口映射，使gitlab钩子可以访问</li><li>提高推理效率，使用triton部署传统torch模型</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型部署 </tag>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态模型部署研发实战</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202409%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202409%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="spark简介"><a href="#spark简介" class="headerlink" title="spark简介"></a>spark简介</h1><p>Apache Spark 是一种分布式处理系统，用于在大型数据集上执行大数据和机器学习任务。借助 Apache Spark，用户可以对 PB 级数据运行查询和机器学习工作流，这在本地设备上是无法做到的。</p><p>PySpark 是 Python 中 Apache Spark 的接口。使用 PySpark，您可以编写类似 Python 和类似 SQL 的命令，以在分布式处理环境中操作和分析数据</p><p>虽然也可以在像Hadoop这样的分布式系统上编写Python代码，但许多组织选择使用Spark并使用PySpark API，因为它速度更快，可以处理实时数据。使用 PySpark，您可以编写代码从不断更新的源中收集数据，而数据只能使用 Hadoop 以批处理模式进行。</p><p>并且，PySpark 提供容错能力，这意味着它能够在故障发生后恢复损失。该框架还具有内存计算功能，并存储在随机存取存储器 （RAM） 中。它可以在未安装硬盘驱动器或 SSD 的计算机上运行。</p><p>此外，Apache Flink 是一个分布式处理系统，它有一个叫做 PyFlink 的 Python API，在性能方面实际上比 Spark 快。但是，Apache Spark 已经存在了更长的时间，并且拥有更好的社区支持，这意味着它更可靠。</p><h1 id="quickstart"><a href="#quickstart" class="headerlink" title="quickstart"></a>quickstart</h1><p>步骤 1：创建 SparkSession<br>SparkSession 是 Spark 中所有功能的入口点，如果要在 PySpark 中生成数据帧，则需要 SparkSession。运行以下代码行以初始化 SparkSession：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spark = SparkSession.builder.appName(<span class="string">&quot;Datacamp Pyspark Tutorial&quot;</span>).config(<span class="string">&quot;spark.memory.offHeap.enabled&quot;</span>,<span class="string">&quot;true&quot;</span>).config(<span class="string">&quot;spark.memory.offHeap.size&quot;</span>,<span class="string">&quot;10g&quot;</span>).getOrCreate()</span><br></pre></td></tr></table></figure><p>使用上面的代码，我们构建了一个 spark 会话并为应用程序设置了一个名称。然后，将数据缓存在堆外内存中，以避免将其直接存储在磁盘上，并手动指定内存量。</p><p>步骤 2：创建 DataFrame<br>我们现在可以读取刚刚下载的数据集：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = spark.read.csv(<span class="string">&#x27;datacamp_ecommerce.csv&#x27;</span>,header=<span class="literal">True</span>,escape=<span class="string">&quot;\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者可以从sql中读取：</p><p>相关命令：看一下 dataframe 的前几行数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.show(<span class="number">5</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>第 3 步：探索性数据分析<br>现在我们已经看到了此数据集中存在的变量，让我们进行一些探索性数据分析以进一步了解这些数据点：</p><p>让我们先计算数据帧中的行数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.select(<span class="string">&#x27;CustomerID&#x27;</span>).distinct().count() <span class="comment"># Answer: 95</span></span><br></pre></td></tr></table></figure><p>使用groupby、orderby：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.types <span class="keyword">import</span> *</span><br><span class="line">df.groupBy(<span class="string">&#x27;Country&#x27;</span>).agg(countDistinct(<span class="string">&#x27;CustomerID&#x27;</span>).alias(<span class="string">&#x27;country_count&#x27;</span>)).show()</span><br><span class="line">df.groupBy(<span class="string">&#x27;Country&#x27;</span>).agg(countDistinct(<span class="string">&#x27;CustomerID&#x27;</span>).alias(<span class="string">&#x27;country_count&#x27;</span>)).orderBy(desc(<span class="string">&#x27;country_count&#x27;</span>)).show()</span><br></pre></td></tr></table></figure><p>最新购买时间，我们需要将InvoiceDate列转换为时间戳格式，并使用 Pyspark 中的 max（） 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spark.sql(<span class="string">&quot;set spark.sql.legacy.timeParserPolicy=LEGACY&quot;</span>)</span><br><span class="line">df = df.withColumn(<span class="string">&#x27;date&#x27;</span>,to_timestamp(<span class="string">&quot;InvoiceDate&quot;</span>, <span class="string">&#x27;yy/MM/dd HH:mm&#x27;</span>))</span><br><span class="line">df.select(<span class="built_in">max</span>(<span class="string">&quot;date&quot;</span>)).show()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spark-submit --master spark://3a25b9ea84a6:7077 \</span><br><span class="line">--name &quot;PythonWordCount&quot; \</span><br><span class="line">/opt/bitnami/spark/examples/src/main/python/wordcount.py /opt/bitnami/spark/examples/src/main/python/wordcount.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型部署 </tag>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建模方法与程序设计</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/uml/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/uml/</url>
      
        <content type="html"><![CDATA[<p>面向对象的核心是面向对象的设计，即把思维和重点转向现实中的客体中来，然后通过UML工具理清这些客体之间的联系。</p><hr><h1 id="UML是什么"><a href="#UML是什么" class="headerlink" title="UML是什么"></a>UML是什么</h1><p>1997年，OMG 组织（Object Management Group对象管理组织）发布了统一建模语言（Unified Modeling Language，UML）。UML 是一种编制软件蓝图的标准化语言，它的目标之一就是为开发团队提供标准通用的设计语言来开发和构建计算机应用。UML 提出了一套 IT 专业人员期待多年的统一的标准建模符号。<strong>通过使用UML，这些人员能够阅读和交流系统架构和设计规划。UML支持面向对象的技术，能够准确的方便地表达面向对象的概念，体现面向对象的分析和设计风格</strong>.</p><p>UML的模型主要有三部分构成：</p><ul><li>事物(Things)：UML模型中最基本的构成元素，是具有代表性的成分的抽象</li><li>关系(Relationships)：关系把事物紧密联系在一起</li><li>图(Diagrams )：图是事物和关系的可视化表示</li></ul><h1 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h1><p>我们在进行项目的时候，通过使用 UML 的面向对象图的方式来更明确、清晰的表达项目中的架设思想、项目结构、执行顺序等一些逻辑思维。 </p><p>UML 特点：</p><ul><li>面向对象</li><li>可视化，表达能力强</li><li>独立于过程</li><li>独立于程序设计</li><li>容易掌握使用</li></ul><h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p>在 UML 2.2 版本的规范中，将 UML 图分为了三大类、共 14 种类型：</p><p>①结构性图形</p><ol><li><strong>静态图（包括类图、对象图、包图）</strong>：类图是最常用的 UML 图，它描述了系统中类的静态结构，包括类的属性和方法以及类之间的关系。对象图则描述了系统中对象的实例以及它们之间的关系。包图描述了系统的模块结构，以及模块之间的依赖关系。</li><li><strong>实现图（包括组件图、部署图）</strong>：组件图用于描述系统的物理结构，包括系统的软件组件以及它们之间的关系。部署图描述了系统的硬件结构，包括系统的节点以及它们之间的通信关系。</li><li>剖面图：剖面图用于描述系统的内部视图。</li><li>复合结构图：复合结构图则用于描述复杂结构的内部组织。</li></ol><p>②行为式图形</p><ol><li>活动图：活动图描述了系统的动态行为，包括系统的业务流程以及流程之间的控制和数据流关系。</li><li><strong>状态图</strong>：状态图描述了系统中对象的生命周期，包括对象的状态以及状态之间的转移条件。</li><li>用例图：用例图描述了系统的功能需求，包括系统的参与者、用例以及它们之间的交互关系。</li></ol><p>③交互性图形</p><ol><li>通信图：通信图描述了系统中对象之间的交互，包括对象之间的消息传递顺序。</li><li>交互概述图：交互概述图是用于描述多个交互图之间的关系。</li><li><strong>时序图</strong>：时序图描述了系统中对象之间的交互，强调交互发生的时间顺序。</li><li>时间图：时间图描述了系统中的事件或者状态在时间轴上的分布。</li></ol><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责。在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。类的属性即类的数据职责，类的操作即类的行为职责。设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。<br>在软件系统运行时，类将被实例化成对象(Object)，对象对应于某个具体的事物，是类的实例(Instance)。</p><p>类图(Class Diagram)使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。</p><h2 id="一、类的表示方式"><a href="#一、类的表示方式" class="headerlink" title="一、类的表示方式"></a>一、类的表示方式</h2><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示</p><p>UML类图中表示可见性的符号有三种：</p><ol><li><ul><li>：表示public</li></ul></li><li><ul><li>：表示private</li></ul></li><li>#：表示protected（friendly也归入这类）</li></ol><p>属性的完整表示方式是这样的：</p><blockquote><p>可见性  名称 ：类型 [ &#x3D; 缺省值]</p></blockquote><p>方法的完整表示方式如下：</p><blockquote><p>可见性  名称(参数列表) [ ： 返回类型]</p></blockquote><h2 id="三、类与类之间关系的表示方式"><a href="#三、类与类之间关系的表示方式" class="headerlink" title="三、类与类之间关系的表示方式"></a>三、类与类之间关系的表示方式</h2><h3 id="1、关联关系"><a href="#1、关联关系" class="headerlink" title="1、关联关系"></a>1、关联关系</h3><p>关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等等。在UML类图中，用实线连接有关联关系的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，<strong>通常将一个类的对象作为另一个类的成员变量。</strong><br>关联关系又可进一步分为单向关联、双向关联和自关联。</p><pre><code>  1. 单向关联  2. 双向关联        所谓的双向关联就是双方各自持有对方类型的成员变量。  3. 自关联        自关联在UML类图中用一个带有箭头且指向自身的直线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</code></pre><p>多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。</p><h3 id="2、聚合关系"><a href="#2、聚合关系" class="headerlink" title="2、聚合关系"></a>2、聚合关系</h3><p>UML中聚合关系用带空心菱形和箭头的直线表示。聚合关系强调是“整体”包含“部分”，但是“部分”可以脱离“整体”而单独存在。<br><strong>成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中</strong></p><h3 id="3、组合关系"><a href="#3、组合关系" class="headerlink" title="3、组合关系"></a>3、组合关系</h3><p><strong>组合关系与聚合关系最大不同在于：这里的“部分”脱离了“整体”便不复存在</strong>。在UML类图中，组合关系用一个带实心菱形和箭头的直线表示。<br>组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，<strong>一旦整体对象不存在，成员对象也将不存在，但是删除个体，不影响整体的存在。</strong></p><h3 id="4、依赖关系"><a href="#4、依赖关系" class="headerlink" title="4、依赖关系"></a>4、依赖关系</h3><p>Driver的drive方法只有传入了一个Car对象才能发挥作用，因此我们说Driver类依赖于Car类。在UML类图中，依赖关系用一条带有箭头的虚线表示。依赖(Dependency)关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。<br>依赖关系通常通过三种方式来实现，第一种也是最常用的一种方式是如图1所示的<strong>将一个类的对象作为另一个类中方法的参数，第二种方式是在一个类的方法中将另一个类的对象作为其局部变量，第三种方式是在一个类的方法中调用另一个类的静态方法</strong>。</p><h3 id="5、继承关系"><a href="#5、继承关系" class="headerlink" title="5、继承关系"></a>5、继承关系</h3><p>继承关系对应的是extend关键字，在UML类图中用带空心三角形的直线表示</p><h3 id="6、接口实现关系"><a href="#6、接口实现关系" class="headerlink" title="6、接口实现关系"></a>6、接口实现关系</h3><p>这种关系对应implement关键字，在UML类图中用带空心三角形的虚线表示</p><h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><p>我们在画时序图时会涉及下面7种元素：</p><ol><li><p>角色(Actor)</p><pre><code> 系统角色，可以是人或者其他系统和子系统。以一个小人图标表示。</code></pre></li><li><p>对象(Object)</p><pre><code> 对象位于时序图的顶部,以一个矩形表示</code></pre></li><li><p>生命线(LifeLine)</p><pre><code> 时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表。</code></pre></li><li><p>控制焦点(Activation)</p><pre><code> 控制焦点代表时序图中在对象时间线上某段时期执行的操作。以一个很窄的矩形表示。</code></pre></li><li><p>消息(Message)</p><pre><code> 表示对象之间发送的信息。消息分为三种类型。  1. 同步消息(Synchronous Message) 消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线和实心箭头表示。 2. 异步消息(Asynchronous Message) 消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线和大于号表示。 3. 返回消息(Return Message) 返回消息表示从过程调用返回。以小于号和虚线表示。</code></pre></li><li><p>自关联消息</p><pre><code> 表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</code></pre></li><li><p>组合片段。</p><pre><code> 组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下： 组合名称组合含义 ref引用其他地方定义的组合片段 alt在一组行为中根据特定的条件选择某个交互 opt表示一个可选的行为 break提供了和编程语言中的break类拟的机制 par支持交互片段的并发执行 seq强迫交互按照特定的顺序执行 strict明确定义了一组交互片段的执行顺序 neg用来标志不应该发生的交互 region标志在组合片段中先于其他交互片断发生的交互 ignore明确定义了交互片段不应该响应的消息 consider明确标志了应该被处理的消息 assert标志了在交互片段中作为事件唯一的合法继续者的操作数 loop说明交互片段会被重复执行</code></pre></li></ol><h1 id="C4Model"><a href="#C4Model" class="headerlink" title="C4Model"></a>C4Model</h1><p>为了构建实际系统的抽象。C4 Model对于系统的描述提供了四个抽象层次：</p><ol><li>Software System：软件系统最高的抽象层次，描述了交付给用户完成用户所需功能的系统。</li><li>Person：使用系统的人或者角色</li><li>Container：容器是独立运行一些代码和数据，组合起来完成系统功能的要素。一个容器可以是Server-side web application、Client-side web application、Client-side desktop application、Mobile app、Server-side console application、Microservice、Database、Blob or content store、File system、Shell script等。</li><li>Component：组件一组相关功能的封装，对外提供良好的接口。</li></ol><p>基于这四个层次的抽象，C4 Model由4张核心图和3张附加图组成。</p><p>4张核心图分别为系统上下文图（Context）、容器图（Container）、组件图（Component）、代码图（Code），代码图是实际的类实现，可选。</p><h2 id="系统上下文图-（所以我们需要景观图，而不是上下文图）"><a href="#系统上下文图-（所以我们需要景观图，而不是上下文图）" class="headerlink" title="系统上下文图 （所以我们需要景观图，而不是上下文图）"></a>系统上下文图 （所以我们需要景观图，而不是上下文图）</h2><p>系统上下文图主要表述的是<strong>当前要开发的系统和周边环境的关系</strong>，包括系统和用户之间的关系和系统和周边系统的关系，在系统上下文图里，方块指代的是软件系统，蓝色表示我们关注的系统（位于中心），灰色表示我们直接依赖的系统或者依赖我们的系统，虚线框一般用于用于聚合相关元素。</p><h2 id="容器图"><a href="#容器图" class="headerlink" title="容器图"></a>容器图</h2><p>当我们理解了当前关注的系统在整个IT环境中的地位的时候，需要将当前系统放大，观察里面的内部结构，放大后就会看到容器，如上图所示，C4模型认为系统是由容器组成的。<strong>容器图显示的是软件架构中各个独立的部分（一般是一个独立的进程）</strong>，每个容器的职责和他们间是如何交互的，以及容器与其他系统是如何交互的。它显示了当前软件系统的技术选型和交互方式。它是一个简单的、以高级技术为重点的图表，对软件开发人员和支持&#x2F;操作人员都很有用</p><h2 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h2><p>继续放大容器，可以看到每个容器里有哪些组件组成，组件的职责是什么，组件是如何交互的。组件主要是相关功能的聚合，提供对外的接口</p><h2 id="代码图-（即UML的类图）"><a href="#代码图-（即UML的类图）" class="headerlink" title="代码图 （即UML的类图）"></a>代码图 （即UML的类图）</h2><p>代码图跟UML里面的类图很类似。除非非常重要的且还没有写出代码的组件才画代码图。<br>核心图主要固定了我们系统的抽象层次，方便讨论和理解。</p><hr><p>三张扩展图<br>核心图让我理解了系统静态架构，三张扩展图，可以让我们关注更多的维度。</p><h2 id="系统景观图-（即UML的静态图）"><a href="#系统景观图-（即UML的静态图）" class="headerlink" title="系统景观图 （即UML的静态图）"></a>系统景观图 （即UML的静态图）</h2><p><strong>比系统上下文图更丰富的系统级别的表达</strong>。不像上下文图只关注聚焦系统和它的直接关系，连一些间接相关的系统都会标示出来，包括那些外部系统相关的用户。系统景观图的意义在于从企业的整个IT架构来看待当前要构建的系统的功能和价值。</p><h2 id="动态图-（即UML的时序图）"><a href="#动态图-（即UML的时序图）" class="headerlink" title="动态图 （即UML的时序图）"></a>动态图 （即UML的时序图）</h2><p>不同于上面所有静态图的表达，它表达的系统的某个运行态，这个运行态中完成了一个用户的场景或者功能。所以一般有步骤，有顺序。而且可以在各个层级去描述这个动态图。</p><h2 id="部署图（通常忽略）"><a href="#部署图（通常忽略）" class="headerlink" title="部署图（通常忽略）"></a>部署图（通常忽略）</h2><p>部署图主要描述系统在容器级别是如何实际部署到物理基础设施中的。</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ol><li>starUML超级卡顿，导出的图片是背景无填充的。但是确实线条清晰，UML工具较完备且分类良好</li><li>drawio。常用工具，但是对UML设计来说可能需要自行调整字体、对齐等。优势是可以一个文件多个子项目</li><li>plantuml。编辑方便，但是注意导出生成代码的工具并不好用。plantcode puml2code这两个开源库都puml的格式都严格限制，但是能够提供的功能十分有限，前者多少还能用，后者安装都失败</li></ol><p>2024年06月27日09:18:15 不要使用starUML。</p><ol><li>超级卡顿</li><li>类图一多，导出图片或生成java代码的时候直接卡死</li><li>手动编辑可视化界面，效率远远不如直接使用plantUML编辑markdown</li></ol><p>2024-09-23 15:04:17 <strong>uml类图如果不能直接生成代码，那最终也无非只是一种沟通工具。建议使用drawio代替plantuml</strong></p><ol><li>drawio所见即所得，可以很方便的组织位置和样式，使整体更直观。基于纯文本的plantuml调整位置相对困难</li><li>drawio也是标记语言，存储并不特别劣势</li><li>drawio可以用一套语言，很轻松的迁移画出多种用途的图表</li></ol><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2018年4月8日11:28:52 学习UML类图</p><blockquote><p>没有要求的时候不做类图了，本身与代码无异又浪费时间。除非用于立项沟通</p></blockquote><blockquote><p>2024年06月17日09:31:45 这种想法是不对的。UML帮助自己厘清关系，做好设计，总好过后期一直在代码的基础上删删改改，工作量非常大</p></blockquote><p>2022年02月08日14:26:42 学习C4models；学习astah；写设计文档。</p><ul><li>学习C4models <a href="https://blog.csdn.net/qianshangding0708/article/details/100571692">https://blog.csdn.net/qianshangding0708/article/details/100571692</a></li><li>学习astah <a href="https://astah.net/">https://astah.net/</a></li></ul><p>2024年06月14日17:20:50 学习UML的基本构成 <a href="https://www.cnblogs.com/shindo/p/5579191.html">五分钟读懂UML类图</a></p><p>2024年06月14日17:23:11 是五分钟读懂UML的扩展 <a href="https://blog.csdn.net/smilejiasmile/article/details/113943361">深入浅出UML类图</a></p><p>2024年06月17日09:30:12 可以看出C4Model是UML的特例 <a href="https://blog.csdn.net/qianshangding0708/article/details/100571692">作为架构师你应该知道 - C4 model</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> uml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSpring研发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/202409JavaSpring%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/202409JavaSpring%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>(@Component, @Repository, @Service的区别)[<a href="https://blog.csdn.net/fansili/article/details/78740877]">https://blog.csdn.net/fansili/article/details/78740877]</a></p><p>@Component, @Service, @Controller, @Repository是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理<br><strong>@Component是通用注解</strong>，其他三个注解是这个注解的拓展，并且具有了特定的功能<br>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。<br>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。<br><strong>@Service层是业务逻辑层注解</strong>，这个注解只是标注该类处于业务逻辑层。  </p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> 分布式服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程机制深度剖析</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/202409Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/202409Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="三种方法的区别"><a href="#三种方法的区别" class="headerlink" title="三种方法的区别"></a>三种方法的区别</h1><p>Thread 类、Runnable 接口和线程池是 Java 中实现多线程的三种常见方式，它们各自有不同的特点和使用场景。</p><p> 1、Thread 类：</p><pre><code>     Thread 类是 Java 中的一个内置类，使用 Thread 类实现多线程时，需要继承 Thread 类并重写其 run() 方法，然后创建 Thread 对象并调用其 start() 方法启动线程。这种方式可以实现多线程，但是每个线程都需要创建一个独立的对象，如果线程数量很大，会占用大量的内存空间。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 线程执行的代码逻辑  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">// 创建线程对象  </span></span><br><span class="line">        myThread.start(); <span class="comment">// 启动线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Runnable 接口：</p><pre><code>    Runnable 接口是 Java 中定义的一个接口，它只有一个 run() 方法，用于定义线程执行的代码逻辑。使用 Runnable 接口实现多线程时，需要实现 Runnable 接口并重写其 run() 方法，然后创建一个 Thread 对象并将 Runnable 对象作为参数传递给 Thread 的构造函数，最后调用 Thread 的 start() 方法启动线程。这种方式相比继承 Thread 类更加灵活，因为多个线程可以共享同一个 Runnable 对象，可以节省内存空间。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 线程执行的代码逻辑  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()); <span class="comment">// 创建线程对象并传入Runnable对象  </span></span><br><span class="line">        thread.start(); <span class="comment">// 启动线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、线程池</p><pre><code>    线程池是一种更加高效的多线程实现方式。它通过预先创建一定数量的线程并保存在内存中，避免了频繁地创建和销毁线程对象，提高了线程的复用性。使用线程池实现多线程时，需要创建一个 ExecutorService 对象（可以通过 Executors 类创建），然后调用其 submit() 或 execute() 方法提交任务给线程池执行。这种方式可以更加高效地利用系统资源，减少线程的创建和销毁开销。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 创建一个固定大小的线程池  </span></span><br><span class="line">        executorService.submit(() -&gt; &#123; <span class="comment">// 提交任务到线程池中执行  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task is running on thread &quot;</span> + Thread.currentThread().getName());  </span><br><span class="line">        &#125;);  </span><br><span class="line">        executorService.shutdown(); <span class="comment">// 关闭线程池  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池生命周期管理"><a href="#线程池生命周期管理" class="headerlink" title="线程池生命周期管理"></a>线程池生命周期管理</h1><p>1、任务提交：当任务被提交到线程池时，线程池会首先检查当前是否有可用的线程。如果有，则将任务分派给该线程执行；如果没有，则根据线程池的设置来处理该任务。</p><p>2、判断核心线程数：线程池会判断当前的核心线程数是否已满。如果没有满，则创建一个新的核心线程去执行任务。如果已满，则进入下一个流程。</p><p>3、判断工作队列：如果工作队列未满，则将新提交的任务存储在工作队列里。如果工作队列已满，则进入下一个流程。</p><p>4、判断整个线程池：如果线程池里面的存活线程数已经等于核心线程数，且工作队列已经满了，再会去判断当前线程数是否已经达到最大线程数。如果没有达到，则会创建一个新的非核心线程去执行任务；如果已经达到，则交给饱和策略来处理这个任务。</p><p>5、饱和策略：当队列和线程池都满了的时候，再有新的任务到达，就必须要有一种办法来处理新来的任务。拒绝策略在此时发挥作用。具体的策略包括丢弃任务、抛出异常或阻塞当前任务等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MacBook上开发Linux Java</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/</url>
      
        <content type="html"><![CDATA[<h1 id="在MacBook上使用IDEA远程开发LINUX-JAVA"><a href="#在MacBook上使用IDEA远程开发LINUX-JAVA" class="headerlink" title="在MacBook上使用IDEA远程开发LINUX JAVA"></a>在MacBook上使用IDEA远程开发LINUX JAVA</h1><h2 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h2><ol><li>本地编译非常容易遇到环境问题，经常遇到一个依赖包调半天的尴尬情况，强烈建议使用docker开发，从0开始构建镜像，源码编译，避免依赖问题</li><li>本项目使用了外部提供的webrtc sdk，只有linux版本，没有mac版本，所以只能远程开发</li><li>本机处理能力不强。我的笔记本启动容器或虚拟机非常容易卡顿，其他什么事都干不了</li><li>纯远程开发成本较高。基于vim编辑器组装IDE代价较大，而且很难标准化，代码和IDE维护的成本都比较高</li><li>IDEA版本更新很快，网上的教程基本上都过时了</li></ol><p>所以经过一段时间的调研和实践，这里推荐 【 开发机IDEA + 远程ssh 】进行主力研发。</p><hr><h2 id="1-开发机安装IDEA"><a href="#1-开发机安装IDEA" class="headerlink" title="1. 开发机安装IDEA"></a>1. 开发机安装IDEA</h2><p>下载安装IntelliJ IDEA， 不再赘述。</p><blockquote><p><strong>建议使用Ultimate版本，因为Community版本不支持运行到远程</strong></p></blockquote><p>安装插件Docker。Ultimate版本默认安装</p><p>特别注意，<strong>Linux的SDK不能在Apple芯片上运行</strong>，即使在容器环境中！所以只能使用远程主机或容器</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/so_cannot_runon_macdocker.png" class=""><h2 id="2-申请远程主机"><a href="#2-申请远程主机" class="headerlink" title="2. 申请远程主机"></a>2. 申请远程主机</h2><p>远程主机至少需要有以下能力：</p><ol><li>可以笔记本直接连接</li><li>可以连接外网安装依赖包</li><li>可以ssh登录或者使用docker context</li></ol><p>目前壳内能用的远程开发机可能是aistudio提供的ubuntu20.04</p><ol><li><p>在aistudio新建项目 <a href="https://aistudio.ke.com/#/project/list">https://aistudio.ke.com/#/project/list</a> <img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/new_project_on_aistudio.png" class=""></p><ol><li>这些选项都无所谓，因为即不用GPU，又不用它的ssh</li></ol></li><li><p>启动时选择纯CPU即可 <img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/start_project_on_aistudio.png" class=""></p></li><li><p>提前在主机上或容器中完成SSH相关配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器</span></span><br><span class="line">docker run -idt --cap-add sys_ptrace --security-opt seccomp=unconfined -v /etc/localtime:/etc/localtime -v /Users/niuqiang/dockerspace:/home -p 8086:8080 -p 8022:22 --name niuqiang_devtest_ubuntu2204 ubuntu:22.04</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装java环境</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get upgrade -y</span><br><span class="line">apt autoremove -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用apt安装java11</span></span><br><span class="line">sudo apt install openjdk-11-jdk -y</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用sdkman安装。但是速度可能比较慢</span></span><br><span class="line">apt-get install curl zip unzip</span><br><span class="line">curl -s &quot;https://get.sdkman.io&quot; | bash</span><br><span class="line">source &quot;/root/.sdkman/bin/sdkman-init.sh&quot;</span><br><span class="line">sdk list java</span><br><span class="line">sdk install java 11.0.24-amzn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install openssh-server</span><br><span class="line">apt-get install vim</span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Port 22</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PermitRootLogin <span class="built_in">yes</span></span></span><br><span class="line">/etc/init.d/ssh restart</span><br><span class="line"></span><br><span class="line">apt-get install net-tools</span><br><span class="line">apt-get install rsync</span><br><span class="line"></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line">which java</span><br></pre></td></tr></table></figure><h2 id="3-开发机使用远程"><a href="#3-开发机使用远程" class="headerlink" title="3. 开发机使用远程"></a>3. 开发机使用远程</h2><ol><li>打开项目的启动配置，选择Run on SSH (Community版本没有这个选项)<img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/dev_java_on_docker/idea_run_on_remote.png" class=""></li></ol><p>完成！</p><h2 id="4-使用小技巧"><a href="#4-使用小技巧" class="headerlink" title="4. 使用小技巧"></a>4. 使用小技巧</h2><ol><li>run和rerun经常遇到卡死的问题，这时候只能手动登录主机，杀死相关java进程，再在IDEA中run</li><li>依赖的Linux SDK最好放到项目目录以外的位置，启动时手动设置LD_LIBRARY_PATH</li><li>aistudio的机器最多保留7天，所以依赖尽量不要搞太复杂</li></ol><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>IDEA + ssh也不是万能的，可能会有各种各样不得不妥协的场景，这里只是给出一个干活儿更高效的方式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Docker </tag>
            
            <tag> 工作环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python开发环境与工具</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/202409%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/202409%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Docker </tag>
            
            <tag> 工作环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习模型部署实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>因为PE平台的智能体和workflow概念已经是业界通行语言，所以如果有智能能力，尽量采用可以在pe平台上线的方式。</p><p>agent的主体必须是大语言模型，所以语音和图像相关的能力需要以http调用的方式对接到workflow。</p><p>而workflow的变量限制文本和段落类型的最大长度，即使从32768扩展到100k级别，仍然不能处理图像和音频数据。</p><p>所以在workflow和模型能力之间需要有一个转接层，用于数据的下载和处理。此外还有以下优势</p><ol><li>增强了干预能力，如果需要对能力做pipeline，这可能是一种比较方便的方式</li><li>可以增加基本的服务可用性保障，如监控、排队等</li></ol><h1 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h1><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>王静提交的mmpretrain可以使用torchserve部署，但是官方没有明确给出性能或易用性等优势，所以暂时不关注，暂时统一使用torchrun方式 </p><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h1 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h1><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h1>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 部署 </tag>
            
            <tag> 大模型与多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件系统设计文档模版</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202408%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202408%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h1><h2 id="现状分析"><a href="#现状分析" class="headerlink" title="现状分析"></a>现状分析</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目背景描述清晰</p><h2 id="竞品调研"><a href="#竞品调研" class="headerlink" title="竞品调研"></a>竞品调研</h2><h1 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h1><p>B点画面</p><h2 id="项目价值"><a href="#项目价值" class="headerlink" title="项目价值"></a>项目价值</h2><p>核心需求分析透彻</p><h2 id="项目范围"><a href="#项目范围" class="headerlink" title="项目范围"></a>项目范围</h2><p>设计目标清晰明确</p><h2 id="关键能力及指标"><a href="#关键能力及指标" class="headerlink" title="关键能力及指标"></a>关键能力及指标</h2><h2 id="重难点问题"><a href="#重难点问题" class="headerlink" title="重难点问题"></a>重难点问题</h2><h2 id="OKR"><a href="#OKR" class="headerlink" title="OKR"></a>OKR</h2><h2 id="达成路径分析"><a href="#达成路径分析" class="headerlink" title="达成路径分析"></a>达成路径分析</h2><p>分析问题全面</p><h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>明确面向的客户，产品的特点</p><h2 id="产品优势"><a href="#产品优势" class="headerlink" title="产品优势"></a>产品优势</h2><h2 id="产品功能"><a href="#产品功能" class="headerlink" title="产品功能"></a>产品功能</h2><p>核心功能图文展示</p><h1 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h1><h1 id="项目方案"><a href="#项目方案" class="headerlink" title="项目方案"></a>项目方案</h1><h2 id="视觉设计"><a href="#视觉设计" class="headerlink" title="视觉设计"></a>视觉设计</h2><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>各系统功能概述。解决方案考虑周全：</p><ul><li>考虑多租户（复用）问题；白名单问题；</li></ul><h2 id="交互用例"><a href="#交互用例" class="headerlink" title="交互用例"></a>交互用例</h2><h2 id="数据泳道"><a href="#数据泳道" class="headerlink" title="数据泳道"></a>数据泳道</h2><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h3 id="依赖接口"><a href="#依赖接口" class="headerlink" title="依赖接口"></a>依赖接口</h3><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><h3 id="数据表定义"><a href="#数据表定义" class="headerlink" title="数据表定义"></a>数据表定义</h3><h3 id="限制约束"><a href="#限制约束" class="headerlink" title="限制约束"></a>限制约束</h3><h2 id="需求推演"><a href="#需求推演" class="headerlink" title="需求推演"></a>需求推演</h2><p>提供可扩展空间</p><h1 id="可用性保障"><a href="#可用性保障" class="headerlink" title="可用性保障"></a>可用性保障</h1><h2 id="加强感知"><a href="#加强感知" class="headerlink" title="加强感知"></a>加强感知</h2><h2 id="及时止损"><a href="#及时止损" class="headerlink" title="及时止损"></a>及时止损</h2><h2 id="日常跟进"><a href="#日常跟进" class="headerlink" title="日常跟进"></a>日常跟进</h2><h1 id="下一步行动"><a href="#下一步行动" class="headerlink" title="下一步行动"></a>下一步行动</h1><h2 id="步骤拆解-优先级-排期"><a href="#步骤拆解-优先级-排期" class="headerlink" title="步骤拆解 &amp; 优先级 &amp;排期"></a>步骤拆解 &amp; 优先级 &amp;排期</h2><h2 id="milestone与达成效果"><a href="#milestone与达成效果" class="headerlink" title="milestone与达成效果"></a>milestone与达成效果</h2><h2 id="验收方案"><a href="#验收方案" class="headerlink" title="验收方案"></a>验收方案</h2><p>2022年01月31日09:27:30 需要考虑如何同时支持生产环境和测试环境<br>2024年04月17日18:28:22 需要支持从各个角度验收交付物，最起码需要有测试环境</p><h2 id="风险预案"><a href="#风险预案" class="headerlink" title="风险预案"></a>风险预案</h2><h2 id="进展追踪"><a href="#进展追踪" class="headerlink" title="进展追踪"></a>进展追踪</h2><p>下一步工作计划</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本管理工具使用实战(Git)</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%88%98(Git)/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%B7%A5%E5%85%B7/202409%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%88%98(Git)/</url>
      
        <content type="html"><![CDATA[<p>2018年1月26日09:32:02</p><p>来源：Git教程-廖雪峰</p><p>Git是目前世界上最先进的分布式版本控制系统，而SVN是目前用得最多的集中式版本库控制系统。<br>集中式版本控制系统，版本库是集中存放在中央服务器的，而分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，但通常也会有一台“中央服务器”用于交换diff 。</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库。这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所有的版本控制系统，其实只能跟踪文本文件的改动。二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化</p><p>选择一个合适的地方，创建一个空目录（也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的）<br>通过git init命令把这个目录变成Git可以管理的仓库  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> learngit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> learngit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/Users/michael/learngit</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>放入或变动文件</p><p>git add readme.txt 把文件添加到仓库</p><p>git reset xxx 从提交区撤销刚刚添加的更改的文件</p><p>git commit -m “wrote a readme file” 把文件提交到仓库</p><p>git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支</p><p>git status 可以让我们时刻掌握仓库当前的状态<br>git diff 查看difference，显示的格式正是Unix通用的diff格式<br>没有变更的时候使用则没有效果<br>TODO 详解通用diff格式<br>提交修改和提交新文件是一样的两步：git add + git commit</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支<br>每次修改，如果不add到暂存区，那就不会加入到commit中</p><p>git log命令显示从最近到最远的提交日志</p><p>commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示在Git中，用HEAD表示当前版本，也就是最新的提交。上一个版本是head~1回退到上一个版本，可以使用git reset命令</p><p>git reflog 查看命令历史，与历次修改时受影响的commit id.</p><p>git checkout – readme.txt 让这个文件回到最近一次git commit或git add时的状态<br>git reset HEAD readme 把暂存区的修改撤销掉<br>2018年1月30日08:37:35</p><p>git rm test.txt 提交删除到暂存区<br>恢复分两种情况: commit了，这时要reset这个文件的HEAD为head~1，然后checkout<br>没有commit，直接reset这个文件的HEAD为HEAD，然后checkout<br>使用GitHub作为远程仓库</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br>ssh-keygen -t rsa -C “<a href="mailto:&#121;&#111;&#117;&#114;&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;">&#121;&#111;&#117;&#114;&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d;</a>“</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容<br>第3步：登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库<br>第4步：把本地仓库与之关联 TODO 如何取消关联<br>git remote add origin <a href="https://github.com/ishitbugs/CmakeEx.git">https://github.com/ishitbugs/CmakeEx.git</a></p><p>第5步：把本地库的所有内容推送到远程库上<br>git push -u origin master</p><p>第6步：使用。只要本地作了提交，就可以把本地master分支的最新修改推送至GitHub<br>git push origin master</p><p>第7步：协作。克隆得到一个本地库，并且修改尝试提交。</p><p>git clone <a href="https://github.com/ishitbugs/learngit.git">https://github.com/ishitbugs/learngit.git</a><br>some modify…<br>git add &amp; git rm &amp; so<br>git commit<br>git push origin master<br>只有通过ssh-key或账号验证的用户才能够成功提交</p><p>2018年1月30日09:38:19 origin是远程库的名字，这是Git默认的叫法，也可以改成别的</p><p>分支管理<br>git branch -a 查看所有本地或远程分支</p><p>git branch <name> &lt;origin&#x2F;name&gt; 由远程分支创建本地分支并绑定</p><p>git checkout <name> 切换分支</p><p>git merge –no-ff -m “merge with no-ff” <name> 合并某分支到当前分支。</p><p>只能将更新的分支合并到未更新分支</p><p>解决冲突</p><p>vim conflicting files<br>git add conflicting files<br>git commit (current branch)<br>git branch -d <name> 删除分支</p><p>git branch -D <name> 强行删除分支</p><p>强行删除的分支仍然能够通过git reflog找到</p><p>多人协作<br>当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin</p><p>使用 git remote -v 查看远程仓库信息<br>git push origin master 推送指定分支到指定远程仓库，该指定分支必须已与远程分支绑定<br>首先，可以试图用git push origin branch-name推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>git pull <remote repo> <branch></p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin&#x2F;branch-name。</p><p>######标签管理<br>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起</p><p>git tag -a tagname (commit id) -m message 默认为HEAD<br>git tag 查看所有标签<br>git show tagname 查看标签详细信息<br>git push origin <tagname> 推送某个标签到远程<br>git push origin –tags 一次性推送全部尚未推送到远程的本地标签<br>删除标签</p><p>git tag -d tagname 先从本地删除<br>git push origin :refs&#x2F;tags&#x2F;tagname 然后从远程删除</p><h2 id="与远程同步fork"><a href="#与远程同步fork" class="headerlink" title="与远程同步fork"></a>与远程同步fork</h2><p>Configuring a remote for a fork<br>给 fork 配置一个 remote<br>使用 git remote -v 查看远程状态。<br>git remote -v</p><p>添加一个将被同步给 fork 远程的上游仓库<br>git remote add upstream <a href="https://github.com/Qihoo360/QConf.git">https://github.com/Qihoo360/QConf.git</a></p><p>再次查看状态确认是否配置成功。<br>git remote -v</p><p>Syncing a fork<br>从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream&#x2F;master<br>git fetch upstream</p><p>切换到本地主分支(如果不在的话)<br>git checkout master</p><p>把 upstream&#x2F;master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。<br>git merge upstream&#x2F;master<br>git merge upstream&#x2F;master</p><p>如果想更新到 GitHub 的 fork 上，直接 git push origin master 就好了。</p><h2 id="使用远程库"><a href="#使用远程库" class="headerlink" title="使用远程库"></a>使用远程库</h2><p>第一步，安装git<br>sudo apt-get install git</p><p>第二步，创建一个git用户，用来运行git服务(可略过，该用户可ssh登陆即可)<br>sudo adduser git</p><p>第三步，创建证书登录<br>收集所有需要登录的用户的公钥，就是他们的id_rsa.pub文件，把所有公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件(如果没有则新建)里，一行一个。</p><p>第四步，初始化Git仓库<br>先选定一个目录作为Git仓库，假定是&#x2F;srv&#x2F;sample.git，在&#x2F;srv目录下输入命令： sudo git init –bare sample.git</p><p>裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。</p><p>然后，把owner改为git(如果未进行第二步，则省略)<br>sudo chown -R git:git sample.git</p><p>第五步，禁用shell登录(如果未进行第二步，则省略)<br>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑&#x2F;etc&#x2F;passwd文件完成。找到该用户所在行，改为：<br>git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</p><p>第六步，克隆远程仓库</p><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><p>git clone ssh:&#x2F;&#x2F;<a href="mailto:&#x6e;&#x69;&#117;&#113;&#x69;&#97;&#x6e;&#103;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#49;&#x30;&#x2e;&#x32;&#48;&#x39;">&#x6e;&#x69;&#117;&#113;&#x69;&#97;&#x6e;&#103;&#64;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#56;&#x2e;&#49;&#x30;&#x2e;&#x32;&#48;&#x39;</a>:20022&#x2F;home&#x2F;niuqiang&#x2F;sample.git</p><p>或者</p><p>git clone ssh:&#x2F;&#x2F;192.168.10.209:20022&#x2F;home&#x2F;niuqiang&#x2F;sample.git</p><p>或者</p><p>git clone ssh:&#x2F;&#x2F;<a href="mailto:&#110;&#105;&#x75;&#113;&#105;&#x61;&#x6e;&#103;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#49;&#48;&#x2e;&#x32;&#x30;&#x39;">&#110;&#105;&#x75;&#113;&#105;&#x61;&#x6e;&#103;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#49;&#48;&#x2e;&#x32;&#x30;&#x39;</a>&#x2F;home&#x2F;niuqiang&#x2F;sample.git</p><p>或者</p><p>git clone ssh:&#x2F;&#x2F;192.168.10.209&#x2F;home&#x2F;niuqiang&#x2F;sample.git ☆</p><p>为了支持端口不在22的ssh协议登陆，可能还需要在.ssh&#x2F;cofig中指定端口</p><p>可能仓库端需要安装openssl-server</p><p>在客户端正常使用和推送。</p><h2 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h2><p>VSS、CVS、SVN和ClearCase等配置工具的评估和比较<br>1<br>概述</p><p>Visual SourceSafe：微软的版本控制工具，仅支持Windows操作系统。虽然简单好用，但是仅适用于团队级开发，不能胜任企业级的开发工作。</p><p>Clearcase：IBM旗下Rational公司(2003年被IBM收购)的一款重量级的软件配置管理(SCM， SoftwareConfiguration Managemen)工具。与CVS和VSS不同，Clearcase涵盖的范围包括版本控制、建立管理、工作空间管理和过程控制。从最初的软件配置计划，到配置项的确立，从变更控制到版本控制，Clearcase贯穿于整个软件生命周期。 Clearcase支持现有的绝大多数操作系统，但它的安装、配置、使用相对较复杂，并且需要进行团队培训。</p><p>CVS：Concurrent Versions System。CVS 是有着三十年以上的时间的考验。CVS是开放源代码软件世界的一个伟大杰作，由于CVS功能强大，跨平台，支持并发版本控制，而且免费，所以它在全球中小型软件企业中得到了广泛使用。CVS最大的遗憾就是缺少相应的技术支持，许多问题的解决需要自已寻找资料，甚至是研究源代码。CVS是一个典型的服务器&#x2F;客户端软件，有UNIX版本的CVS 、Linux版本的CVS和WINDOWS版本的CVS。CVS支持远程管理，项目组分布开发时一般都采用CVS。</p><p>SVN：Subversion。采用了更先进的分支管理系统，它的设计目标就是取代CVS，CVS纵然易用，但也有一些与生俱来的缺点，比如CVS不支持文件改名，只对文件控制版本而没有针对目录的管理等。之后CVS 的创始人之一在其现任公司的资助下开发了SVN，用以针对CVS 的一些弱点进行改进。</p><p>2<br>主要功能说明CVS纵然是一个老牌的工具产品，并也对开源事业有贡献，但CVS的命令行操作着实让一些使用者头疼。在对一个特定版本的文档Check in的时候，需要输入一长串的路径名、文件名。在操作易用性上与CVS形成对比的是微软家族的VSS。作为微软的产品，在图形界面化操作上自不用多言，但VSS只能适用于小团队的开发工作。VSS是很好的入门级工具，但它的一些功能太过于“入门”，在验证密码、保存密码这些基本功能上处理的不尽人意。适用于大型软件开发的有“中坚级”的Clearcase，用它来管理一些小型的项目管理有些“大材小用”。Clearcase支持目录版本管理、异地团队开发、视图、多服务器等强大功能，所以一些大公司把它做为一、二级产品管理用，但同样它的价格也不菲。CVS是开源的，免费的，更何况它还有一个理想的替代者——SVN。SVN的设计专门针对CVS的问题作了改进,命令的设计更为合理,对二进制文档和目录这样的数据加强了控制能力,并且吸收了VSS的lock-modify-update(release)的模式和modify-merge模式的优点这两种方式在一定程度都支持并作了优化,没有提高使用的复杂度。由于SVN的设计结构很好,所以很容易为它开发客户端,还有WEB模式的,可以远程管理,支持RSS更改订阅。</p><p>功能<br>名称</p><p>Internet网络和远程管理</p><p>并行开发</p><p>跨平台开发</p><p>操作的便利性</p><p>信息安全性</p><p>VSS<br>最新发布版本VSS8.0可支持此功能<br>最新发布版本VSS8.0支持此功能<br>仅支持Windows 操作系统<br>安装、配置、使用均较简单，很容易上手使用<br>安全性不高，基于文件系统共享实现对服务器的访问，需要共享存储目录，这样用户可以对VSS的文件夹执行删除操作。</p><p>CVS<br>支持，速度一般<br>支持<br>支持几乎所有的操作系统<br>安装、配置较复杂，但使用比较简单，只需对配置管理做简单培训即可<br>安全性高，CVS服务器有自己专用的数据库，文件存储并不采用 “共享目录”方式，所以不受限于局域网。</p><p>SVN<br>相比CVS，更加适合基于互联网协作开发的团队，速度也更快<br>相比CVS，能够保证所有的修改都入库生效<br>同上<br>同上<br>同上</p><p>ClearCase<br>速度最快，且不受网络连接带宽的限制、防火墙以及安全问题的影响。<br>支持<br>支持常见的平台<br>安装、配置、使用相对较复杂，需要进行团队培训<br>安全性不高，采用C&#x2F;S模式，需要共享服务器上的存储目录以供客户端访问</p><p>2.1<br>Internet网络访问和远程管理</p><p>VSS、CVS和SVN都提供基于Web的界面，用户可以通过浏览器执行配置管理的相关操作，即通过这样的方法来实现对异地开发的支持。但是相对于CVS，SVN采用统一的二进制差异算法，所以消耗更少的网络带宽，因此更加适合基于互联网（或广域网）进行协作开发的地理上分布的团队，即版本服务器集中、单一；客户端可广泛分布。</p><p>其实上述实现方法有太多的局限性，例如网络（Internet）连接带宽的限制、防火墙以及安全问题等。真正意义上的异地开发支持，是指在不同的开发地点建立各自的存储库，通过工具提供同步功能自动或手动同步。这样做的好处是与网络无关，即便各个开发地点之间没有实时连通的网络，也可以通过E-Mail 附件等其它方式将同步包发给对方，实现手动的同步。而ClearCase就能实现这样的功能。</p><p>值得说明的是，在不同开发点建立各自存储库的方式，主要适用于两个或两个以上位于不同地点的开发团队协作开发的情况。如果仅是采用虚拟团队合作的方式，开发人员以个体的形式散落在不同地方，则更适合通过Internet 直接操作远程的配置管理服务器。<br>2.2<br>并行开发支持</p><p>在团队协作开发过程中，有两种主要的模式：集体代码权和个体代码权。采用集体代码权模式进行开发时，一段代码可能同时会被多个开发人员同时修改；而采用个体代码权模式进行开发时，每一段代码都始终被一个开发人员独享，别人需要修改时也要通过该开发人员完成。<br>而配置管理软件针对这一情况，也采用了不同的策略：Copy-Modify-Merge(拷贝、修改、合并)的并行开发模式、Check ut-Modify-Check in（签出、修改、签入）的独占开发模式。在并行开发模式下，开发人员可以并行开发、更改代码，并能够自动检测到代码冲突，并自动合并，或提示开发人员手动解决。<br>VSS最新发布版本8.0可支持并行开发模式，其它三种工具也都可支持。<br>CVS 采用线性、串行的批量提交，即依次地，一个接一个地执行提交，每成功提交一个文件，该文件的一个新的版本即被记录到版本库中，提交时用户提供的日志信息被重复地存储到每一个被修改的文件的版本历史中。但是当任何原因造成批量操作的中断时（典型原因包括：网络中断、客户端死机等），版本库往往处于一个不一致的状态：原本应该全部入库的文件只有一部分入库，很有可能版本库中的最新版本不能顺利编译，更为严重的是，随着其他的用户执行cvs update 操作，该不一致性将迅速在开发团队中扩散，从而严重影响团队的开发效率，并存在质量隐患。另外，假如该批量提交的中断没有被及时发现，开发团队往往要花更多的时间进行软件调试和排错。<br>SVN彻底消除了CVS的以上弊端。无论批量提交包含多少文件修改，只有当全部文件修改都成功入库，该提交才变得有效，才对其他用户可见；否则，无论任何原因造成中断，SVN 都会自动执行“回滚”（rollback）操作。换一个说法，SVN保证所有的修改要么全部入库生效，要么一个也不入库，即对版本库不作任何的修改。这就是SVN 的原子性提交（atomic commit）。<br>ClearCase可以很容易的产生分支，也可以很容易的将不同分支进行合并。这样一来，即便某一部分的工作被冻结或加锁，开发者仍然可以继续自己的工作（如：在软件集成期）。在这种情况，开发者可以在分支上工作，ClearCase的自动化操作和图形归并工具可以很容易的重新集成新的工作。<br>2.3<br>跨平台开发支持<br>如果企业需要从事多个不同平台下的开发工作，就需要配置管理工具能够对跨平台开发提供支持，否则势必会给开发、测试、发布等各个环节带来不便，将使大量的时间被浪费于代码的手工上传、下载中。<br>VSS仅支持Windows操作系统。<br>CVS、SVN和ClearCase支持几乎所有的操作系统和平台。但是CVS和SVN的服务器端在Unix, Linux环境下运行会更稳定可靠。<br>2.4<br>开发操作使用的便利性VSS安装、配置、使用均较简单，很容易上手使用。<br>CVS和SVN安装、配置较复杂，但使用比较简单，只需对配置管理做简单培训即可。<br>ClearCase安装、配置、使用相对较复杂，需要进行团队培训，需投入成本大概四万元。<br>2.5<br>信息安全性VSS它是基于文件系统共享实现对服务器的访问，需要共享存储目录，这样用户可以对VSS的文件夹执行删除操作，安全性不高。<br>CVS和SVN服务器有自己专用的数据库，文件存储并不采用 “共享目录”方式，所以不受限于局域网。安全性较高。<br>ClearCase采用C&#x2F;S模式，需要共享服务器上的存储目录以供客户端访问，安全性不高。<br>性能详述<br>3.1<br>VSS优点：操作简单，容易掌握；权限划分可到文件夹级，有Read、CheckOut&amp;&amp;CheckIn、Add&#x2F;Rename&#x2F;Delete、Destroy四种权限级别。</p><p>缺点：权限管理基于文件共享形式，只能从文件夹共享的权限设定对整个库文件夹的权限，而且必须要有可写权限；版本管理和分支管理只能靠人为的手工设置；版本发行时，只能手工挑选对应的版本文件进行发布。<br>最新版本VSS8.0主要增加了以下功能：<br>Ø<br>支持并行开发<br>Ø<br>支持基于Internet的远程访问模式<br>Ø<br>分布式团队协作增强<br>3.2<br>CVSCVS 诞生于 1986 年，当时作为一组 shell脚本而出现；1989年3月，Brian Berlinor用C语言重新设计并编写了CVS的代码；1993年前后，Jim Kingdon最终将CVS设计成基于网络的平台，开发者们能从Internet任何地方获得程序源代码。截至目前最新版本是2004年12月13日发布的<br>功能介绍<br>Ø<br>代码统一管理，保存所有代码文件更改的历史记录。对代码进行集中统一管理，可以方便查看新增或删除的文件，能够跟踪所有代码改动痕迹。可以随意恢复到以前任意一个历史版本。并避免了因为版本不同引入的深层BUG。<br>Ø<br>完善的冲突解决方案，可以方便的解决文件冲突问题，而不需要借助其它的文件比较工具和手工的粘贴复制。<br>Ø<br>代码权限的管理，可以为不同的用户设置不同的权限。可以设置访问用户的密码、只读、修改等权限，而且通过CVS ROOT目录下的脚本，提供了相应功能扩充的接口，不但可以完成精细的权限控制，还能完成更加个性化的功能。<br>Ø<br>支持方便的版本发布和分支功能。CVS在服务器端维护代码文档库，不同的开发者在本地机器上建立对应代码树，并利用CVS保持本地代码文档同代码文档库的一致。当由于多个开发者对文件的同时修改造成本地与库中的代码文件冲突时，CVS报告并协助解决冲突代码的合并问题。普通开发者（非管理员）对CVS的使用流程。<br>3.3<br>SVN</p><p>SVN 是一个自由&#x2F;开源版本控制系统，它管理文件和目录可以超越时间。一组文件存放在中心版本库，这个版本库很像一个普通的文件服务器，只是它可以记录每一次文件和目录的修改，这便使你可以取得数据以前的版本，从而可以检查所作的更改。从这个方面看，许多人把版本控制系统当作一种“时间机器”。</p><p>SVN 可以通过网络访问它的版本库，从而使用户可以在不同的电脑上使用。一定程度上可以说，允许用户在各自的地方修改同一份数据是促进协作。由于所有的工作都有历史版本，你不必担心由于失去某个通道而影响质量，如果存在不正确的改变，只要取消改变。<br>SVN的历史：</p><p>早在2000 年，CollabNet,Inc. (<a href="http://www.collab.net/">http://www.collab.net/</a>) 开始寻找CVS 替代产品的开发人员，CollabNet 提供了一个协作软件套件CEE (CollabNet EnterpriseEdition)，它的一个组件是版本控制系统。尽管CEE 在初始时使用CVS 作为其版本控制系统，但是CVS 的局限性在一开始就很明显，CollabNet 知道迟早要找到一个更好的替代品。遗憾的是，CVS成为了开源世界事实上的标准，因为没有更好的产品，至少是没有可以自由使用的。所以CollabNet 决定写一个新的版本控制系统，建立在CVS 思想之上的，但是修正其错误和不合理的特性。</p><p>2000 年2 月，他们联系OpenSource Development with CVS(Coriolis, 1999)的作者Karl Fogel，并且询问他是否希望为这个新项目工作，巧合的是，当时Karl 正在与朋友JimBlandy 讨论设计一个新的版本控制系统。在1995 年，他们两个曾经开办一个提供CVS支持的公司Cyclic Software，尽管他们最终卖掉了公司，但还是天天使用CVS 进行日常工作，在使用CVS 时的挫折最终促使他们认真地去考虑如何管理标记版本的数据，而且他们当时不仅仅提出了“SVN”这个名字，并且做出了SVN 版本库的基础设计。所以当CollabNet 提出邀请的时候，Karl 马上同意为这个项目工作，同时Jim 也得到了他的雇主，RedHat 软件赞助他到这个项目并提供了一个宽松的时间。CollabNet 雇佣了Karl 和Ben Collins Sussman，详细的设计从三月开始，在Behlendorf 、CollabNet、Jason Robbins 和 Greg Stein（当时是一个独立开发者，活跃在WebDAV&#x2F;DeltaV 系统规范阶段）的恰当激励的帮助下，SVN 很快吸引了许多活跃的开发者，结果是许多有CVS 经验的人们很乐于有机会为这个项目做些事情。</p><p>最初的设计小组固定在简单的目标上，他们不想在版本控制方法学中开垦处女地，他们只是希望修正CVS，他们决定SVN 匹配CVS 的特性，保留相同的开发模型，但不复制CVS 明显的缺陷。尽管它不需要成为CVS的继任者，它也应该与CVS 保持足够的相似性，使得CVS 用户可以轻松的做出转换。</p><p>经过14 个月的编码，2001 年8 月31 日，SVN 自己能够“成为服务”了，开发者停止使用CVS 保存SVN 的代码，而使用SVN 本身。</p><p>当CollabNet 开始这个项目的时候，曾经资助了大量的工作（它为全职的SVN 开发者提供薪水），SVN 像许多开源项目一样，被一些激励知识界精英的宽松透明的规则支配着。CollabNet的版权许可证完全符合Debian的自由软件方针，也就是说，任何人可以自由的下载，修改和重新发布，不需要经过CollabNet 或其他人的允许。<br>SVN和CVS功能性对比：<br>一、SVN包含绝大部分CVS功能<br>SVN 作为CVS 的重写版和改进版，其目标就是作为一个更好的版本控制软件，取代目前流行的CVS。SVN 的主要开发人员都是业界知名的CVS 专家。SVN支持绝大部分的CVS 功能&#x2F;命令；SVN 的命令风格和界面也与CVS 非常接近。当然，不同的地方正是对CVS 的改进。<br>二、全局性的版本编号<br>一个新的版本，并得到一个自增量的版本号N+1，该版本号并不针对某个特定的文件，而是全局性的、针对整个版本库的。因此，我们可以将SVN 的版本库看作是一个文件系统或文件目录树的数组。</p><p>从技术的角度来说，在SVN 中，“文件foo.c 的第5 版本”这个说法是错误的；正确的说法应该是：”文件foo.c 在版本库被修改了5 次，即执行5 次commit 后是什么样子？”。显然，在SVN 中，版本库被修改5 次后foo.c 的内容，和被修改了6 次后foo.c 的内容很可能完全一样，因为版本库的第6 次修改很可能只修改了版本库的其他部分，而并没有对foo.c 的进行修改。相反，在CVS 中，文件foo.c 的第1.1 版本和第1.2 版本总是不同的。</p><p>SVN 的全局性版本编号为SVN 带来了诸多的优势：如对目录或文件执行拷贝，无论涉及多少文件，SVN 不需要对单个文件依次执行拷贝命令，仅仅需要建立一个指向相应的全局版本号的一个指针即可。<br>三、目录的版本控制<br>CVS 只能对文件进行版本控制，不能对目录进行版本控制，因此CVS 没有任何关于文件“移动”（move）<br>操作的概念。当人为进行文件移动操作时，CVS 只能注意到，一个文件在一个位置被删除了，而在一个新位置创建了另外一个文件。由于它不会连接两个操作，因此也很容易使文件历史轨迹丢失。设置 CVS 存储库时，必须非常谨慎地为每个文件选择准确的位置，因为在设置之后，几乎就要一直使用这个位置了。</p><p>同样由于CVS 不记录目录的版本历史，CVS 不支持对文件的“重命名”（rename），人为的对文件进行重命名会使得命名前后的文件失去历史联系，而记录历史本来是版本管理的主要目的。</p><p>还有，CVS 不支持对文件的“拷贝”（copy），人为的拷贝对CVS 而言，只能看到新的文件的增加，而不能记录拷贝源文件和目标文件之间的联系。</p><p>综上所述，缺乏对文件“移动”、“重命名”、“拷贝”的支持的根源在于CVS 不能记录目录的版本历史，而这些操作在当前的软件开发过程中经常发生，这正是SVN被开发并取代CVS 的主要原因之一。</p><p>SVN 将目录作为一类特殊的文件来处理（事实上，从文件系统的角度来看，目录确实是一类特殊的文件，当目录中的子目录&#x2F;文件被删除、重命名、或新的子目录&#x2F;文件被创建时，目录的内容将发生改变）。因此，SVN 象记录普通文件的修改历史一样记录对目录的修改历史，当发生文件&#x2F;目录的移动、重命名或拷贝操作时，SVN 能够准确记录操作前后的历史联系。同样，象对文件的不同历史版本进行比较一样，SVN支持对目录的不同历史版本的比较，清晰展现目录的变化历史。<br>四、原子性提交<br>从使用者的角度来看，CVS 和SVN 都支持对多个文件修改的批量提交，但二者在实现方式上存在本质的区别。 CVS 采用线性、串行的批量提交，即依次地，一个接一个地执行提交，每成功提交一个文件，该文件的一个新的版本即被记录到版本库中，提交时用户提供的日志信息被重复地存储到每一个被修改的文件的版本历史中。</p><p>CVS 串行批量提交模式的弊端在于<br>－<br>当任何原因造成批量操作的中断时（典型原因包括：网络中断、客户端死机等），版本库往往处于一个不一致的状态：原本应该全部入库的文件只有一部分入库，很有可能版本库中的最新版本不能顺利编译，更为严重的是，随着其他的用户执行cvs update 操作，该不一致性将迅速在开发团队中扩散，从而严重影响团队的开发效率，并存在质量隐患。另外，假如该批量提交的中断没有被及时发现，开发团队往往要花更多的时间进行软件调试和排错。</p><p>CVS 即使在批量提交不发生中断时也会造成不一致：假设用户A 启动一个需要较长时间才能完成的批量提交；与此同时，用户B 执行cvs update 操作。此时，用户B 很有可能得到一个不一致的更新，即用户B 通过“更新”操作，得到用户A 的部分修改文件。</p><p>SVN 彻底消除了CVS 的以上弊端。无论批量提交包含多少文件修改，只有当全部文件修改都成功入库，该提交才变得有效，才对其他用户可见；否则，无论任何原因造成中断，SVN 都会自动执行“回滚”（rollback）操作。换一个说法，SVN 保证所有的修改要么全部入库生效，要么一个也不入库，即对版本库不作任何的修改。这就是SVN 的原子性提交（atomic commit）。</p><p>由于SVN 的原子性提交特性和全局版本编号方式，当提交成功完成时，一个唯一的、新的全局版本编号产生，而提交时用户提供的日志信息与该新的版本编号关联，只进行一次存储（区别于CVS 的按文件重复存储）。</p><p>五、支持变更集概念<br>由于SVN 的所有提交是原子性的，每次成功提交形成的唯一的全局版本号对应此次批量提交的所有文件修改，也就是说，一个SVN 版本号其实对应了一个逻辑上的变更集（change set），该变更集可能对应于对一个BUG 的修复，或者对应于对一个已有功能的改进，或者对应于一个新功能的实现。可以说，变更集是一个软件开发活动的逻辑结果，该变更集可以通过其对应的版本号在软件开发的其他过程中（如软件合并&#x2F;集成过程，软件发布管理，变更管理系统，缺陷追踪系统）被引用。因此，SVN 将版本管理从单纯的、单个的文件修改的层次通过逻辑上的抽象，上升到更便于理解和交流的开发活动的层次。<br>六、差异化的二进制文件处理<br>由于历史原因，CVS 主要是为早期的程序员设计的，CVS 能够有效处理文本文件（或ASCII文件，源代码文件），可以对文本文件进行差异化的存储、新旧版本的比较，文件合并等；但对于二进制文件，CVS 则明显力不从心。在CVS 的版本库中，对于二进制文件的历史版本，CVS 唯一能做的就是对不同的版本进行独立的、冗余的存储，哪怕版本之间其实只存在微小的差异。举例而言，一个10M<br>的二进制文件（照片、图形文件、机械设计文件、电子设计文件）假如每周修改一次，无论每次修改的大小，一年下来，仅该文件就要消耗500M<br>以上的存储空间。而且，客户端每次获取该文件的新版本都要消耗10M<br>的网络流量。</p><p>对于目前的开发团队，无论是软件开发，Web 站点的开发，手机等电子产品的研发，需要进行版本管理的不仅是源代码等文本文件，还需要管理需求文档、设计文档、测试文档、用户手册，图形图像文件，机械&#x2F;电子设计文件等诸多的二进制文件，CVS 显然不是一个好的选择。</p><p>与CVS 不同，SVN 采用统一的二进制差异算法（binary differencing algorithm），即对文本文件和二进制文件采用相同的差异比较算法，并以相同的方式在版本库中进行存储：每次提交后版本库中只存储相对于先前版本的差异，从而可以节省大量的存储空间。</p><p>该二进制差异算法不仅应用在版本的存储上，更为重要的是，SVN 对二进制文件与文本文件一视同仁，当客户端需要获取新的版本时（如执行svn update），在网络上只有版本的差异被传输，从而大大减少对网络带宽的消耗。更多细节参见“七、双向的差异化－压缩网络传输”。<br>七、<br>双向的差异化－压缩网络传输<br>如上所述，CVS 对二进制文件不能进行有效的差异化处理。对于文本文件，CVS 仅仅支持单向的差异化传输：从CVS 服务器到客户端的传输是差异化的，即执行cvs update 时，只有差异的部分从服务器传输到客户端；而当执行cvs commit 时，无论代码变化多少，CVS 都需要从客户端向服务器完整传输被修改文件的全部内容，不能只传输差异。</p><p>相反，无论是文本文件还是二进制文件，SVN 都进行双向的差异化传输，并且差异化内容还要进行压缩&#x2F;解压缩的过程：在服务器端获取差异显而易见，与CVS 类似；SVN 在客户端获取差异的秘密在于 — SVN 在客户端的工作拷贝中隐含了每个文件的一个“只读的、干净的”副本（该副本隐藏在隐含目录.svn 里，通常不可见，该副本还有更多的妙用，参见“十二、更多的本地&#x2F;离线操作”），通过比较用户在客户端的修改和该隐含的副本，SVN 获取需要真正传送到服务器的差异，并对差异进行压缩后才进行网络传输。</p><p>对CVS 而言，操作的成本（网络带宽消耗是最大的操作成本）与被修改的文件的大小成比例，而与修改本身的大小无关；对SVN 而言，操作成本只与修改本身的大小成比例，而与被修改的文件的大小无关。因此，与CVS 相比，SVN 消耗更少的网络带宽（以客户端的存储空间换取更少的带宽消耗在目前的计算环境下应该是个相当不错的选择！）。SVN 更加适合基于互联网（或广域网）进行协作开发的地理上分布的团队 — 版本服务器集中、单一；客户端广泛分布。<br>八、高效、快捷创建分支和基线<br>CVS 和SVN 都支持分支（branch）和基线（tag），通过分支与合并，可以有效支持大项目的并行开发模式；通过基线管理，可以准确标识一组文件的版本，有效进行软件发布管理和必要时的历史回溯。</p><p>但CVS 和SVN 在实现分支和基线的方式上存在很大的不同。CVS 在创建分支的时候，需要对所有进行分支的文件进行依次的操作，因此分支的建立成本（主要是建立分支所需的时间，或消耗的计算资源）与参与分支的文件数量成比例，项目越大，版本库越大，文件越多，分支的建立成本越高；基线（tag）的建立与此类似。</p><p>SVN 的分支和基线是通过执行“拷贝”来建立的：回想一下在没有引入版本管理工具的时候我们是如何进行所谓的“分支”和“基线”管理的？答案显然是“拷贝” — 我们通过“拷贝”或“备份”来建立基线；同样，为支持多个开发人员可以同时进行开发，我们为每个开发人员创建一份“拷贝”。由此看来，SVN 通过“拷贝”来建立分支和基线显得非常自然，有点“返朴归真”的意思。</p><p>由于SVN 的全局版本号特性，SVN 中分支或基线的创建过程，或SVN中的“拷贝”过程，真正的操作是在版本库中创建一个到某一全局版本号的指针（pointer），不再需要针对众多的单个文件依次执行操作。因此，该操作的成本为一个很小的常数，与项目大小，版本库大小，文件数目的多少无关；并且，分支或基线的建立不需要进行版本的冗余存储，新建立的分支或基线基本不占用版本库空间，分支的后续存储空间的开销也只与修改的大小有关。<br>九、集成Apache Web Server，提供更多的特性<br>SVN 通过与Apache Web Server 的集成，可以提供基于http&#x2F;https 协议的版本库访问机制，从而支持SVN 跨越防火墙的安全访问。除此以外，SVN 还可以利用更多的Apache 特性，包括但不限于：Apache 丰富的用户认证机制（包括通过LDAP服务器如Windows Active Directory 服务器的用户认证），基于目录路径的精细粒度的访问控制，对传输的网络流量进行压缩&#x2F;解压缩，浏览版本库目录结构等等。<br>十、支持WebDAV<br>WebDAV（Web-based Distributed Authoring and Versioning）是一种基于 HTTP 1.1 协议的通信协议.它扩展了HTTP 1.1，在GET、POST、HEAD 等几个HTTP 标准方法以外添加了一些新的方法，使应用程序可直接对Web Server 直接读写，并支持写文件锁定(Locking)及解锁(Unlock)，还可以支持文件的版本控制。</p><p>Microsoft windows2000&#x2F;XP 及IE, Office 还有Adobe&#x2F;MicroMedia 的DW 等都支持WebDAV，这又大大增强了Web 应用的价值，以及效能。对于需要大量发布内容的用户而言，应用WebDAV 可以降低对CMS 系统的依赖，而且能够更自由的进行创作。上传、下载变得轻松自如。</p><p>SVN 通过与Apache Web Server 的集成，支持WebDAV 协议，使得业务用户（business users）或非技术用户在不安装任何版本管理客户端的情况下轻松访问SVN 版本库，不改变业务用户已有使用习惯，支持分布的业务用户对文档的评审、修改并实现版本控制，真正将软件开发的生命周期从开发&#x2F;技术团队扩展到项目的全部干系人（stakeholder），避免通过电子邮件传递文档的混乱与无序、通过Windows 操作系统共享造成的安全漏洞、病毒攻击、历史版本被覆盖或丢失、审计困难等诸多典型问题。<br>十一、更好的冲突标识与处理<br>CVS 和SVN 都支持通过分支与合并进行并行开发，并可以自动检测到合并时的冲突（conflicts），并在合并结果中以&lt;&lt;&lt;&lt;&lt;&lt; … &gt;&gt;&gt;&gt;&gt;&gt;标识合并的冲突部分。</p><p>在CVS 中，经常会出现由于用户的疏忽（如，没有注意到冲突，或没有完全处理好冲突）而将仍然带有&lt;&lt;&lt;&lt;&lt;&lt; … &gt;&gt;&gt;&gt;&gt;&gt;冲突标识符号的文件直接进行提交（commit），从而在版本库中产生垃圾版本。</p><p>SVN 有效解决了CVS 的以上问题：SVN 记录并保持文件的冲突状态，只有当用户明确执行svn resolved 命令后，该冲突状态标识才被复位，该文件才能被提交，从而大大减少了将仍然带有&lt;&lt;&lt;&lt;&lt;&lt; … &gt;&gt;&gt;&gt;&gt;&gt;冲突标识符号的文件直接进行提交的可能性。<br>十二、<br>更多的本地&#x2F;离线操作<br>众所周知，CVS 客户端的工作拷贝中包含了一个隐含目录CVS，该目录中记录了客户端需要的一些管理信息；与此类似，SVN 的客户端工作拷贝中也包含了一个隐含目录.svn，该目录中同样记录了客户端需要的一些管理信息，如版本库URL，当前访问版本号等。</p><p>与CVS 不同的是，SVN 的.svn 目录中还包含了工作拷贝中每一个文件的一个“只读的、干净的”副本。正是由于该副本的存在，使得SVN 与CVS 相比，可以执行更多的本地&#x2F;离线操作，即某些操作不需要访问版本库服务器，因此不需要存在从客户端到服务器的网络链接，当然也不消耗任何网络带宽，这进一步增强了SVN 对广域网的友好支持。<br>SVN 的以下命令可以进行离线操作：<br>svn status －<br>显示工作拷贝上的本地修改概况；<br>svn diff －显示工作拷贝上的本地修改细节，比较修改前后的内容；<br>svn revert －<br>撤销工作拷贝上的本地修改；<br>十三、<br>对符号链接进行版本管理<br>在Unix 文件系统中，符号链接（symbolic links，包括硬链接和软链接）是一种重要的文件系统元素。CVS 不能对符号链接进行版本管理；SVN 则可以对符号链接进行版本管理。<br>十四、<br>元数据管理<br>与CVS 相比，SVN 增加了元数据（metadata）管理机制。即可以对版本库中的文件或目录附加任意的“属性”（property），并记录属性的变化历史，也就是对元数据进行版本管理。一个SVN 属性是一个“属性名称&#x2F;属性值”的二元组，如“BugNumber&#x3D; 100”就是一个属性，可以将该属性附加到版本N 上，以说明版本N 改正了编号为100的BUG。</p><p>SVN 元数据的目的是提供附件的信息以满足流程或过程自动化的需要，以增强SVN 的管理能力和自动化程度。SVN 自身就通过“属性”来存储一些特殊的信息。一个使用SVN 元数据的例子：可以在一些批处理的脚本程序或SVN的钩子程序（hooks）中创建、访问、修改“属性”元数据来满足流程自动化的要求。<br>非功能性对比：性能、可用性、可扩展性：<br>一、层次化的体系架构<br>尽管CVS 是开放源代码的，但同样由于历史的原因，即使是CVS 的主要开发和维护人员也认为目前CVS 的代码很难进行后续的维护和扩展，而这正是SVN 被重写的主要原因之一。<br>SVN 具备设计良好的三层体系架构<br>－<br>版本库层（Repository Layer），版本库访问层（Repository Access Layer），和客户端层（Client Layer）。 SVN 在层与层之间定义了明确的接口，使之具备更好的扩展性。<br>SVN 的体系架构如下图所示：</p><p>二、可选的后台版本库实现<br>CVS 的版本库以普通的文件系统方式实现；SVN 的版本库支持两种实现方式：以嵌入式的数据库BerkeleyDB 实现，或，采用特定格式的普通文件系统FSFS 方式实现。二者在可扩展性、性能、备份&#x2F;恢复等方面各有特色，用户可以根据自身的实际需求进行灵活的选择。<br>三、更好的性能和可用性<br>由于CVS 主要针对文本文件的版本处理而设计，CVS 在处理大文件时存在性能和可用性问题<br>－ CVS 在执行提交时需要向服务器传输整个文件的内容。一方面，处理文件的大小受制与客户端可用内存的多少；另一方面，大文件的处理将占用服务器的绝大部分资源，可能导致服务器性能严重下降，使得其他用户无法访问和工作，甚至出现服务器宕机。</p><p>SVN 从设计上根本杜绝了CVS 的上述问题。SVN 能够处理任意大小的文件，包括比可用内存还大的文件，并且无论是在客户端还是在服务器端，SVN 始终只需要一个相对小、相对固定的内存开销<br>－ SVN 能够进行双向的差异化&#x2F;压缩的网络传输，而且无论差异的大小，SVN 始终以大小固定的管道方式或流模式（stream）执行网络传输。事实上，由于客户端参与了差异的计算，SVN 让大量的客户端一起分担服务器的处理负荷，从而从整体上提高了SVN 的性能和可用性。<br>四、可解析、格式规范的输出<br>从用户的角度来看，命令行方式下的SVN 的风格与CVS 的风格非常类似，但SVN 还是做了重大的改进：SVN 命令行方式下的输出经过了“认真、仔细”的设计，使得其输出不仅便于“人”的阅读和理解，同样便于程序脚本的自动化解析，或者说，适合“机器”的阅读和理解。因此，在SVN 下编写批量的自动化脚本程序更加容易，脚本工作更加可靠。<br>五、更好的本地化、国际化支持<br>SVN 从一开始就充分考虑到本地化（ Localization ， L10N ）<br>、国际化（Internationalization， I18N）方面的需求，无论是对多字节文件，多字节文件名的版本管理，还是客户端工具的用户界面&#x2F;输出提示信息本地化等，SVN 都比CVS 做得更好。<br>六、丰富的可选组件<br>·SVN 有大量的客户端工具和服务器工具可供选择，主流的SVN 客户端有：<br>·SVN 命令行客户端<br>－<br>支持各种操作系统平台<br>·TortoiseSVN – Windows 下与资源管理器紧密集成的图形界面客户端<br>·Subclipse – SVN 的Eclipse 插件<br>七、支持从CVS到SVN的版本库迁移<br>由于SVN 与CVS 的诸多共性和历史渊源，现有的CVS 版本库可以很方便地转换成（或迁移到）SVN 版本库格式，使得在保留原来的CVS 历史版本信息的同时在SVN 下继续使用。现成的转换工具有：cvs2svn，该转换工具由SVN 的核心开发团队开发和维护。<br>3.4<br>ClearCase优点：功能强大，版本管理和分支管理完全自动化。<br>　　缺点：权限管理只能是基于Windows的用户安全权限管理。<br>随着软件团队人员的增加，软件版本不断变化，时间的紧缺，多种平台的复杂环境，使得 ClearCase所拥有的特殊组件已成为当今软件开发人员（工程人员和管理者）所必须的工具。分布式操作使得基于Client&#x2F;Server的运算结构跨越于网上客户机和服务器，ClearCase的先进功能直接解决了原来开发团队所面临的难以处理的问题。</p><p>软件开发所面临的问题包括：对当前多种产品的开发和维护，保证产品版本的精确，重建先前发布的产品，加强开发政策的统一和对特殊版本需求的处理。通过解决这些问题，ClearCase用资源重用的方法帮助开发团队使他们所有的软件建立得更加可靠。 Rational公司的ClearCase是软件配置领域的先导，它主要基于Windows和UNIX的开发环境。它提供了全面的配置管理──包括版本控制、工作空间管理、建立管理和过程控制，而且无须软件开发者改变他们现有的环境、工具和工作方式。</p><p>ClearCase的核心功能是版本控制，它是对在软件开发进程中一个文件或一个目录发展过程进行追踪的手段。ClearCase对所有文件系统对象（包括文件、目录和链接）增强了版本控制系统功能。可定版本的文件包括源代码、可执行文件、位图文件、需求文档、设计说明、测试计划、和一些ASCII和非ASCII文件。目录的版本记录了整个组织基础资源的发展状况，包括源文件的建立、重新命名、重新构造和删除操作等。 这种版本控制系统提供了先进的版本分支和归并功能用于支持并行开发。</p><p>3.4.1<br>控制任何文件的版本<br>ClearCase可以对每一个软件组件或元件的版本进行维护和控制。ClearCase也可以维护一个非文本文件、目录和工具的版本。正如：它可以管理库文件、编译器、需求文档、<br>测试包和数据库而不仅仅是源代码。</p><p>ClearCase的元件类型可以管理版本内容。用户可以定义自己的元件类型，也可以使用ClearCase中的预定义类型：文本文件、压缩文本文件、文件、压缩文件和二进制增量文件。</p><p>ClearCase可以利用增量算法将文本文件存储在一个特殊结构的文件容器中。ClearCase采用标准的压缩技术和增量算法存储一个压缩文本文件。（这比以往的存储形式节省了50%―70%的存储空间。）<br>　　这种元件类型文件和压缩文件可以被用于控制任何操作系统文件──比如，可执行程序、程序资源库、结构数据库和结构文档文件。二进制增量文件类型可以随时被用于二进制文件格式。<br>3.4.2<br>在版本树中组织元件发展的过程　　在ClearCase中，元件版本的组织体现在版本树结构中。一个版本书的结构可以按目录结构定制，<br>还可以包含多层分支和子分支。<br>　　在一个典型的开发环境中，很多元件的版本树结构最初仅包含一个分支，即，<br>元件的版本排列在同一条线型队列中。随着时间的发展，当用户做一些错误修复、代码的组织、一些实验性修改或指定平台的开发时，它们可以给一些相关元件定义子分支，从而脱离主干进行开发。ClearCase可以支持多级的分支操作，还可以给版本或分支命名。<br>对目录和子目录进行版本控制</p><p>ClearCase可以对目录和子目录进行版本控制，允许开发者对他们数据的组织发展过程进行追踪。目录版本对一些改变进行控制，如：建立一个新文件、修改文件名、<br>建立新的子目录或在目录间移动文件等。</p><p>ClearCase也支持对目录自动进行比较和归并的操作。<br>存储数据在一个可访问的版本对象类中（VOBS）</p><p>ClearCase把所有版本控制的数据存放在一个永久、安全的存储区中，这个存储区被称为版本对象类（Version Object Bases），项目团队（或管理者）可以决定它们所需要的VOBs的数量，可以决定什么样的目录或文件需要被维护。VOBs不仅是一个可连接的文件系统而且也是网上的资源──主机可以连接任何数量的VOBs.</p><p>ClearCase VOBs的组成模式跟UNIX、Windows NT的文件系统和分布式的数据库系统非常类似。ClearCase采用Raima数据管理机制区维护VOB数据库。当在ClearCase中连接和访问时，VOB象一个标准的软件作为目录树的形式出现在客户面前，包含标准的文件对象：目录、文件、符号链接和硬链接。但事实上，文件系统已经有广泛的版本控制组件：它包含目录元素、目录元素版本、文件元素、文件元素版本、VOB动态链接和VOB硬链接。开发者也可以查看和这些文件系统对象相关的数据。这些数据包括事件记录，建立审核以及用户定义的项如：版本标签和属性。<br>3.4.3<br>使用常见的检出&#x2F;编辑&#x2F;检入范例<br>ClearCase的命令可以控制元素的变化，确保存储区有序的繁衍并使数据损坏的程度达到最小。ClearCase采用一种检出&#x2F;编辑后检入的范例，类似于传统的版本控制工具如：RCS和SCCS。ClearCase除了可以进行检出、检入以及非检出操作外，它还可以通过命令设置另外的操作，如：删除版本、建立&#x2F;删除分枝、可按时间顺序排列或结构排列顺序列出版本历史、比较版本间的差异，并且可以归并并行开发的版本。<br>　　当开始对于一个指定的文件进行工作时，该文件具有只读属性──这意味着它不能被编辑或删除。而检出操作可以对该文件的最近版本形成一个可编辑的拷贝。它无须将文件拷贝到另一区域工作。检出的注释可以被提供。当编辑完成后，该文件被检入，于是在版本树中形成一个新的版本并且将可编辑的拷贝删除。为了检验文件的变化，在检入过程中可以填入注释信息。文件一旦被检入，即刻回复到只读状态成为共享数据，可被所有成员使用。</p><p>ClearCase支持两种检出，保留以及非保留。保留检出可以保证版本历史形成的正确范围，并且同时只允许一个人做保留检出的操作。非保留检出无须保证建立一个成功的版本，如果多个用户同时对同一元素执行非保留检出，也企图进行检入操作，那么第一个检入操作被允许，而其他用户必须通过归并操作合并它们的结果。<br>丰富的注释信息和版本数据的报表</p><p>ClearCase存储了和文件系统对象相关又截然不同的信息类。这些信息实际上并不包含在对象中，它是一些额外数据。这些数据可以由ClearCase产生，也可以由用户自己定义。在VOB数据库中存储了所有的数据。</p><p>ClearCase产生的这种数据信息提供了可靠的、面向文件系统的版本注释信息。比如：这些数据可以验证在某一时刻，元素A建立了一个新的版本。用户定义的数据可以用来表达额外的功能──比如：该文件的版本曾被用于构造应用系统的4.31版。</p><p>ClearCase的操作（如：检出、检入、和版本归并）可以建立时间记录，记录数据包含这些操作信息。这些记录被存储在VOB数据库中，主要描述了该操作的属性”谁做的、做什么、什么时候、在哪个地方及为什么”，比如：敲入命令的人员的ID号，操作的种类，操作的时间，主机名称及用户填入的描述。可以通过”lshistory”的命令显示存储在VOB中的事件记录，并且可以通过历史信息浏览器提供的图形接口观察VOB中的事件记录。<br>　　用户可以针对多种目的定义数据，包含分支的名称、版本标签、元素任一版本的注释信息。</p><p>ClearCase数据的另一种应用是形成注释的文本文件。注释命令可以通过行显示的形式列出任何一个版本文本文件的内容，这使得我们可以更容易的看到什么时候在不同的地方做了添加或删除的操作。</p><p>ClearCase也可以针对文件系统对象建立客户报表。而报表的种类可以由用户自己定制输出格式。<br>3.4.4<br>通过分支功能支持并行开发<br>ClearCase支持并行（同时）开发，每一个元素都可以沿着不同的分枝同时发展，即新的版本加到独立的分支上。ClearCase可以很容易的产生分支，也可以很容易的将不同分支进行合并。这样一来，即便某一部分的工作被冻结或加锁，开发者仍然可以继续自己的工作（如：在软件集成期）。在这种情况，开发者可以在分支上工作，我们知道， ClearCase的自动化操作和图形归并工具可以让我们很容易的重新集成新的工作。<br>　　并行开发是非常重要的，因为：<br>　　（1）它允许不同的项目在同一时间使用同一资源树。<br>　　（2）它将目前不可和其他人员共享的修改成果进行隔离。<br>　　（3）它将绝对不可和其他人员共享的修改成果进行隔离（如：已发布版本中的错误修复）。<br>　　（4）它使得在软件集成期间开发工作无需停止，程序员可以先在分枝上开发，以后再集成。<br>　　为了支持并行开发，ClearCase允许进行分支建立，追踪分支的使用，文件比较，自动归并功能。<br>3.4.5<br>自动的比较和版本间的归并　　并行开发的特点是对同一元素的不同版本进行定期比较，也需要对版本间内容进行归并。在ClearCase中，对于元素或文本文件进行比较和归并的操作有两种：基于字符型和图形界面型。其中，diff命令执行多文件比较，不执行归并。而归并命令可以处理32个”成员”，并把它们生成一个独立的文件。 ClearCase可以自动辨认归并选项并实现归并。ClearCase也可以对需要归并的项目元素进行定位。如果所有的”成员”（归并元素）是同一元素的版本，系统会自动确定基础”成员”，通常是最低版本。此外，ClearCase会记录基础版本和某一归并元素版本间的差异。如果，所有的”成员”间差异互不相同，ClearCase会自动建立归并版本。如果两个或多个归并”成员”文件内容部分不同，归并功能会提示开发者选择归并内容。ClearCase也可以实现反向归并――从主分支向子分支归并。</p><p>ClearCase的加归并功能可以在归并其它分支时选择指定的版本（那些在分支上自始至终进行变化的版本）。负归并操作可以删除部分版本差异，从而形成一个新的版本，该版本除了那些被删除的变更外包含所有的改变。</p><p>2020年11月19日11:41:54 解决git log乱码问题<br>export LESSCHARSET&#x3D;utf-8</p><p>2019年12月23日14:20:20 使用git log –author&#x3D;“author” 可以查找某一个作者所有的提交</p><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><table><thead><tr><th>加入时间</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td></td><td>git log -p filename</td><td>可以显示该文件每次提交的diff</td></tr><tr><td>2020年05月06日12:33:26</td><td>git diff c286ea2c1c65d97b679141d936dcab334687f54e HEAD – ‘:!test-input’</td><td>git diff 排除文件</td></tr><tr><td></td><td>git branch -a</td><td>查看全部分支</td></tr><tr><td></td><td>git checkout -b name remote&#x2F;branch</td><td>创建本地分支并切换</td></tr><tr><td></td><td>git push origin test:test</td><td>本地分支推送到远程</td></tr><tr><td></td><td>git pull origin test</td><td>克隆远程分支到本地，不建议</td></tr><tr><td></td><td>git remote update</td><td>更新远程分支到本地</td></tr><tr><td></td><td>git merge test</td><td>尝试快速合并本地分支</td></tr><tr><td></td><td>git branch -d(-D)</td><td>尝试、强制删除本地分支</td></tr><tr><td></td><td>git tag -d xxx</td><td>删除标签</td></tr><tr><td></td><td>git push origin :test</td><td>删除远程分支</td></tr><tr><td></td><td>git remote prune origin</td><td>删除本地仓库中无效的远程分支</td></tr></tbody></table><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>git config –local user.name “niuqiang002”<br>git config –local user.email “<a href="mailto:&#110;&#x69;&#117;&#113;&#105;&#x61;&#110;&#x67;&#48;&#x30;&#x32;&#64;&#107;&#101;&#x2e;&#x63;&#x6f;&#109;">&#110;&#x69;&#117;&#113;&#105;&#x61;&#110;&#x67;&#48;&#x30;&#x32;&#64;&#107;&#101;&#x2e;&#x63;&#x6f;&#109;</a>“</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><ol><li>git checkout –orphan new_branch  # 生成一个新的分支new_branch，包含父分支的所有文件，且orphan参数会让该分支不会指向任何以前的提交即没有历史。</li></ol><h2 id="git-lfs"><a href="#git-lfs" class="headerlink" title="git lfs"></a>git lfs</h2><p>因为yum和apt-get经常因为有人污染源配置，导致各种难以修复的问题，无法使用。所以这里建议使用二进制安装的方式</p><p>上传  </p><ol><li>下载 wget <a href="https://packagecloud.io/github/git-lfs/packages/el/7/git-lfs-3.5.1-1.el7.x86_64.rpm/download">https://packagecloud.io/github/git-lfs/packages/el/7/git-lfs-3.5.1-1.el7.x86_64.rpm/download</a> -O git-lfs.rpm</li><li>安装 rpm -i git-lfs.rpm</li><li>项目文件夹下初始化 git lfs install –local</li><li>追踪文件，此时会自动产生.gitattributes git lfs track “*.psd”</li><li>注意，一定要首先add .gitattributes git add .gitattributes</li><li>git add file.psd</li><li>git commit -m “Add design file”</li><li>git push origin main</li></ol><p>下载  </p><ol><li>如果你正在克隆包含大量 LFS 文件的仓库，显式使用 git lfs clone 命令可提供更好的性能：git lfs clone <a href="mailto:&#103;&#105;&#116;&#x40;&#x62;&#105;&#x74;&#x62;&#117;&#x63;&#107;&#x65;&#116;&#x2e;&#x6f;&#114;&#x67;">&#103;&#105;&#116;&#x40;&#x62;&#105;&#x74;&#x62;&#117;&#x63;&#107;&#x65;&#116;&#x2e;&#x6f;&#114;&#x67;</a>:tpettersen&#x2F;Atlasteroids.git</li><li>或者普通git clone后 git lfs pull</li></ol><h2 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h2><ol><li><p>添加子模块 <code>git submodule add https://github.com/OFA-Sys/Chinese-CLIP.git 20240827_wangyuliang006_clip_score_model/Chinese-CLIP</code></p></li><li><p>使用子模块</p><p>克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行如下命令完成子模块的下载：<br><code>git submodule update --init --recursive</code></p></li></ol><h2 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**/__pycache__</span><br></pre></td></tr></table></figure><p>在.gitignore中添加，忽略所有的同名文件（夹）</p><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ol><li>git fetch –all 拉取所有分支</li></ol><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><ol><li>git log –color –graph –pretty&#x3D;format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ci) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date&#x3D;relative | head -n 3</li></ol><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><ol><li>git remote add origin git@{repo}.git</li><li>git remote set-url origin https:&#x2F;&#x2F;{repo}.git</li></ol><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><ol><li>git pull origin {branch}</li></ol><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>git push origin –all</p><h2 id="本地修改尚未-add-想撤销"><a href="#本地修改尚未-add-想撤销" class="headerlink" title="本地修改尚未 add 想撤销"></a>本地修改尚未 add 想撤销</h2><p>2018年12月04日19:17:14 git 丢弃所有本地修改，包括新增删除和修改：git clean -xdf</p><p>2018年12月10日16:43:50 git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态<br>git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。<br>git reset –hard HASH #返回到某个节点，不保留修改。<br>git reset –soft HASH #返回到某个节点。保留修改<br>git clean -xdf 清除未提交的新文件及文件夹</p><ol><li>git add 添加多余文件</li></ol><p>git add 如果添加了错误的文件的话撤销操作</p><p>git status 先看一下add 中的文件</p><p>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了</p><p>git reset HEAD XXX&#x2F;XXX&#x2F;XXX.java 就是对某个文件进行撤销了</p><h2 id="git-commit-撤销"><a href="#git-commit-撤销" class="headerlink" title="git commit 撤销"></a>git commit 撤销</h2><p>如果不小心 弄错了 git add后 ， 又 git commit 了。</p><p>先使用 git log 查看节点</p><p>git reset commit_id （回退到上一个 提交的节点 代码还是原来你修改的）</p><p>git reset –hard commit_id （回退到上一个commit节点， 代码也发生了改变，变成上一次的）</p><h2 id="git-push错误提交"><a href="#git-push错误提交" class="headerlink" title="git push错误提交"></a>git push错误提交</h2><p>使用 git revert还原已经提交的修改</p><p>此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交</p><p>git revert HEAD 撤销前一次 commit</p><p>git revert HEAD^ 撤销前前一次 commit</p><p>git revert commit-id (撤销指定的版本，撤销也会作为一次提交进行保存）</p><p>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。</p><h2 id="git-tag操作"><a href="#git-tag操作" class="headerlink" title="git tag操作"></a>git tag操作</h2><p>git tag -l<br>git tag -a v1.2 9fceb02<br>git show v1.2<br>git push origin v1.2</p><h2 id="ubuntu-下升级git"><a href="#ubuntu-下升级git" class="headerlink" title="ubuntu 下升级git"></a>ubuntu 下升级git</h2><p>1、查看git版本<br>git –version</p><p>2、升级Git<br>sudo apt update  # 更新源<br>sudo apt install software-properties-common # 安装 PPA 需要的依赖<br>sudo add-apt-repository ppa:git-core&#x2F;ppa    # 向 PPA 中添加 git 的软件源<br>sudo apt-get update<br>sudo apt-get install git</p><h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>2024年04月16日11:15:59 github F2A recovery codes。 使用Microsoft Authenticator APP 扫码</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">44696-0c382</span><br><span class="line">f10ae-8a318</span><br><span class="line">62f15-94a5b</span><br><span class="line">7fda9-eb1f1</span><br><span class="line">e3241-b5e23</span><br><span class="line">4fcb9-979d5</span><br><span class="line">e7006-4ab3f</span><br><span class="line">5990f-16889</span><br><span class="line">4fdd4-54992</span><br><span class="line">fb643-a450a</span><br><span class="line">f9a95-11a24</span><br><span class="line">a1d20-e0431</span><br><span class="line">7c3c6-5c269</span><br><span class="line">ecdac-e34b9</span><br><span class="line">b5a18-0df10</span><br><span class="line">25232-4a892</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>2019年04月10日10:20:18 git操作时一定要注意git库是不是在上层目录中，这样会把上层提交</p><p>2019年04月17日19:40:03 git报错 fatal: refusing to merge unrelated histories<br>在你操作命令后面加–allow-unrelated-histories</p><p>2020年03月23日12:28:21 git保留空目录<br>我们可以直接在 logs 里面写一个 .gitignore 文件，内容如下：<br> *<br> !.gitignore<br>然后 git add logs&#x2F;.gitignore</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统及工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某壳基础设施汇总</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE/03.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%B1%87%E6%80%BB/202104%E8%B4%9D%E5%A3%B3/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE/03.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%B1%87%E6%80%BB/202104%E8%B4%9D%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<p>2021年04月25日20:08:00 TODO每个都应该有单独栏目<br>ketrace<br>天眼<br>prom<br>数易 - 聚合数据 kapcit</p><p>2021年04月29日13:53:34 调研服务云</p><ol><li>与私有云的关系。主要针对模块的运营管理，可以无缝衔接</li><li>golang&#x2F;C++接入，自定义dockerfile。主营java</li><li>如何发起上线及回滚动作，在keones发布平台</li><li>自定义监控指标，数据采集与展示。需要自行推送到prom</li></ol><p>2021年05月07日18:41:13 尝试使用web2.0自构建镜像上线后处理服务<br>完成镜像构建。即将压测</p><ol><li>如何登陆Pod？测试环境可能需要重新调整</li><li>如何查看资源利用率</li><li>如何查看日志导出等</li><li>如何发送请求，需要接入</li></ol><p>2021年05月08日10:22:18 keones创建golang项目需要技术委员会审批？！<br>先使用其他绕过，但是需要注意学习其他团队的golang使用经验</p><p>2021年05月08日11:46:13 不能使用ke-boot提供的cpp框架，里面第三方库使用的是lib发布</p><p>2021年05月10日20:20:46 可能是一次性提交太多commit了，重新init就可以了。这种情况可以尝试使用keones的导入功能<br>remote: fatal: pack exceeds maximum allowed size<br>error: remote unpack failed: index-pack abnormal exit</p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>gerrit.lianjia.com 需要单独开权限。只能使用http的方式下载，使用的密码需要在设置中获取，而不是壳内用户密码</p><img src="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/01.%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE/03.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%B1%87%E6%80%BB/202104%E8%B4%9D%E5%A3%B3/202409_gerrit_clone_login.png" class=""><h1 id="基础服务编码框架"><a href="#基础服务编码框架" class="headerlink" title="基础服务编码框架"></a>基础服务编码框架</h1><p>2023年02月06日15:26:17 继续学习keboot。今日目标是熟悉完服务云的介绍，可以开始写接口<br>2023年02月09日10:13:40 输入和输出调试；查看日志</p><p>2023年01月17日07:36:23 学习java spring cloud<br>TODO 学习私有云java对接规范，总结可用性、可观测性等要点<br>TODO 移植sample和proxy接口<br>TODO 上游如何做一致性hash</p><p>2021年05月17日20:07:38 TODO 了解天眼与日志规范</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><p>sftp 邮箱前缀@relay.ke.com<br>登录密码：pin码+网盾动态口令  </p><p>常用命令ls cd get put</p><p>2021年05月17日12:22:17 线上使用sftp<br><a href="http://wiki.lianjia.com/pages/viewpage.action?pageId=765470107">http://wiki.lianjia.com/pages/viewpage.action?pageId=765470107</a></p><p>2021年05月31日12:42:53 堡垒机会话复制<br>配置Mac所在机器的ssh<br>vim ~&#x2F;.ssh&#x2F;config<br>输入下面三行<br>host *<br>ControlMaster auto<br>ControlPath ~&#x2F;.ssh&#x2F;master-%r@%h:%p</p><p>2024-07-08 11:44:57 登录线上裸金属 ssh <a href="mailto:&#110;&#x69;&#117;&#113;&#x69;&#97;&#x6e;&#x67;&#48;&#x30;&#50;&#64;&#x72;&#x65;&#x6c;&#97;&#x79;&#x2e;&#107;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#110;&#x69;&#117;&#113;&#x69;&#97;&#x6e;&#x67;&#48;&#x30;&#50;&#64;&#x72;&#x65;&#x6c;&#97;&#x79;&#x2e;&#107;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></p><h1 id="发布平台"><a href="#发布平台" class="headerlink" title="发布平台"></a>发布平台</h1><p>2024-07-08 14:07:10 贝壳云的发布构建乱的一比，建议以multimodal-interact-platform为底，注意复制每一项配置细节。尤其是构建器和工作负载</p><h2 id="构建器"><a href="#构建器" class="headerlink" title="构建器"></a>构建器</h2><p>编译步骤选择镜像 harbor.intra.ke.com&#x2F;dayu&#x2F;tools&#x2F;maven-node:11.0.9.1-redskull，通过在harbor中的信息可知，这是支持的最新的java版本（当然有可能不在这个harbor目录还有更新的，着我们就无从得知了）。</p><blockquote><p>推送时间 2021&#x2F;9&#x2F;7 下午5:07</p></blockquote><p><a href="https://blog.csdn.net/luckywuxn/article/details/137932127">Java JDK各版本发布时间</a>  摘录其中的lts版本  </p><p>JDK 172021年9月14日第二个长期支持（LTS）版本，包含许多增强和改进，例如JEP 384：移除JFR Recording。</p><p>JDK 112018年9月25日第一个长期支持（LTS）版本，引入了HTTP 2客户端，文本块，以及删除了Java EE模块。</p><p>JDK 82014年3月18日最大的变化之一是添加了Lambda表达式和函数式编程支持，以及Stream API，日期&#x2F;时间API的改进，接口默认方法和静态方法。</p><blockquote><p>所以目前看来2018年的java11已经足够新了，没必要单独折腾升级java17或者21</p></blockquote><h1 id="监控和日志采集"><a href="#监控和日志采集" class="headerlink" title="监控和日志采集"></a>监控和日志采集</h1><p>2021年07月26日10:43:02 <a href="http://paoding.ke.com/?orgId=1">http://paoding.ke.com/?orgId=1</a><br>niuqiang002 ABC123</p><p>2024年05月03日12:06:45 fast日志监控平台 <a href="http://fast.ke.com/">http://fast.ke.com/</a></p><h1 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h1><p>2024-07-08 14:24:14 统一文档入口 <a href="http://docs.cloud.intra.ke.com/%e5%af%bc%e8%88%aa%e9%a1%b5">http://docs.cloud.intra.ke.com/%e5%af%bc%e8%88%aa%e9%a1%b5</a></p><blockquote><p>现在有用的看起来也就是项目上云：<br>而且还不如老文档好用 <a href="https://wiki.lianjia.com/pages/viewpage.action?pageId=954241753">https://wiki.lianjia.com/pages/viewpage.action?pageId=954241753</a></p></blockquote><p>2024年05月03日12:13:27 私有云控制台 <a href="http://cloud.intra.ke.com/profile/resource?from=/profile/resource">http://cloud.intra.ke.com/profile/resource?from=/profile/resource</a></p><p>2021年07月27日08:16:50 压测<br>3. 添加接口延迟监控，配置panel</p><p>2021年07月27日10:50:29 网关接入流量评估<br><a href="https://wiki.lianjia.com/pages/viewpage.action?pageId=888458265">https://wiki.lianjia.com/pages/viewpage.action?pageId=888458265</a></p><p>2021年10月12日16:12:18 工作机不能访问测试机，什么狗东西啊。尝试使用ab工具测试</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>2024年05月03日14:45:35 <a href="http://dayu.ke.com/env">http://dayu.ke.com/env</a></p><h2 id="机器学习平台"><a href="#机器学习平台" class="headerlink" title="机器学习平台"></a>机器学习平台</h2><p>2021年12月07日14:19:54 对基础平台的诉求<br>2. 支持监控成组<br>3. 可以支持TCP、WS等socket协议<br>4. 可以支持gitlab runner，自动化构建测试<br>5. 模型和数据存储<br>6. 腾挪服务器</p><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><p>2024-07-10 16:33:09 kepass平台申请IAM <a href="https://paas.ke.com/subability/iam/supplier/multimodal-interact-platform/token?serviceId=multimodal-interact-platform">https://paas.ke.com/subability/iam/supplier/multimodal-interact-platform/token?serviceId=multimodal-interact-platform</a><br>生产环境multimodal-interact-platform的服务密钥创建成功<br>AccessKeyId: G9JTCZTAB8WQJXXSMVW7<br>AccessKeySecret: K2qfHVGJnfHloB3cmQN+8BF9qnd4rDRgt5tVHpXY</p><p>测试环境multimodal-interact-platform的服务密钥创建成功<br>AccessKeyId: W1ZBDUQT1C191KVLSBGL<br>AccessKeySecret: xBkgzxTduGmXJlDvCesA3F+etzHMdpKP7sVu&#x2F;et+</p><p>预览环境multimodal-interact-platform的服务密钥创建成功<br>AccessKeyId: JB671UO1QXXJFCCVN15R<br>AccessKeySecret: zfWnf3PcMWTs01X4KpN33Qihbpk1zigBBr5o9430</p><p>开发环境multimodal-interact-platform的服务密钥创建成功<br>AccessKeyId: NMSWLJIKA7HUEGINTG8T<br>AccessKeySecret: xXALQ1wKJvFBJJCMDkHeXhWsLRS9EjQzjTNpdh02</p><p>2021年12月24日10:59:30 申请个人开发机<br><a href="mailto:&#114;&#111;&#111;&#116;&#64;&#49;&#48;&#46;&#50;&#54;&#x2e;&#x33;&#55;&#46;&#54;&#x37;">&#114;&#111;&#111;&#116;&#64;&#49;&#48;&#46;&#50;&#54;&#x2e;&#x33;&#55;&#46;&#54;&#x37;</a><br>Ksven52-<br>2021年12月24日11:17:34 个人开发机上启动docker <a href="https://www.codercto.com/a/76012.html">https://www.codercto.com/a/76012.html</a></p><ol><li>卸载旧版本 <a href="https://www.runoob.com/docker/centos-docker-install.html">https://www.runoob.com/docker/centos-docker-install.html</a></li><li>使用官方安装脚本自动安装新版本 curl -fsSL <a href="https://get.docker.com/">https://get.docker.com</a> | bash -s docker –mirror Aliyun</li><li>打开&#x2F;etc&#x2F;modprobe.d&#x2F;blacklist.conf，将 xt_conntrack 至 nf_conntrack_ipv4的都注释掉。</li><li>打开&#x2F;etc&#x2F;modprobe.d&#x2F;connectiontracking.conf，全设置true</li><li>mv &#x2F;etc&#x2F;modprobe.d&#x2F;connectiontracking.conf &#x2F;etc&#x2F;modprobe.d&#x2F;connectiontracking.conf.bak</li><li>重启docker  systemctl restart docker.service</li></ol><p>2021年12月24日11:33:58 推理服务平台不是独立构建，会使用缓存，导致构建不是最新的</p><p>2022年08月23日11:33:30 aistudio需求汇总</p><ol><li>硬件故障报警，资源监控</li><li>serving更新的权限是否可以下放给空间管理员</li><li>评测环境</li></ol><h1 id="大数据工厂"><a href="#大数据工厂" class="headerlink" title="大数据工厂"></a>大数据工厂</h1><p>2021年10月20日18:31:21 mysql2hive<br><a href="https://wiki.lianjia.com/pages/viewpage.action?pageId=96109417">https://wiki.lianjia.com/pages/viewpage.action?pageId=96109417</a></p><p>2024年05月03日12:03:27 奥丁数据平台（hive）查询页面：<a href="http://odin.adhoc.ke.com/selfQuery">http://odin.adhoc.ke.com/selfQuery</a></p><p>2024年05月03日14:42:32 数据地图 <a href="http://factory.data.ke.com/table-manage/charge/detail?table_id=108118&is_active=2">http://factory.data.ke.com/table-manage/charge/detail?table_id=108118&amp;is_active=2</a></p><p>400通话数据索引，永久存储hive表 <a href="http://factory.data.ke.com/detail?table_id=1059402&is_active=1">表详情 olap_lianjia_tp_call_record_da</a></p><p>常见问题汇总及解决@齐家乐 <a href="https://doc.weixin.qq.com/doc/w3_ANsAjgYWAAk8IfphLJTSQS80PeIlq?scode=AJMA1Qc4AAwpwwHghkAWAAkwYsADg">https://doc.weixin.qq.com/doc/w3_ANsAjgYWAAk8IfphLJTSQS80PeIlq?scode=AJMA1Qc4AAwpwwHghkAWAAkwYsADg</a></p><p>数据入仓接入指引（mysql2hive等） <a href="https://wiki.lianjia.com/pages/viewpage.action?pageId=1325255445">https://wiki.lianjia.com/pages/viewpage.action?pageId=1325255445</a></p><h1 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h1><p>2022年04月14日15:42:02<br>配偶申请住房补贴，需要证明公司无房管部门</p><p>配偶申请住房补贴，需要夫妻双方的单位房管部门意见。申请表名为《海关总署职工住房补贴申请审核表》，见附件1、2。</p><p>此表目的在于证明夫妻双方均无经适房或福利分房，本单位仅需说明无福利分房部门即可。具体为：<br>意见需要填写：“情况属实”<br>单位盖章处需要填写：“本单位无房管部门”，并加盖人力部门鲜章。<br>可见附件3。<br>因为职工申请时单位盖章是上交材料后由司局统一加盖，所以必须先加盖配偶（就是我）单位盖章。</p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>2024年05月03日12:10:25 kakfa平台化对接 <a href="https://xmen.intra.ke.com/#/kafka/kafka-resource?active=">https://xmen.intra.ke.com/#/kafka/kafka-resource?active=</a></p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>2024年05月03日14:42:58 <a href="http://apollo.portal.life.ke.com/">http://apollo.portal.life.ke.com/</a></p><h1 id="内网主站"><a href="#内网主站" class="headerlink" title="内网主站"></a>内网主站</h1><p>2024年05月03日14:41:08 贝壳内网主站 <a href="https://family.ke.com/home/beike">https://family.ke.com/home/beike</a></p><h1 id="中台主站"><a href="#中台主站" class="headerlink" title="中台主站"></a>中台主站</h1><p>2024年05月03日14:41:56 内网中台主站 <a href="https://family.ke.com/home/beike">https://family.ke.com/home/beike</a></p><h1 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h1><p>2024年05月03日14:45:01 <a href="https://vpn.ke.com/portal/#!/down_client">https://vpn.ke.com/portal/#!/down_client</a></p><h1 id="前端package"><a href="#前端package" class="headerlink" title="前端package"></a>前端package</h1><p>2024-07-15 17:17:08 <a href="http://i.package.lianjia.com/package?page=1">http://i.package.lianjia.com/package?page=1</a></p><p>2024-07-15 17:15:49 livein C端APP <a href="http://i.package.lianjia.com/package/detail?id=236164">http://i.package.lianjia.com/package/detail?id=236164</a></p><blockquote><p>联系 周勇(风行)(26515208) 开通权限</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 团队建设 </tag>
            
            <tag> 基础设施 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang深度剖析</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/202408Golang%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/202408Golang%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串存储与表示"><a href="#字符串存储与表示" class="headerlink" title="字符串存储与表示"></a>字符串存储与表示</h1><p><a href="https://cloud.tencent.com/developer/article/2029043">【Golang】深究字符串——从byte rune string到Unicode与UTF-8</a></p><h2 id="UNICODE"><a href="#UNICODE" class="headerlink" title="UNICODE"></a>UNICODE</h2><ol><li><p>ASCII码<br>通过数字电路的知识，我们知道使用二进制对信息进行编码与度量。最初现代计算机由美国人发明使用，自然而然就考虑把英语进行编码，所以<strong>ASCII码就是英语字符对应的二进制位</strong>，而且一直沿用至今，ASCII码占用1个字节，最高位统一规定为0，所以只使用了7位，一共可以表示27&#x3D;128个字符，包括32个不能打印的字符。</p></li><li><p>Unicode<br>现代计算机早已不是美国一家独大，互联网更是让世界互联互通。但是文字确实多种多样，各个国家拥有一套编码规则，同一个二进制数会被不同编码解释为不同符号。如果每次不把编码方式勾兑清楚，谁也不知道该怎么解码。有没有不需要勾兑的方式？有，就是<strong>抛开各个国家独有的编码方式，统一使用一个编码方式：Unicode</strong></p></li></ol><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><ol start="3"><li>UTF-8<br><strong>Unicode规定了字符的二进制代码，但是却没有规定如何存储</strong>。而且，各个字符占的字节是可能不同的，比如汉字很多都有10几位二进制，可能需要2个字节，3个字节，甚至4个字节。虽有unicode对应，肯定是该多少字节就存多少字节，而不是每个字符都存相同大小字节，毕竟unicode有100多万，全存相同大小字节，肯定浪费空间。但是就有了最终要解决的问题：什么时候该读3个字节以表示1个字符，什么时候该读1个字节以表示字符？</li></ol><p><strong>UTF-8就是存储Unicode的方式</strong>，但不是唯一的，其他还有utf-16,utf-32</p><p>什么时候读1个字节的字符？<br>字节的第一位为0，后面7位为符号的unicode码。所以这样看，英语字母的utf-8和ascii一致。</p><p>什么时候读多个字节的字符？<br>对于有n个字节的字符，（n&gt;1）….其中第一个字节的高n位就为1，换句话说：</p><ol><li>第一个字节读到0，那就是读1个字节  </li><li>第一个字节读到n个1，就要读n个字节  </li><li>然后第一个字高n位后1位设为0，后续其他字节前两位都设为10</li></ol><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>xxxxxxx # 读<span class="number">1</span>个字节</span><br><span class="line"><span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx # 读两个字节</span><br><span class="line"><span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx #读<span class="number">3</span>个字节</span><br><span class="line"><span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx #读<span class="number">4</span>个字节</span><br><span class="line"></span><br><span class="line">Unicode符号范围     |        UTF<span class="number">-8</span>编码方式</span><br><span class="line">(十六进制)        |              （二进制）</span><br><span class="line">----------------------+---------------------------------------------</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span><span class="number">-0000</span> <span class="number">007</span>F | <span class="number">0</span>xxxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0080</span><span class="number">-0000</span> <span class="number">07</span>FF | <span class="number">110</span>xxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0000</span> <span class="number">0800</span><span class="number">-0000</span> FFFF | <span class="number">1110</span>xxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br><span class="line"><span class="number">0001</span> <span class="number">0000</span><span class="number">-0010</span> FFFF | <span class="number">11110</span>xxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx <span class="number">10</span>xxxxxx</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是Go 语言中最常用的基础数据类型之一，实际上字符串是一块连续的内存空间，一个由字符组成的数组，既然作为数组来说，它会占用一片连续的内存空间，这片连续的内存空间就存储了多个字节，整个字节数组组成了字符串</p><p>Go语言使用UTF-8编码，为此，Go在代码中引入了一个新术语，称为 rune。rune是int32的类型别名；byte其实是uint8的别名</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>unicode是一种编码方式，任意字符可以使用一个unicode单位表示，即int32，即rune</li><li>字符串由byte数组组成，即utf-8编码存储的unicode</li></ol><p>所以字符串比如“golang字符串”，对应[]rune的size是6+3，对应[]byte的size是6+9</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/201805%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/201805%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="相关技术栈"><a href="#相关技术栈" class="headerlink" title="相关技术栈"></a>相关技术栈</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h2 id="java开发套件"><a href="#java开发套件" class="headerlink" title="java开发套件"></a>java开发套件</h2><h2 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h2><h2 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h2><h2 id="hbase"><a href="#hbase" class="headerlink" title="hbase"></a>hbase</h2><h2 id="oozie"><a href="#oozie" class="headerlink" title="oozie"></a>oozie</h2><h2 id="flume"><a href="#flume" class="headerlink" title="flume"></a>flume</h2><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h2 id="kakfa"><a href="#kakfa" class="headerlink" title="kakfa"></a>kakfa</h2><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><h2 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h2><h2 id="flink"><a href="#flink" class="headerlink" title="flink"></a>flink</h2><h2 id="elk"><a href="#elk" class="headerlink" title="elk"></a>elk</h2><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p><a href="https://www.zhihu.com/question/21380122/answer/301323291">我是学Java的，想尝试大数据和数据挖掘，该怎么规划学习？</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iphone使用配置和心得</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>iphone并不是最好的手机，甚至很多时候也是捏着鼻子在用，只是使用习惯了，没有动力和精力迁移罢了</p><ol><li><strong>iphone12仍然是主力机里最薄最小的</strong>，这对我来说是最大的吸引力。现在的小米14也能做到相近的水平，保持关注</li><li>因为日常开发更多使用<strong>MacBook，跟iphone的互联互通最流畅</strong>，所以暂时没有把iphone换掉的动力</li><li>iphone的马达震动质感更强，换过一段时间的华为，总是错过消息。但是现在可以使用手环来补缺，<strong>消息提醒方面华为的手环还是很香的</strong></li><li>在此顺便cue一下<strong>iwatch，基本需要一天一充电</strong>，充完电还经常忘了带，妥妥的电子垃圾</li></ol><h1 id="iphone"><a href="#iphone" class="headerlink" title="iphone"></a>iphone</h1><p>软件配置</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E4%B8%BB%E5%B1%8F.PNG" class="" title="iphone主屏"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E5%89%AF%E5%B1%8F.PNG" class="" title="iphone副屏"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E8%B4%9F%E5%B1%8F.png" class="" title="iphone负屏"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/iphone%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8.png" class="" title="iphone软件列表"><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ol><li><p><strong>备忘录APP</strong>和<strong>提醒事项APP</strong>都是实时同步，很好用。二者配合已经成为我的工作区，备忘录负责维护项目安排工作，提醒事项负责安排具体生活事项的执行时间</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/%E5%A4%87%E5%BF%98%E5%BD%95%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" class="" title="备忘录工作区"><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/iphone%E6%89%8B%E6%9C%BA%E9%85%8D%E7%BD%AE/%E6%8F%90%E9%86%92%E4%BA%8B%E9%A1%B9%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" class="" title="提醒事项工作区"></li><li><p><strong>屏幕使用时间APP</strong>不要全局共享，特别注意全部设备都要关闭，否则会出现不显示app图标的bug</p></li><li><p><strong>日历APP</strong>有一个致命缺陷，不能轻松的管理一个分类的日程，只能按照日期来看，也就是说其实没有办法快速查找和管理日程，比如maybe；schedule不能直接列出来，也就没办法提前做或者调整顺序</p></li></ol><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ol><li><strong>通讯录</strong>只存在于本机，垃圾玩意儿不好用。可以尝试都绑定到微信上</li><li>现在连电动车、手环都可以做到<strong>NFC复制</strong>，垃圾苹果至今没有开放，shame for apple!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iphone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据任务调度研发实战</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>需求 <img src="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-hive2hive%E5%85%B3%E7%B3%BB.png" class="" title="组件图"></p><ol><li>由四张信息表，得到一张汇总表</li><li>根据汇总表，建立调度任务，调用图片打标的能力，产出图片tag表</li><li>根据汇总表和图片tag表，产出汇总产出表</li></ol><p>我们负责的是第二部分。可以拆分为如下步骤</p><ol><li>根据汇总表，关联调度任务</li><li>开发调度任务，调用图片打标能力</li><li>结果产出到图片tag表</li></ol><h1 id="关联调度任务"><a href="#关联调度任务" class="headerlink" title="关联调度任务"></a>关联调度任务</h1><p>汇总表 xyz_dwd_xyzdata_house_floor_url_basic_da<br><a href="http://factory.data.ke.com/detail?table_id=2964502&is_active=2&search_id=172481543366828805613">http://factory.data.ke.com/detail?table_id=2964502&amp;is_active=2&amp;search_id=172481543366828805613</a></p><p>2024-09-27 16:01:29 SELECT count(*) FROM xyz.xyz_dwd_xyzdata_house_floor_url_basic_da WHERE pt&#x3D;’20240926000000’ and vector_create_time &gt; ‘2024-09-01 00:00:00’<br>count(1) &#x3D; 335713。 所以每日增量约12912条</p><p>TODO 如何识别增量更新的数据，数据表里没有唯一ID，是否可以用vector_time</p><h1 id="数据地图"><a href="#数据地图" class="headerlink" title="数据地图"></a>数据地图</h1><p><a href="http://factory.data.ke.com/tableSearch">http://factory.data.ke.com/tableSearch</a></p><p>TODO 需要关注如何控制调度任务的并发，以尽量减少资源占用</p><h1 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h1><h2 id="方案1-GPU推理"><a href="#方案1-GPU推理" class="headerlink" title="方案1 GPU推理"></a>方案1 GPU推理</h2><img src="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-GPU%E6%8E%A8%E7%90%86%E6%9E%B6%E6%9E%84.drawio.png" class=""><ol><li>spark入口任务，根据上游任务关联调度，在上游任务产出后调度，把数据表增量的每一行，当做一个请求，发送到任务管理服务</li><li>任务管理服务收到请求时，记录任务到详情表，然后发送任务到队列</li><li>队列处理服务按照模型服务的资源量，控制消费并发度，并同步请求模型服务，获取到处理结果</li><li>队列处理服务将结果更新到任务详情表。（队列处理服务和任务管理服务可能是同一个应用）</li><li>通过mysql to hive任务，将任务详情表的每日增量，同步到hive表中交付</li></ol><p>这个方案的优势是通过任务队列，保护资源不足的模型服务，最大程度控制需要的资源量，扩缩容操作非常简单，更容易复用到在线服务；模型独立打包容器服务，可以很容易屏蔽环境问题。但是显然</p><ol><li>链条比较长，可能会导致mysqltohive和原始hive的数量不对应</li><li>模块众多，开发难度大</li><li>系统吞吐瓶颈在GPU资源，一旦模型服务不可用，后续的恢复工作需要很多人工参与</li></ol><h2 id="方案2-CPU推理-python"><a href="#方案2-CPU推理-python" class="headerlink" title="方案2 CPU推理 python"></a>方案2 CPU推理 python</h2><img src="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/202409%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94.png" class=""><p>相关的模型居然可以轻松使用CPU，而且速度更快？！所以架构就完全变了</p><img src="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98-CPU%E6%8E%A8%E7%90%86%E6%9E%B6%E6%9E%84.drawio.png" class=""><p>模型可以CPU推理之后，事情就简单了。spark入口任务从hive中取数据后，直接调用模型模块即可直接得到结果</p><p>优势:  </p><ol><li>直接使用CPU资源，架构简单，不需要做并发量控制</li></ol><p>劣势: </p><ol><li>需要把CPU运行环境搬运到pyspark环境中，需要有很多调试测试的工作</li><li>复用性差，同个模型很难复用到在线服务，并且环境也比较难复用到其他模型，</li><li>很难适用于较大的模型，因为打包分发比较困难</li><li>不能使用GPU资源<br>所以只能作为参考方案</li></ol><h3 id="模型模块"><a href="#模型模块" class="headerlink" title="模型模块"></a>模型模块</h3><p>主要有以下工作：</p><ol><li>打包pyspark上的运行环境 <a href="https://spark.apache.org/docs/latest/api/python/user_guide/python_packaging.html#using-virtualenv">https://spark.apache.org/docs/latest/api/python/user_guide/python_packaging.html#using-virtualenv</a></li><li>打包需要在pyspark上运行的代码</li><li>需要确认，能否在spark集群环境的CPU上并行执行</li></ol><h4 id="打包pyspark上的运行环境"><a href="#打包pyspark上的运行环境" class="headerlink" title="打包pyspark上的运行环境"></a>打包pyspark上的运行环境</h4><p>启动容器</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> harbor.intra.ke.com/asr/mmpretrain</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> DOMAIN_PREFIX=xyz-multimodal-typical-floorplan-cls-service</span><br><span class="line"><span class="comment"># 源代码目录</span></span><br><span class="line"><span class="keyword">ENV</span> MATRIX_CODE_DIR=/data0/service/$&#123;DOMAIN_PREFIX&#125;.ke.com</span><br><span class="line"><span class="comment"># 应用日志目录</span></span><br><span class="line"><span class="keyword">ENV</span> MATRIX_APPLOGS_DIR=/data0/applogs/$&#123;DOMAIN_PREFIX&#125;.ke.com</span><br><span class="line"><span class="comment"># 其他数据目录</span></span><br><span class="line"><span class="keyword">ENV</span> MATRIX_PRIVDATA_DIR=/data0/privdata/$&#123;DOMAIN_PREFIX&#125;.ke.com</span><br><span class="line"><span class="comment"># 缓存数据目录</span></span><br><span class="line"><span class="keyword">ENV</span> MATRIX_CACHE_DIR=/data0/cache/$&#123;DOMAIN_PREFIX&#125;.ke.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="variable">$&#123;MATRIX_CODE_DIR&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p <span class="variable">$&#123;MATRIX_APPLOGS_DIR&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p <span class="variable">$&#123;MATRIX_PRIVDATA_DIR&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p <span class="variable">$&#123;MATRIX_CACHE_DIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;MATRIX_CODE_DIR&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . <span class="variable">$&#123;MATRIX_CODE_DIR&#125;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install mmengine==0.8.3 -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure><p>构建环境。这里使用conda的方式，venv打包出来的环境没有python可执行程序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化conda环境，这一步可能比较慢</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/miniconda3</span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh</span><br><span class="line">bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3</span><br><span class="line"><span class="built_in">rm</span> ~/miniconda3/miniconda.sh</span><br><span class="line">~/miniconda3/bin/conda init bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建独立环境，后续就可以使用python3和pip了</span></span><br><span class="line">conda create -y -n pyspark_conda_env -c conda-forge python=3.10.13</span><br><span class="line">conda activate pyspark_conda_env</span><br><span class="line">python3 --version</span><br><span class="line">python3 -m pip list</span><br><span class="line">python3 -m pip install conda-pack</span><br><span class="line">python3 -m pip install pyspark</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装必要的依赖包</span></span><br><span class="line">python3 -m pip install  torch==1.12 torchvision torchaudio -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line"><span class="built_in">cd</span> /home/jingjing/ &amp;&amp; python3 -m pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/  <span class="comment"># 注意这里需要使用王静提供的requirements.txt</span></span><br><span class="line">pip install -U openmim &amp;&amp; mim install mmcv==2.2.0  <span class="comment"># 注意这里只能使用2.2.0版本</span></span><br><span class="line">pip install numpy==1.26.4 -i https://pypi.tuna.tsinghua.edu.cn/simple/  <span class="comment"># 注意这里只能使用1.x版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认环境，使用conda打包</span></span><br><span class="line">python3 -m pip list</span><br><span class="line">conda list</span><br><span class="line">conda pack -f -o pyspark_conda_env.tar.gz</span><br><span class="line">docker <span class="built_in">cp</span> 8b60a48521a6:/data0/service/xyz-multimodal-typical-floorplan-cls-service.ke.com/pyspark_conda_env.tar.gz ./</span><br><span class="line">tar xzf pyspark_conda_env.tar.gz &amp;&amp;  ./bin/python3.10 -m pip list <span class="comment"># 确认环境打包出来了</span></span><br><span class="line"><span class="built_in">cd</span> /mnt/cfs/xyz-data-tj/inference/multimodal-interact-deploy/20240924_wangjing490_cls_typical_floorplan/ &amp;&amp; /home/niuqiang002/condaenv/bin/python3.10 run.py  <span class="comment"># 确定环境在宿主机上也能使用</span></span><br></pre></td></tr></table></figure><p>conda环境包交付大数据团队上传到指定的hdfs路径。工单如：<a href="https://ones.ke.com/project/orders/19/detail/73974?currentKey=%23basic">https://ones.ke.com/project/orders/19/detail/73974?currentKey=%23basic</a></p><p>到这里并没有结束。。。运行时发现又少底层依赖的opengl库。如果直接用宿主机的，又发现宿主机只有32位的lib，所以需要专门构建centos7的镜像，安装x86_64的依赖后拷贝</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ImportError: libGL.so.1: wrong ELF class: ELFCLASS32</span><br></pre></td></tr></table></figure><h4 id="打包运行代码环境"><a href="#打包运行代码环境" class="headerlink" title="打包运行代码环境"></a>打包运行代码环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 宿主机上安装java环境</span></span><br><span class="line">yum install -y java-11-openjdk java-11-openjdk-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试打包出来的pyspark环境可用</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/mnt/env/addon/lib/:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PYSPARK_DRIVER_PYTHON=/mnt/env/condaenv</span><br><span class="line"><span class="built_in">export</span> PYSPARK_PYTHON=/mnt/env/condaenv/bin/python3.10</span><br><span class="line">/home/niuqiang002/condaenv/bin/python3.10 spark_entrance.py</span><br><span class="line"></span><br><span class="line">zip pyspark_cls_typical_floorplan202409291540.zip -r configs imgdata inference_housetype.py main_process.py mmpretrain model parse_frame_json.py run_spark.sh testdata</span><br></pre></td></tr></table></figure><p>运行代码包通过任务上传。配置如：<img src="/"></p><h2 id="方案3-CPU推理-dockercontainer"><a href="#方案3-CPU推理-dockercontainer" class="headerlink" title="方案3 CPU推理 dockercontainer"></a>方案3 CPU推理 dockercontainer</h2><h1 id="数据产出"><a href="#数据产出" class="headerlink" title="数据产出"></a>数据产出</h1><p>户型落表字段：<a href="https://lv3m6lva5yh.feishu.cn/sheets/QsSNs5CYVh1CBVtcBIac0qHDnHg?sheet=OX9lx8">https://lv3m6lva5yh.feishu.cn/sheets/QsSNs5CYVh1CBVtcBIac0qHDnHg?sheet=OX9lx8</a></p><p>矢量基础信息解析：  &#x2F;nfs&#x2F;a100-80G-18&#x2F;wencheng&#x2F;MultiModal&#x2F;floor_plan_label&#x2F;parse_frame_json.py</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据调度任务技术研究</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%95%B0%E6%8D%AE/202408%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="数据地图"><a href="#数据地图" class="headerlink" title="数据地图"></a>数据地图</h1><p><a href="http://factory.data.ke.com/tableSearch">http://factory.data.ke.com/tableSearch</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webRTC开发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>UI设计稿 <a href="https://mastergo.com/file/123324039025749?page_id=11759:036146&shareId=123324039025749">https://mastergo.com/file/123324039025749?page_id=11759%3A036146&amp;shareId=123324039025749</a><br>来自20117403</p><h1 id="声网"><a href="#声网" class="headerlink" title="声网"></a>声网</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>&#x2F;Users&#x2F;niuqiang&#x2F;Downloads&#x2F;实时多模态大模型X声网RTC-20240701.pdf</p><h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><p>最基础版约合403.2元&#x2F;千小时 <img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/202408_shengwang_webrtc_price.png" class="" title="细节"></p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p><a href="https://console.shengwang.cn/overview">https://console.shengwang.cn/overview</a></p><p>水晶球。可以从咱的账号控制台进去，查看通话详情。<br><a href="https://doc.shengwang.cn/doc/analytics/general/landing-page">https://doc.shengwang.cn/doc/analytics/general/landing-page</a></p><p>RTC</p><p>APpid 70379961c2614cf39cf619c370315157<br>APP 主要证书 3d21006007ef4ca2a3d3941724776830  </p><p>产品名： RTC<br>频道名： test<br>Token : 007eJxTYNiW9dO3rqG11fK4zHTtqkvVu&#x2F;pfrPLUko7wqArk6thtm6TAYG5gbG5paWaYbGRmaJKcZmyZnGZmaJlsDBQ3NDU0Nb+w9H5aQyAjw67jWxkYoRDEZ2EoSS0uYWAAABORHxs&#x3D;<br>Token 将于 September 11, 2024 1:50 AM UTC 过期</p><p>产品名： RTM<br>用户 ID：<br>niuqiang<br>Token : 007eJxTYOCrecEr2&#x2F;XZyvqc+9xr8ZY3Ao+fn6BmF5TB4&#x2F;b6ue6tF44KDOYGxuaWlmaGyUZmhibJacaWyWlmhpbJxkBxQ1NDU&#x2F;Oty+6nNQQyMvh372diZGBiYARCEJ+DIS+ztDAzMS8dAFcUIKM&#x3D;<br>Token 将于 September 11, 2024 1:53 AM UTC 过期</p><h2 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h2><p>安卓客户端开发 <a href="https://doc.shengwang.cn/doc/rtc/android/landing-page">https://doc.shengwang.cn/doc/rtc/android/landing-page</a></p><p>iOS<br><a href="https://doc.shengwang.cn/doc/rtc/ios/landing-page">https://doc.shengwang.cn/doc/rtc/ios/landing-page</a></p><p>Android<br><a href="https://doc.shengwang.cn/doc/rtc/android/landing-page">https://doc.shengwang.cn/doc/rtc/android/landing-page</a></p><p>web<br><a href="https://doc.shengwang.cn/doc/rtc/javascript/landing-page">https://doc.shengwang.cn/doc/rtc/javascript/landing-page</a></p><h2 id="服务端开发（虚拟人）"><a href="#服务端开发（虚拟人）" class="headerlink" title="服务端开发（虚拟人）"></a>服务端开发（虚拟人）</h2><p>从rtc 获取音频，pcm&#x3D;&#x3D;vad&#x3D;&#x3D;ars&#x3D;&#x3D;llm&#x3D;&#x3D;tts&#x3D;&#x3D;》 rtc</p><p>参考端上已有逻辑 <a href="http://gerrit.lianjia.com/#/admin/projects/livein-app/android/livein_home">http://gerrit.lianjia.com/#/admin/projects/livein-app/android/livein_home</a></p><p>服务端 Java SDK文档地址 @郑晓峰<br><a href="https://doc.shengwang.cn/doc/rtc-server-sdk/java/overview/product-overview">https://doc.shengwang.cn/doc/rtc-server-sdk/java/overview/product-overview</a></p><p>java相关的demo，你可以先跑起来看看 @刘应<br>&#x2F;Users&#x2F;niuqiang&#x2F;Downloads&#x2F;sdkdemo-java.zip</p><p><a href="https://doc.shengwang.cn/doc/rtc-server-sdk/java/resources">https://doc.shengwang.cn/doc/rtc-server-sdk/java/resources</a>  lib包在这里下载  </p><p>go sdk和 demo @魏洪钦<br><a href="https://github.com/AgoraIO-Extensions/Agora-Golang-Server-SDK/tree/main">https://github.com/AgoraIO-Extensions/Agora-Golang-Server-SDK/tree/main</a><br><a href="https://github.com/AgoraIO-Extensions/go-aigc-agent-demo">https://github.com/AgoraIO-Extensions/go-aigc-agent-demo</a></p><p>rtc和rtm的 linux sdk访问声网的rtn哪个端口</p><p>tcp：80，443，1080，8000，8443，9700，25000；<br>udp：53, 1080，8000，8443，8913，9700，25000，4000-4050</p><h2 id="服务端开发（通道管理）"><a href="#服务端开发（通道管理）" class="headerlink" title="服务端开发（通道管理）"></a>服务端开发（通道管理）</h2><p><a href="https://doc.shengwang.cn/doc/rtc/restful/channel-management/operations/post-dev-v1-kicking-rule">服务端 API</a> 看起来是做项目运营管理用的，不是服务端开发</p><h2 id="服务端开发（token服务器）"><a href="#服务端开发（token服务器）" class="headerlink" title="服务端开发（token服务器）"></a>服务端开发（token服务器）</h2><p><a href="https://doc.shengwang.cn/doc/rtc/android/basic-features/token-authentication">https://doc.shengwang.cn/doc/rtc/android/basic-features/token-authentication</a></p><p>golang demo<br><a href="https://github.com/AgoraIO/Tools/blob/master/DynamicKey/AgoraDynamicKey/go/sample/rtctokenbuilder2/sample.go">https://github.com/AgoraIO/Tools/blob/master/DynamicKey/AgoraDynamicKey/go/sample/rtctokenbuilder2/sample.go</a></p><h2 id="RTM"><a href="#RTM" class="headerlink" title="RTM"></a>RTM</h2><p>1对1发送文本信息只能使用另外的RTM通道，现在还没有很好的融合 <a href="https://doc.shengwang.cn/doc/rtm2/homepage">https://doc.shengwang.cn/doc/rtm2/homepage</a></p><p>但是另一个技术给出了dataStream系列接口</p><ol><li>边端 doc.shengwang.cn&#x2F;api-ref&#x2F;rtc&#x2F;ios&#x2F;API&#x2F;toc_datastream#api_irtcengine_createdatastream</li><li>服务端sdk也可以收发dataStream：<br>AgoraRtcConn.createDataStream、sendStreamMessage发送，<br>ILocalUserObserver.onStreamMessage来接收<br><a href="https://doc.shengwang.cn/api-ref/rtc-server-sdk/java/interfaceio_1_1agora_1_1rtc_1_1_i_local_user_observer#onStreamMessage()">https://doc.shengwang.cn/api-ref/rtc-server-sdk/java/interfaceio_1_1agora_1_1rtc_1_1_i_local_user_observer#onStreamMessage()</a></li></ol><p>限制：<br>每一个声网引擎实例，只能同时持有5个数据流通道。但是每一个通道是可以持续的复用来发送消息的。<br>每次createDataStream会返回一个streamId，这个streamId代表一个数据流消息通道，同一个streamId可以多次使用，总体上只要不超过如下限制即可：</p><ol><li>频道内每人最多能同时有 5 个数据通道。</li><li>每个数据通道每秒最多能发送 60 个包（每个包最大为 1 KB）。</li><li>每个数据通道每秒最多能发送 30 KB 数据。</li></ol><h1 id="跟进过程归档"><a href="#跟进过程归档" class="headerlink" title="跟进过程归档"></a>跟进过程归档</h1><p>2024-09-05 16:13:54 技术对接，正常操作的情况下，手动干预一次</p><p>2024-09-11 14:41:47 SDK代码类没有任何文档，参数命名s,s1,s2</p><p>2024-09-12 19:59:20 sdk下载页给出的sdk是有问题的，conn.connect固定报-121，换成跑通示例项目里的就正常了<br>错误的 <a href="https://doc.shengwang.cn/doc/rtc-server-sdk/java/resources">https://doc.shengwang.cn/doc/rtc-server-sdk/java/resources</a><br>正确的 <a href="https://doc.shengwang.cn/doc/rtc-server-sdk/java/get-started/run-example">https://doc.shengwang.cn/doc/rtc-server-sdk/java/get-started/run-example</a><br>wget <a href="https://repo1.maven.org/maven2/io/agora/rtc/linux-sdk/4.0.1/linux-sdk-4.0.1.jar">https://repo1.maven.org/maven2/io/agora/rtc/linux-sdk/4.0.1/linux-sdk-4.0.1.jar</a>  </p><p>2024-09-18 08:13:55 遇到keschedule服务端引发的异常，造成的服务无法启动。只能先删除相关依赖，耽误大概2小时</p><p>2024-09-15 10:35:14 用户离开房间没有明确回调</p><p>2024-09-16 17:10:53 研发测试，发现有比较明显的杂音问题。未能复现</p><h1 id="火山"><a href="#火山" class="headerlink" title="火山"></a>火山</h1><h2 id="价格-1"><a href="#价格-1" class="headerlink" title="价格"></a>价格</h2><p>基础版400元&#x2F;千小时</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/202409_valcano_webrtc_price.png" class="" title="基础版"><p>但是有个100万分钟可以薅</p><img src="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98/202409_valcano_webrtc_priceoff.png" class="" title="100万分钟优惠"><h2 id="控制台-1"><a href="#控制台-1" class="headerlink" title="控制台"></a>控制台</h2><p>临时token：<br>00166b5cf21580473015c39df69SQC2pzYCTnzaZs6242YLAHRlc3RDaGFubmVsCABuaXVxaWFuZwYAAADOtuNmAQDOtuNmAgDOtuNmAwDOtuNmBADOtuNmBQDOtuNmIACJ5vmkVa9B9PZN2k+yVBRIg5ilc&#x2F;j6gFlTLRtEHe86pw&#x3D;&#x3D;</p><p>此临时Token将于2024-09-13 11:51到期</p><p>APP_ID &#x3D; “66b5cf21580473015c39df69”;<br>APP_KEY &#x3D; “a97642a1a9d2476d80f3ccba79880c9d”;</p><p>String appid &#x3D; “4931624750”;<br>String accessToken &#x3D; “qnF3X3pKUz4VfLC2Zim1B2eP1JkOGf4u”;<br>应用名称 livein_speech_all<br>ASR_DEFAULT_CLUSTER &#x3D; “volcengine_streaming_common”<br>TTS_DEFAULT_CLUSTER &#x3D; “volcano_tts”;<br>SAMPLE_RATE_INT &#x3D; 16000;<br>CHANNEL_NUM_INT &#x3D; 1;<br>TTS_DEFAULT_ONLINE_VOICE_TYPE &#x3D; “BV700_streaming”;  </p><h2 id="服务端开发（通道管理）-1"><a href="#服务端开发（通道管理）-1" class="headerlink" title="服务端开发（通道管理）"></a>服务端开发（通道管理）</h2><p>火山的<a href="https://www.volcengine.com/docs/6348/69815">服务端 OpenAPI 参考</a> 看起来可以在服务端实现虚拟人，与客户端通信</p><h2 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h2><h2 id="虚拟人开发"><a href="#虚拟人开发" class="headerlink" title="虚拟人开发"></a>虚拟人开发</h2>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生多模态大模型及相关技术研究</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E5%8E%9F%E7%94%9F%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E5%8E%9F%E7%94%9F%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="GPT4o"><a href="#GPT4o" class="headerlink" title="GPT4o"></a>GPT4o</h1><p>发布页 <a href="https://openai.com/index/hello-gpt-4o/">https://openai.com/index/hello-gpt-4o/</a></p><p>接口文档定义 <a href="https://platform.openai.com/docs/guides/chat-completions">https://platform.openai.com/docs/guides/chat-completions</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多模态大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新项目模板</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202409%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%89%8B%E5%86%8C/202409%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="新项目模板"><a href="#新项目模板" class="headerlink" title="新项目模板"></a>新项目模板</h1><p>来自持续工作的方法和技巧</p><h2 id="简略版"><a href="#简略版" class="headerlink" title="简略版"></a>简略版</h2><ol><li>定义目标和原则。</li><li>展望结果。</li><li>头脑风暴&#x2F;集思广益。</li><li>组织整理。</li><li>明确下一步的行动方案。</li></ol><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><pre><code>概念：是什么，有什么用。概念是一种语言实操：怎么用--&gt; 产出 xxx技术调研落地：有什么优势；有什么限制优化：在场景落地的重难点--&gt; 产出 xxx研发实战架构：怎么做到的八股：直接面向面试（即money）编程--&gt; 产出 xxx深度剖析</code></pre><h2 id="STAR完整版"><a href="#STAR完整版" class="headerlink" title="STAR完整版"></a>STAR完整版</h2><ol><li>Situation<ol><li>项目背景。</li><li>当前最重要的一件事是什么（为什么是它）？</li><li>作用的对象是哪些？</li><li>还需要哪些输入？</li><li>能达成什么效果</li></ol></li><li>Task。<ol><li>自己负责的部分，注意定义边界，</li><li>解决了什么问题，</li><li>目标和任务拆分是什么</li></ol></li><li>Action。<ol><li>如何设计，各模块功能，</li><li>核心算法，技术选型是如何达成的，</li><li>清楚的知道每一个组件的工作流程以及实现原理。</li><li>怎么实现，难点在哪？</li><li>需要哪些团队合作（什么人，需要分别贡献什么）</li></ol></li><li>Result。<ol><li>达成的效果，</li><li>最好有数据能够支撑。</li></ol></li><li>你自己有哪些思考？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程师手册 </tag>
            
            <tag> STAR模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webRTC技术调研</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/202408WebRTC%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="音频3A算法"><a href="#音频3A算法" class="headerlink" title="音频3A算法"></a>音频3A算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>手机电脑等智能设备的普及，AI智能、5G等技术的不断发展，<strong>语音通信成为了最方便快捷的远程交流方式</strong>，会议全向麦克风、会议一体化终端等会议系统逐渐成为企业经营中的重要工具。语音质量决定了企业远程沟通协作效果，其中噪音和回声能够严重影响到语音预处理后的质量，从而降低参会人员对另一方语音的接收完整度和准确性。我们知道影响通话质量的主要因素是噪声和回声，其中噪声是语音信号在采集、传输、编码等处理过程中的无用成分，而回声就是在通话过程中从听筒听到自己讲话的声音。噪音和回声的存在令人难以忍受，<strong>如何降低噪声及回声对语音信号的影响至关重要</strong>，而音频3A算法的产生就是为了解决这些问题。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>音频数据的处理过程有个预处理过程，就是在音频数据采集完成之后的一步，音频的预处理就是用的3A处理。啸叫和回声是因为扬声器发出的声音被麦克风再拾取导致的。音频3A算法主要包含以下三个方面：</p><p>(1).声学回声消除（AEC）</p><p>(2).背景噪声抑制（ANS）</p><p>(3).自动增益控制（AGC）</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>1、AEC回声消除算法原理</p><p>回声消除（AEC）是指在二线传输的两个方向上同时间、同频谱地占用线路，在线路两个方向传输的信号完全混在一起，本端发信号的回波就成为了本端信号的干扰信号，利用自适滤波器可抵消回波以达到较好的接收信号质量，即为回声消除。<strong>回声消除的原理就是利用接收到的音频与本地采集的音频做对比，添加反相的人造回声，将远端的声音消除</strong>。</p><p>2、ANS背景噪声抑制算法原理</p><p>背景噪声抑制（ANS）指的是将声音中的背景噪声识别并进行消除的处理。背景噪声分为平衡噪声和瞬时噪声，<strong>平稳噪声频谱稳定，频谱能量方差小，利用噪声的特点，对音频数据添加反向波形处理，即可消除噪声。目前，对于平稳的噪声处理已经有很多种简单方法能够进行成功抑制，但是对于生活中常见的一些瞬态噪声却没有过多解决的好办法</strong>。</p><p>瞬态噪声的共同特点就是突发性极强，在时域上呈振荡衰弱的形式出现，持续时间在十几毫秒至上百毫秒不等，在频域上分布很宽，所以在频域上瞬态噪声的频谱基本上都是和正常的语音的频谱混叠在一起的很难进行抑制。</p><p>3、AGC自动增益算法原理</p><p>自动增益控制（AGC）指当直放站工作于最大增益且输出为最大功率时，增加输入信号电平，提高直放站对输出信号电平控制的能力。<strong>其主要用于调整音量幅值，提高语音通信系统在带噪声环境中的性能</strong>。人正常交谈的音量在40-60dB之间，低于25dB的声音听起来很吃力，而超过100dB的声音会让人感到不适，AGC的作用就是将音量调整到人接受的范围。</p><p>音频响度及麦克风拾音控制是保证音视频沟通质量的重要技术手段，一般来说，音频标准、传输条件、人为失误等因素都可能导致音频信号之间出现声音突变或者响度不一致的情况，这时候就需要对音频信号放大或缩小以得到自然清晰的语音通信。</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞定-工作方法与艺术</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202407%E6%90%9E%E5%AE%9A-%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E4%B8%8E%E8%89%BA%E6%9C%AF/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202407%E6%90%9E%E5%AE%9A-%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95%E4%B8%8E%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式入门</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202408%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202408%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谨记最后是为了解决问题，创造业务价值。设计模式是与别人交流的语言，也是工具，但不是目的</p><h1 id="大话设计模式"><a href="#大话设计模式" class="headerlink" title="大话设计模式"></a>大话设计模式</h1><h1 id="没有设计模式的时候是什么样子的？"><a href="#没有设计模式的时候是什么样子的？" class="headerlink" title="没有设计模式的时候是什么样子的？"></a>没有设计模式的时候是什么样子的？</h1><h1 id="吴玲业务方法论"><a href="#吴玲业务方法论" class="headerlink" title="吴玲业务方法论"></a>吴玲业务方法论</h1><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ol><li>所谓的过度设计，就是在没有必要的时间和地点进行过度的抽象；</li><li>所谓的缺乏抽象，就是在必要的时间和地点没办法进行通用的抽象设计；</li></ol><p>所以一方面，我们应该急业务所急，牢记价值牵引；另一方面，我们应该知道在何时何地做恰当的抽象，不忘技术驱动</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 技术与工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习入门</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202409%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/202409%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-26 10:46:39 从韩阳分享开始，入门深度学习。首先是分享时的几个问题：</p><ol><li>为什么首字最慢，后面计算过程是类似的</li><li>第一个字是怎么生成的</li><li>纬度不可能枚举，怎么找到一个字的</li><li>既然都是数值计算，为什么相同输入不是相同输出</li><li>数据量大小具体在哪个位置产生影响</li></ol><p>两本书：</p><ol><li>基于Python的理论与实现 – 深度学习入门</li><li>深入浅出神经网络与深度学习</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 技术与工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灵感书单</title>
      <link href="/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/%E7%81%B5%E6%84%9F%E4%B9%A6%E5%8D%95/"/>
      <url>/journaling/%E6%80%8E%E4%B9%88%E8%AF%BB/%E7%81%B5%E6%84%9F%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="未读书单"><a href="#未读书单" class="headerlink" title="未读书单"></a>未读书单</h1><p>第一版按照onedrive中的分类</p><table><thead><tr><th>分类</th><th>书名</th><th>推荐语</th><th>添加时间</th></tr></thead><tbody><tr><td>编程能力</td><td>Head first 设计模式</td><td>了解设计模式和mvc</td><td></td></tr><tr><td></td><td>领域驱动设计</td><td></td><td></td></tr><tr><td></td><td>编程之道</td><td></td><td>2018年5月15日</td></tr><tr><td>公司制度</td><td></td><td></td><td></td></tr><tr><td>行业研究</td><td>深入浅出神经网络与深度学习</td><td></td><td>2023-04-08</td></tr><tr><td>八股</td><td></td><td></td><td></td></tr><tr><td>家庭与我</td><td></td><td></td><td></td></tr><tr><td>通俗文学</td><td>百年孤独</td><td></td><td></td></tr><tr><td>人物传记</td><td></td><td></td><td></td></tr><tr><td>方法论</td><td>思考，快与慢</td><td>尝试发现自己思维的优势与不足，避免无效努力</td><td>2024-06-20</td></tr><tr><td></td><td>进化：快速打开局面的职场丛林法则</td><td>非必选</td><td>2018年5月15日</td></tr><tr><td>理财</td><td>曼昆经济学</td><td></td><td></td></tr><tr><td>政经时闻</td><td>理想国</td><td></td><td>2024-06-20</td></tr><tr><td>文法哲史</td><td>血酬定律，潜规则</td><td>之后看大明王朝</td><td></td></tr><tr><td>人文社科</td><td></td><td>注意社会心理学top10</td><td></td></tr><tr><td>博弈论</td><td></td><td></td><td></td></tr><tr><td>通往奴役之路</td><td></td><td></td><td></td></tr><tr><td>独裁者手册 &amp; 商君书</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>2024年06月24日16:45:51 从豆瓣网页版拷贝，待整理</p><pre><code>宝贵的人生建议2024-02-15把时间当作朋友2023-02-15变态心理学（第6版）2024-06-24社会心理学2024-06-24软件架构基础（影印版）2024-05-26架构整洁之道2024-05-26富妈妈穷妈妈2024-05-26一本书读懂财报2024-05-26财富自由之路2024-05-26投资最重要的事2024-05-26投资中最简单的事2024-05-26彼得·林奇的成功投资2024-05-26聪明的投资者2024-05-26百万富翁快车道2024-05-26穷查理宝典2024-05-26富爸爸，穷爸爸2024-05-26小狗钱钱2024-05-26月亮与六便士2024-04-30给一个未出生孩子的信2024-04-18医生最想让你做的事2024-04-14幸福的家庭2024-04-14通往奴役之路2024-04-14态度改变与社会影响2024-04-13决策与判断2024-04-13影响力2024-04-13亲密关系2024-04-13路西法效应2024-04-13狂热分子2024-04-13社会性动物2024-04-13社会心理学2024-04-13逃避自由2024-04-13与自己和解2024-04-13瓦尔登湖2024-04-05战争与和平2024-04-05论犯罪与刑罚2024-03-30自剖2024-03-23高效能人士的七个习惯2024-03-17详谈：赵鹏2024-03-08权力与繁荣2024-03-07西方哲学史（第9版）2024-03-03与神对话2024-03-03沉思录2024-02-25中国社会各阶层分析报告2024-02-25枪炮、病菌与钢铁2024-02-21乌合之众2024-02-19若干重大决策与事件的回顾（上下卷）2024-02-15东京百年史2024-02-15分布式系统应用设计2024-02-15笔记的方法2024-02-15Redis设计与实现2024-02-15代码整洁之道2024-02-15美丽新世界2024-02-15十日谈：新冠时期故事集2024-02-15十日谈2024-02-15神们自己2024-02-15未来的序曲2024-02-15二十年目睹之怪现状2024-02-15一地鸡毛2024-02-15哲学起步2024-02-15时间从来不语，却回答了所有问题2024-02-15邓小平时代2024-02-15百年孤独2024-02-15高情商沟通2024-02-15人性的弱点2024-02-15浪潮之巅2024-02-15变量2024-02-15曾国藩的正面与侧面2024-02-15亲密关系2024-02-15非暴力沟通2024-02-15心理学与生活（第19版）2024-02-15价值2024-02-15江村经济2024-02-15曾国藩家书2024-02-15唐浩明谈曾国藩齐家之道2024-02-15繁花2024-02-15俞军产品方法论2024-02-15工作、消费主义和新穷人2024-02-15为什么伟大不能被计划2024-02-15沧浪之水2024-02-15繁花2024-02-15认知觉醒2024-02-15北京古迹史话2024-02-15独裁者手册2024-02-15研究的方法2024-02-15学习的方法2024-02-15影响力2024-02-15自我与本我2024-02-15打开心智2024-02-15勤勉的昏君崇祯2023-12-04时间的秩序2023-09-25变量4：大国的腾挪2023-04-27兴盛与危机2023-04-12学会提问 (原书第12版)2023-04-11刀锋2023-04-11爱的艺术2023-04-11批判性思维（原书第5版）2023-04-08沧浪之水2023-03-1521世纪的管理挑战2023-02-27黑客与画家2023-02-27父权制与资本主义2023-02-23公正2023-02-15HBase原理与实践2023-02-15成功，动机与目标2023-02-14中国历代政治得失2023-02-10数据分析之道：用数据思维指导业务实战2023-02-10腾讯传2023-02-10自私的基因2023-02-10华为数字化转型之道2023-02-10华为数据之道2023-02-10数字人文导论2023-02-10王阳明全集2023-02-10逆向管理2023-02-10置身事内2023-02-10TED演讲的秘密2023-02-10向上生长2023-02-10管理的实践2023-02-10影响力2023-02-10卓有成效的管理者2023-02-10要领2023-02-10态度2023-02-10用户体验要素：以用户为中心的产品设计（原书第2版）2023-02-10深层认知2023-02-10见识2023-02-10结构性改革2023-02-10格局2023-02-10联盟2023-02-07领导梯队2023-02-07筚路维艰2022-09-17江村经济2022-09-17万历十五年2022-09-17高塔下的小镇2022-05-14赢2022-03-17钢铁是怎样炼成的2022-03-04永恒的终结2022-03-04包法利夫人2021-12-23影响力2021-11-26最後的問題2021-11-12走出软件作坊2021-10-31人月神话2021-10-31安娜·卡列尼娜2021-10-30资本社会的17个矛盾2020-07-12</code></pre><p>2024年06月24日17:08:59 从onedrive文件夹中直接list，待整理</p><pre><code>├── 方法论│   ├── 35岁前要做的33件事.mobi│   ├── FBI教你破解身体语言（插图版）.mobi│   ├── facebook效应.mobi│   ├── 演讲.docx│   ├── 人件.mobi│   ├── 气场.mobi│   ├── 硬球.mobi│   ├── 面试one.docx│   ├── 影响力.mobi│   ├── 潜规则.mobi│   ├── 打开心智 (李睿秋) (Z-Library).epub│   ├── 尽管去做 ——无压工作的艺术.mobi│   ├── 营销管理(第13版).mobi│   ├── 乌合之众.mobi│   ├── 书读完了.mobi│   ├── 优势谈判.mobi│   ├── 围炉夜话.mobi│   ├── 幸福了吗.mobi│   ├── 醒世恒言.mobi│   ├── 随遇而安_孟非.mobi│   ├── 非暴力沟通 (马歇尔•卢森堡) (Z-Library).epub│   ├── 人性的弱点.mobi│   ├── 心理控制术.mobi│   ├── 麦肯锡方法.mobi│   ├── 演讲与口才.txt│   ├── 我不是教你诈(1－5合集).mobi│   ├── 不生病的智慧.mobi│   ├── 别为小事抓狂.mobi│   ├── 我们如何思维.mobi│   ├── 把时间当朋友.mobi│   ├── 餐巾纸的背面.mobi│   ├── 上班族必懂的office天择定律.mobi│   ├── 宝贵的人生建议 (凯文·凯利) (Z-Library).epub│   ├── 把时间当作朋友(第3版) (李笑来) (Z-Library).epub│   ├── 乔布斯的演讲稿.docx│   ├── 如何阅读一本书.mobi│   ├── 拆掉思维里的墙.mobi│   ├── 遇见未知的自己.mobi│   ├── 免费游戏的陷阱.txt│   ├── 遇见未知的自己.txt│   ├── 好妈妈胜过好老师.mobi│   ├── 怎样说话才打动人.mobi│   ├── 蔡康永的说话之道.mobi│   ├── 按自己的意愿过一生 [王潇]【微信：zsbyg199】.mobi│   ├── 大学生是怎么废掉的.pdf│   ├── 金字塔原理（麦肯锡40年经典培训教材） (芭芭拉·明托) (Z-Library).epub│   ├── 搞定Ⅰ无压工作的艺术(全球工作者都在学习使用的GTD时间管理系统) (戴维·艾伦) (Z-Library).epub│   ├── 每天懂一点色彩心理学.mobi│   ├── 《人性的弱点》完整版.txt│   ├── 当我谈跑步时，我谈些什么.mobi│   ├── 乌合之众——大众心理研究.txt│   ├── 大学只有四年，绝对经不起挥霍.docx│   └── 思考的技术：思考力决定竞争力（节选）.mobi├── 人物传记│   ├── 李鸿章传.mobi│   ├── 王尔德童话.mobi│   ├── 纳兰词笺注.mobi│   └── 乔布斯的魔力演讲.mobi├── 家庭与我│   ├── 中国生育成本报告2022版.pdf│   └── 亲密关系（十周年纪念版） (罗兰·米勒,Rowland S. Miller) (Z-Library).epub├── 政经时闻│   ├── 35岁前要上的33堂理财课.mobi│   ├── Rework － Jason Fried _ Da(和谐)vid Heinemeier Hansson.mobi│   ├── W.钱·金___莫博涅.蓝海战略.mobi│   ├── 价值 (张磊 [张磊]) (Z-Library).epub│   ├── 华尔街.mobi│   ├── 战国策.mobi│   ├── 乡土中国 (费孝通) (Z-Library).epub│   ├── 江村经济 (费孝通) (Z-Library).epub│   ├── 中县干部 (冯军旗) (Z-Library).pdf│   ├── 生育制度 (中学图书馆文库) (费孝通 [费孝通]) (Z-Library).epub│   ├── 《新民说+坐待天明》+作者：许章润.mobi│   ├── 大败局上-吴晓波.txt│   ├── 大败局下-吴晓波.txt│   ├── 万物简史.mobi│   ├── 价格理论.mobi│   ├── 大而不倒.mobi│   ├── 时间简史.mobi│   ├── 浪潮之巅.mobi│   ├── 证券分析.mobi│   ├── 黄金时代.mobi│   ├── 大而不倒.txt│   ├── 浩荡两千年(全文阅读).txt│   ├── 东京百年史.mobi│   ├── 十亿消费者.mobi│   ├── 卢瑟经济学.mobi│   ├── 推销员之死.mobi│   ├── 时代三部曲.mobi│   ├── 浩荡两千年.mobi│   ├── 激荡三十年.mobi│   ├── 贫穷的本质.mobi│   ├── 跌荡一百年.mobi│   ├── 金融的逻辑.mobi│   ├── 推销员之死.txt│   ├── 贫穷的本质.txt│   ├── 跌荡一百年.txt│   ├── 毛泽东选集1-5（全）.rar│   ├── 毛泽东选集_1-5卷.mobi│   ├── 通往奴役之路(全文阅读).txt│   ├── 上帝掷骰子吗.mobi│   ├── 大败局（上）.mobi│   ├── 大败局（下）.mobi│   ├── 富爸爸穷爸爸.mobi│   ├── 通往奴役之路.mobi│   ├── 富爸爸穷爸爸.txt│   ├── 《浪潮之巅》TXT下载（全本）作者：吴军.txt│   ├── 原来这才是春秋.mobi│   ├── 曼昆经济学原理.mobi│   ├── 朱镕基答记者问.mobi│   ├── 牛奶可乐经济学.mobi│   ├── 我们台湾这些年_讲述台湾老百姓自己的故事.mobi│   ├── 中国历代政治得失 (钱穆) (Z-Library).epub│   ├── 历代经济变革得失 - 吴晓波.mobi│   ├── 活着就为改变世界.mobi│   ├── 中国生育成本报告2022版.pdf│   ├── 历史是个什么玩意儿.mobi│   ├── 格雷厄姆论价值投资.mobi│   ├── 谷歌吴军：数学之美.mobi│   ├── 资治通鉴（柏杨版）.mobi│   ├── 毛泽东选集（第一卷）.mobi│   ├── 毛泽东选集（第三卷）.mobi│   ├── 毛泽东选集（第二卷）.mobi│   ├── 毛泽东选集（第四卷）.mobi│   ├── 从总体支配到技术治理_基于中国30年改革经验的社会学分析_渠敬东.caj│   ├── 八次危机中国的真实经验 (温铁军) (Z-Library).epub│   ├── 东京百年史：从江户到昭和-爱德华·赛登施蒂克.txt│   ├── 为什么中国人勤劳而不富有.mobi│   ├── 经济学的思维方式（节选）.mobi│   ├── 置身事内：中国政府与经济发展 (兰小欢) (Z-Library).epub│   ├── 财务自由之路系列（全六册）【全球销量1000万册，连续110周雄居德国图书排行榜榜首！】 (博多·舍费尔) (Z-Library).epub│   ├── 哈耶克作品集：通往奴役之路自由宪章致命的自负 ([英]哈耶克) (Z-Library).mobi│   └── 独裁者手册：为什么坏行为几乎总是好政治（补全版） (布鲁斯·布鲁诺·德·梅斯奎塔,阿拉斯泰尔·史密斯) (Z-Library).epub├── 文法哲史│   ├── MaSiLuo.pdf│   ├── [新世纪万有文库]理想丈夫与不可儿戏-王尔德的两出喜剧.余光中译.辽宁教育出版社(1998).pdf│   ├── [外国名人书话系列]王尔德读书随笔[爱尔兰]王尔德.张介明译.上海三联书店(1999).pdf│   ├── 论语.mobi│   ├── 散文诗.docx│   ├── 巨婴国.mobi│   ├── 叫魂：1768年中国妖术大恐慌.epub│   ├── 食南之徒 (马伯庸) (Z-Library).epub│   ├── 乐府诗集.mobi│   ├── 警世通言.mobi│   ├── 论语全解.mobi│   ├── 社会转型_发展社会学的新议题_孙立平.caj│   ├── 变态心理学.azw3│   ├── 论美国的民主.mobi│   ├── 马斯洛人本哲学 (马斯洛 [马斯洛]) (Z-Library).epub│   ├── 道德经古今正解.mobi│   ├── 郑渊洁童话全集.mobi│   ├── 郑渊洁童话全集.txt│   ├── 对重刑主义的忧思_顾德瑞.caj│   ├── 二十年目睹之怪现状.mobi│   ├── 笔杆子、画笔和毒药[爱尔兰]王尔德.杨东霞、罗汉等译.浙江文艺出版社(2007).pdf│   ├── 作为意志和表象的世界.mobi│   ├── 怪诞行为学（升级版）.mobi│   ├── 两极化刑事政策之批判_黄华生.caj│   ├── 对我国重刑主义的反思_胡学相.caj│   ├── 作为意志和表象的世界_叔本华.txt│   ├── 东京百年史从江户到昭和1867-1989 (爱德华·赛登施蒂克, 谢思远, 刘娜) (Z-Library).epub│   ├── 法家重刑思想的逻辑分析_霍存福.caj│   ├── 崇祯往事：明帝国最后的图景（禁书 崇祯：勤政的亡国君 第一版） (陈梧桐) (Z-Library).epub│   └── 给一个未出生孩子的信（剖心之作，一个女人献给世界上所有女人的书，也是一个女人献给世界上所有“男人”的书 理想国出品） (奥丽娅娜·法拉奇) (Z-Library).epub├── 编程能力│   ├── 1097825528836019620.JPG│   ├── 11936297069687671408.PNG│   ├── 13577974351240529508.JPG│   ├── 2022-故障全流程及处理规范宣讲.pptx│   ├── 20220311——AIT.pptx│   ├── 2022年语音语言技术部质量宣讲.pdf│   ├── 21年至今故障整理-先刚老师.pptx│   ├── 51CTO下载-SQL学习指南(第2版).pdf│   ├── BRPC开发手册.pdf│   ├── C++ Primer Plus（第6版）_中文版_带书签_超清.pdf│   ├── C++ Primer（第5版）_带书签_高清完整版.pdf│   ├── C++ 程序设计语言：第1~3部分（原书第4版）.pdf│   ├── C++ 程序设计语言：第4部分 标准库（原书第4版）.pdf│   ├── C++编程思想（两卷合订本）.pdf│   ├── DevOps软件架构师行动指南@www.java1234.com.pdf│   ├── FunctionalProgrammingForTheRestOfUs.cn.md│   ├── Getting Real － 37signals.mobi│   ├── Go工程效率实践.pptx│   ├── LeetCode 101 - A LeetCode Grinding Guide (C++ Version).pdf│   ├── Linux基础知识体系图│   │   ├── 1 基础篇.png│   │   ├── 2 系统操作篇.png│   │   ├── 3 系统管理篇.png│   │   ├── 4 Shell篇.png│   │   ├── 5 文本操作篇.png│   │   ├── 6 服务管理篇.png│   │   └── 完整版-Linux基础知识体系.png│   ├── Linux多线程服务端编程使用muduo C++网络库 (陈硕 [陈硕]) (Z-Library).epub│   ├── MySQL最佳实践.pdf│   ├── Redis设计与实现 (黄健宏) (Z-Library).epub│   ├── Spring揭秘.pdf│   ├── [代码整洁之道].(美)马丁.扫描版.pdf│   ├── deloitte-cn-innovation-conversational-ai-is-reshaping-the-human-machine-interac.pdf│   ├── designpatterns1.jpg│   ├── designpatterns2.jpg│   ├── game-programmer-zh-cn.pdf│   ├── modern-cpp-tutorial-zh-cn.pdf│   ├── mysql5.7-manual-en.a4.pdf│   ├── zh-google-styleguide-20220529.pdf│   ├── 剑指OFFER  名企面试官精讲典型编程题  第2版.pdf│   ├── 设计模式.jpg│   ├── 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） 周志明.pdf│   ├── 代码整洁之道 (马丁(Robert C. Martin)) (Z-Library).epub│   ├── 【买卖真房源】400语音识别宣导材料-20220222.pptx│   ├── 杂事中的小幸福_傅昆.pptx│   ├── 服务云技术方案评审-0710.pptx│   ├── 小贝训练场用户手册0222.pptx│   ├── 【云课堂】第七期第2讲《顺风车稳定性实践》.pdf│   ├── 服务稳定性建设教科书-贝壳语音.pdf│   ├── 推荐系统总结思维导图.jpg│   ├── 数据密集型应用系统设计 (Martin Kleppmann) (Z-Library).epub│   ├── 家装现场委托标准作业规范_1027.pptx│   └── 凤凰架构：构建可靠的大型分布式系统 (周志明) (Z-Library).epub├── 行业研究│   ├── 银行数字化转型(一部指导银行业进行数字化转型的方法论著作，为银行的数字化转型给出了完整的方案。) (付晓岩 [付晓岩]) (Z-Library).epub│   ├── 神经网络与深度学习 (邱锡鹏) (Z-Library).pdf│   ├── 华为数字化转型之道 (华为公司企业架构与变革管理部) (Z-Library).epub│   └── 俞军产品方法论（互联网产品界里程碑式作品，产品经理进阶读物。字节跳动CEO张一鸣、百度CTO刘建国鼎力推荐。） (俞军 [俞军]) (Z-Library).epub├── 通俗文学│   ├── 围城.TXT│   ├── 孟子.mobi│   ├── 道连·葛雷的画像[爱尔兰]王尔德.荣如德译.上海译文出版社(2006).pdf│   ├── 全宋词.mobi│   ├── 沉思录.mobi│   ├── 钱锺书.宋诗选注.mobi│   ├── 狱中记[爱尔兰]王尔德.孙宜学译.南海出版公司(1998).pdf│   ├── 沧浪之水 (阎真) (Z-Library).epub│   ├── 百年孤独 (根据马尔克斯指定版本翻译,未做任何增删) (加西亚•马尔克斯, 范晔) (Z-Library).epub│   ├── 人类简史.mobi│   ├── 太平广记.mobi│   ├── 浮生六记.mobi│   ├── 浮生六记.txt│   ├── 李嘉诚的7封信.docx│   ├── 曾国藩家书 - 曾国藩.mobi│   ├── 唐诗三百首.mobi│   ├── 病菌与钢铁.mobi│   ├── 社会契约论.mobi│   ├── 王尔德全集.第1卷.小说童话.荣如德、巴金等译.pdf│   ├── 王尔德全集.第2卷.戏剧.王阳等译.pdf│   ├── 王尔德全集.第3卷.诗歌.杨烈、黄杲炘等译.pdf│   ├── 王尔德全集.第4卷.评论随笔.杨东霞、杨烈等译.pdf│   ├── 王尔德全集.第5卷.书信-上.苏福忠、高兴等译.pdf│   ├── 王尔德全集.第6卷.书信-下.常绍民、沈弘等译.pdf│   ├── 王尔德诗选[英]王尔德.袁宪军译.福建教育出版社(2010).pdf│   ├── 灵魂的毁灭[爱尔兰]王尔德.姜允麟译.黑龙江人民出版社(1988).pdf│   ├── 世说新语译注.mobi│   ├── 仓央嘉措诗集.mobi│   ├── 老子白话今译.mobi│   ├── 王尔德喜剧选[爱尔兰]王尔德.张南峰译.海峡文艺出版社(1990).pdf│   ├── 王尔德作品集[爱尔兰]王尔德.黄源深等译.人民文学出版社(2001).pdf│   ├── 唐诗三百首补注.mobi│   ├── 百家讲坛－和珅.mobi│   ├── 百家讲坛－水浒.mobi│   ├── 百家讲坛－老子.mobi│   ├── 假如给我三天光明.mobi│   ├── 百家讲坛－多尔衮.mobi│   ├── 百家讲坛－讲聊斋.mobi│   ├── 百家讲坛－读史记.mobi│   ├── 假如给我三天光明.txt│   ├── 枪炮、病菌与钢铁.txt│   ├── 曾国藩的正面与侧面 完整版.mobi│   ├── 百家讲坛－二战风云.mobi│   ├── 百家讲坛－动物世界.mobi│   ├── 百家讲坛－大师语录.mobi│   ├── 百家讲坛－明十七帝.mobi│   ├── 百家讲坛－清十二帝.mobi│   ├── 百家讲坛－生活保健.mobi│   ├── 百家讲坛－科技之光.mobi│   ├── 百家讲坛－笑书神侠.mobi│   ├── 百家讲坛－艺术漫谈.mobi│   ├── 百家讲坛－教育与成功.mobi│   ├── 百家讲坛－经济与社会.mobi│   ├── 百家讲坛－道德与法律.mobi│   ├── 社会契约论〔法〕卢梭.txt│   ├── 百家讲坛－刘心武谈红楼.mobi│   ├── 百家讲坛－历史与文化篇.mobi│   ├── 百家讲坛－外国文艺欣赏.mobi│   ├── 百家讲坛－金正昆谈礼仪.mobi│   ├── 易中天：先秦诸子百家争鸣.mobi│   └── 谎言的衰落：王尔德艺术批评文选.萧易译.江苏教育出版社(2004).pdf</code></pre>]]></content>
      
      
      <categories>
          
          <category> 书单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交互式提示工程入门</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用chatgpt-4omini做测试 <a href="https://chatgpt.com/">https://chatgpt.com/</a></p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-26 11:07:47 最初来自眼镜交互场景。应邹伟要求，沉淀一波，搞个口语交互场景下的prompt经验分享</p><p>2024-08-26 11:08:28 参考资料</p><ol><li><strong>Anthropic：从入门到精通交互式提示工程教程</strong> <a href="https://github.com/anthropics/prompt-eng-interactive-tutorial">https://github.com/anthropics/prompt-eng-interactive-tutorial</a></li><li>发行说明 <a href="https://docs.anthropic.com/en/release-notes/system-prompts">https://docs.anthropic.com/en/release-notes/system-prompts</a></li><li><strong>the art of asking chatgpt for high-quality answers</strong> <a href="https://book.xindoo.xyz/The%20Art%20of%20Asking%20ChatGPT%20for%20High-Quality%20Answ...%20%28Z-Library%29.pdf">https://book.xindoo.xyz/The%20Art%20of%20Asking%20ChatGPT%20for%20High-Quality%20Answ...%20%28Z-Library%29.pdf</a></li><li><strong>ChatGPT 中文调教指南</strong>。各种场景使用指南。学习怎么让它听你的话。 <a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh">https://github.com/PlexPt/awesome-chatgpt-prompts-zh</a></li><li>吴恩达 x Open AI ChatGPT 提示工程教程 <a href="https://www.bilibili.com/list/15467823?sid=3247315&desc=1&oid=783015669&bvid=BV1s24y1F7eq">https://www.bilibili.com/list/15467823?sid=3247315&amp;desc=1&amp;oid=783015669&amp;bvid=BV1s24y1F7eq</a></li><li>尚尔昕的分享资料 how_to_use_chatgpt.pptx</li><li>其他资料。搜索 Prompt engineering</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习部署入门</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%A8%A1%E6%80%81/202408%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%83%A8%E7%BD%B2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="推理部署综述"><a href="#推理部署综述" class="headerlink" title="推理部署综述"></a>推理部署综述</h1><p>模型部署的步骤：</p><ol><li>训练一个深度学习模型；</li><li>使用不同的推理框架对模型进行推理转换；</li><li>在应用平台运行转换好的模型。</li></ol><p><strong>实际应用场景往往需要模型速度与精度能达到一个较好的平衡。因此这就需要在算法（剪枝，压缩等）与底层（手写加速算作）去优化模型。</strong></p><h1 id="模型格式介绍"><a href="#模型格式介绍" class="headerlink" title="模型格式介绍"></a>模型格式介绍</h1><ol><li>PyTorch (.pth&#x2F;.pt): 这种格式是PyTorch的原生格式，主要用于保存和加载PyTorch模型。</li><li>ONNX (Open Neural Network Exchange): 这是一个开放的模型表示格式，允许在不同的深度学习框架之间交换模型，如PyTorch、TensorFlow、Caffe2等。</li><li>TensorRT (TRT): TensorRT是一个深度学习模型优化器和运行时，主要用于加速模型的推理。TRT格式是为NVIDIA GPU优化的，并且经过了量化、层融合和其他优化。<strong>使用TensorRT优化的模型通常在NVIDIA GPU上有更快的推理速度。这是因为TensorRT会进行很多针对性能的优化。</strong></li></ol><p>通常，你可能首先从PyTorch转换为ONNX，然后从ONNX转换为TensorRT格式，尽管也有直接从PyTorch到TensorRT的工具和方法。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><ol><li>PyTorch: 由于它是PyTorch的原生格式，所以它与PyTorch高度兼容。</li><li>ONNX: 设计为跨框架的，但<strong>并不是所有的模型和操作都能轻松地转换为ONNX或从ONNX转换</strong>。</li><li>TensorRT: 主要为NVIDIA GPU优化，对于使用不支持的层或操作的模型，可能需要额外的工作来进行转换。</li></ol><h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><p>开放神经网络交换ONNX（Open Neural Network Exchange）是一套表示深度神经网络模型的开放格式，由微软和Facebook于2017推出，然后迅速得到了各大厂商和框架的支持。通过短短几年的发展，<strong>已经成为表示深度学习模型的实际标准，并且通过ONNX-ML，可以支持传统非神经网络机器学习模型，大有一统整个AI模型交换标准</strong>。ONNX定义了一组与环境和平台无关的标准格式，为AI模型的互操作性提供了基础，使AI模型可以在不同框架和环境下交互使用。硬件和软件厂商可以基于ONNX标准优化模型性能，让所有兼容ONNX标准的框架受益，简单来说，ONNX就是模型转换的中间人。</p><h2 id="TensorRT"><a href="#TensorRT" class="headerlink" title="TensorRT"></a>TensorRT</h2><p>NVIDIA TensorRT™ 是用于高性能深度学习推理的 SDK。此 SDK 包含深度学习推理优化器和运行时环境，可为深度学习推理应用提供低延迟和高吞吐量。</p><p>在推理过程中，<strong>基于 TensorRT 的应用程序的执行速度可比 CPU 平台的速度快 40 倍</strong>。借助 TensorRT，您可以优化在所有主要框架中训练的神经网络模型，精确校正低精度，并最终将模型部署到超大规模数据中心、嵌入式或汽车产品平台中。<br>TensorRT 针对多种深度学习推理应用的生产部署提供 INT8 和 FP16 优化，例如视频流式传输、语音识别、推荐和自然语言处理。推理精度降低后可显著减少应用延迟，这恰巧满足了许多实时服务、自动和嵌入式应用的要求。</p><p><strong>模型可以通过onnx格式转换成TensorRT格式后，使用 NVIDIA Triton 推理服务器完成部署</strong></p><h1 id="TensorRT-LLM"><a href="#TensorRT-LLM" class="headerlink" title="TensorRT-LLM"></a>TensorRT-LLM</h1><p>TensorRT-LLM是NV发布的一个推理引擎。llm被编译成TensorRT后与triton服务器一起部署并支持多GPU-多节点推理和FP8。</p><h1 id="LMDeploy"><a href="#LMDeploy" class="headerlink" title="LMDeploy"></a>LMDeploy</h1><p>(<a href="https://github.com/InternLM/lmdeploy">https://github.com/InternLM/lmdeploy</a>)</p><p>LMDeploy 是一个 Python 库，<strong>用于压缩、部署和服务大型语言模型 （LLM） 和视觉语言模型 （VLM）</strong>。 其核心推理引擎包括 TurboMind Engine 和 PyTorch Engine。前者由 C++ 和 CUDA 开发，力求最终优化推理性能，而后者则纯粹使用 Python 开发，旨在为开发人员减少门槛。</p><p>它支持在 Linux 和 Windows 平台上部署 LLM 和 VLM，最低要求 CUDA 版本 11.3。</p><p>LMDeploy允许压缩、部署和服务llm，同时提供高效的推理(持久批处理、阻塞KV缓存、动态分裂和融合、张量并行、高性能CUDA内核)、有效的量化(4位推理性能比FP16高2.4倍)。跨多台机器和GPU部署多模型服务。此外，它还允许分析令牌延迟和吞吐量、请求吞吐量、API服务器和triton推理服务器性能。</p><p>可以很简单的支持server部署，提供类似openai的接口</p><h1 id="VLLM"><a href="#VLLM" class="headerlink" title="VLLM"></a>VLLM</h1><p>vLLM提供LLM推理和服务，<strong>具有SOTA吞吐量，分页注意力，连续批处理，量化(GPTQ, AWQ, FP8)的支持和优化的CUDA内核</strong>。</p><p>支持各种生成式 Transformer 模型。 <a href="https://docs.vllm.ai/en/stable/models/supported_models.html">https://docs.vllm.ai/en/stable/models/supported_models.html</a><br>另外还支持transformer模型的自我定制。 <a href="https://docs.vllm.ai/en/stable/models/adding_model.html">https://docs.vllm.ai/en/stable/models/adding_model.html</a></p><p><strong>暂不支持whisper</strong></p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>从官方文档上可以看出，支持的事常见的大语言模型和多模态大模型，并不支持传统的Torch模型 <a href="https://lmdeploy.readthedocs.io/en/latest/supported_models/supported_models.html">https://lmdeploy.readthedocs.io/en/latest/supported_models/supported_models.html</a></p><h1 id="Chinese-CLIP"><a href="#Chinese-CLIP" class="headerlink" title="Chinese-CLIP"></a>Chinese-CLIP</h1><p>需求的起源是基于Chinese-CLIP训练的模型。产出是Torch类型的模型，所以最差情况下可以直接Torch.run。同时也<strong>支持将各规模的Pytorch模型，转换为ONNX或TensorRT格式</strong> <a href="https://github.com/OFA-Sys/Chinese-CLIP/blob/master/deployment.md">https://github.com/OFA-Sys/Chinese-CLIP/blob/master/deployment.md</a></p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-27 19:39:16 原因是有几个图像模型需要上线。经过调研有三种方式：</p><ol><li>交付冯亮，以离线任务封装。优势是可以尝试利用spark集群的CPU资源，劣势是仅有的GPU来自AIT，不确定归还时间。所以作为长期跑大量数据无固定交付时间的的候选方案</li><li>在方阳aistudio（2.0）平台上自建空间。需要有组内独占的GPU资源，因为xyz的GPU卡都由彭一平管理，所以不可行</li><li>交付一平手动部署，隐藏与aistudio交互的细节。然后自建调度任务</li></ol><p>不管哪种方案，都需要了解模型的推理部署框架，以便与部署层沟通。</p><p>2024-08-27 19:53:09 看起来vllm和lmdeploy都不太支持语音模型和传统的图像模型，比如whisper</p><p>2024-08-27 19:57:06 AI模型部署落地综述（ONNX&#x2F;NCNN&#x2F;TensorRT） <a href="https://www.jianshu.com/p/4e74a7c1a6f1">https://www.jianshu.com/p/4e74a7c1a6f1</a></p><p>2024-08-27 20:18:05 TODO 一篇就够：高性能推理引擎理论与实践 (TensorRT) <a href="https://developer.aliyun.com/article/995926">https://developer.aliyun.com/article/995926</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓开发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="按钮高亮效果研究"><a href="#按钮高亮效果研究" class="headerlink" title="按钮高亮效果研究"></a>按钮高亮效果研究</h1><p>主要需求是在按钮获取焦点时，有一个高亮效果，当然动画效果更好 可能有如下几个方案</p><ol><li>使用简单动画<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">alphaAnimation</span> <span class="operator">=</span> AnimationUtils.loadAnimation(<span class="built_in">this</span>, R.anim.btn_alpha_effect);</span><br></pre></td></tr></table></figure>优势是可以不用setBackground，因为有个按钮有三种状态，所以使用setBackground需要进行复杂的状态控制；可以随时绑定和取消；劣势是只能使用简单动画，比如呼吸灯效果，缩放效果</li></ol><h1 id="使用火山引擎的识别和合成能力"><a href="#使用火山引擎的识别和合成能力" class="headerlink" title="使用火山引擎的识别和合成能力"></a>使用火山引擎的识别和合成能力</h1><p>提供了SDK。<br>ASR <a href="https://www.volcengine.com/docs/6561/113642">https://www.volcengine.com/docs/6561/113642</a><br>TTS <a href="https://www.volcengine.com/docs/6561/79834">https://www.volcengine.com/docs/6561/79834</a></p><p>需要注意的是，ASR时如果选择 <code>RECORDER_TYPE_RECORDER</code>(内置录音机)，就不要再用demo里的SpeechStreamRecorder再自行录音并调用Engine.feedAudio，后者对应于 <code>RECORDER_TYPE_STREAM</code> (外部PCM音频流)。也就是说识别的SDK中，硬件和交互本身就是解耦的</p><p>同样，TTS也可以禁止SDK直接使用系统播放器 <code>PARAMS_KEY_TTS_ENABLE_PLAYER_BOOL</code> ，而是获取到录音数据后自行使用播放器播放</p>]]></content>
      
      
      <categories>
          
          <category> 前端与小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macbook电脑配置</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/macbook%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/macbook%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Macbook-iOS"><a href="#Macbook-iOS" class="headerlink" title="Macbook(iOS)"></a>Macbook(iOS)</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>2024年06月30日13:42:52 不要企图使用u盘把mac电脑的资料导出。经常会出现错误弹出，导致u盘损坏。更多的通过网络的方式，比如笔记、onedrive、网盘，兜底的情况下使用smb与Windows连接互传，之后再使用u盘</p><h2 id="目录环境备份"><a href="#目录环境备份" class="headerlink" title="目录环境备份"></a>目录环境备份</h2><p>.<br>├── Applications  # 应用目录<br>├── Desktop # 临时存放位置，随时可删除<br>├── Documents # 文稿。待整理到Onedrive等<br>├── Downloads # 下载。为了方便下载加速，空间充足时可以暂时不动<br>├── Library<br>├── Movies  # 可能有些测试文件，随时可删除<br>├── Music  # 可能有些测试文件，随时可删除<br>├── OneDrive -&gt; &#x2F;Users&#x2F;niuqiang&#x2F;Library&#x2F;CloudStorage&#x2F;OneDrive-个人<br>├── Pictures  # 临时图片，随时可删除<br>├── Public<br>├── go<br>├── iBook  # 博客工作区，方便直接用vsc打开整个文件夹。随时同步，随时可删除<br>├── node_modules<br>├── openCode # 下载的代码。为了方便下载加速，空间充足时可以暂时不动<br>    ├── openCxx<br>    ├── openJava<br>    ├── openPython<br>    ├── openShell<br>    ├── openTools<br>    ├── openUI<br>    ├── opengolang<br>    └── ruoyi<br>└── workspace # 代码工作区，方便直接用vsc打开整个文件夹。这里每次同步需要手动压缩打包，然后使用smb传输到windows电脑<br>    ├── AwesomeCxx<br>    ├── AwesomeGolang<br>    ├── AwesomeJava<br>    ├── AwesomePython<br>    ├── AwesomeShell<br>    └── AwesomeUI</p><h2 id="软件列表备份"><a href="#软件列表备份" class="headerlink" title="软件列表备份"></a>软件列表备份</h2><p>2024年06月06日11:59:34<br>$ ls -hal &#x2F;Applications&#x2F;</p><pre><code>Another Redis Desktop Manager.appAudacity.appBaiduNetdisk.appClashX.appDocker.appDoubao.appEasyConnect.appGoogle Chrome.appHBuilderX.appIntelliJ IDEA CE.appKeePassium.appLark.appMicrosoft Edge.appMySQLWorkbench.appOneDrive.appPhotoScapeX.appPostman.appPyCharm CE.appQQ.appQQMusic.appSafari.appSmart Countdown Timer.appSourcetree.appTencent Lemon Lite.appTencentMeeting.appThunder.appUtilitiesVisual Studio Code - Insiders.appVisual Studio Code.appWeChat.appWireshark.appdraw.io.appiShot.appiTerm.appsogou_mac_615a.appwechatwebdevtools.appwpsoffice.app抖音.app万年历.app企业微信.app有道云笔记.app网易有道翻译.app</code></pre><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><p>2024年06月27日08:59:13 首先尽量不要使用homebrew，这是一个第三方的包管理工具，可能随着系统升级遇到奇奇怪怪的问题</p><p>2021年04月05日11:58:28 安装homebrew<br><a href="https://github.com/cunkai/HomebrewCN">https://github.com/cunkai/HomebrewCN</a><br>&#x2F;bin&#x2F;zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh</a>)”</p><p>(Mac下Homebrew更新国内源brew update卡死)[<a href="https://cloud.tencent.com/developer/article/1817647]">https://cloud.tencent.com/developer/article/1817647]</a><br>export HOMEBREW_NO_INSTALL_FROM_API&#x3D;1</p><p>2024年06月27日09:12:48 如果 Homebrew 遇到问题，可以先尝试执行以下步骤：</p><ol><li>首先，运行 brew doctor 命令查看问题并按照指示进行修复。</li><li>然后，执行 brew update-reset 将 Homebrew 还原到稳定版本。</li><li>最后，运行 brew update 命令来更新软件包。</li></ol><p>2024年06月28日17:10:01 使用brew安装的软件包：brew install ctags tree wget rename ffmpeg graphviz python3 java cmake vim kcat git-lfs</p><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><p>2024年06月27日09:15:51 卸载旧node环境</p><ol><li><p>brew uninstall node</p></li><li><p>npm uninstall npm -g</p></li><li><p>强制删除残留</p><pre><code> sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*  sudo rm -rf /usr/local/include/node /Users/$USER/.npm  sudo rm /usr/local/bin/node  sudo rm /usr/local/share/man/man1/node.1  sudo rm /usr/local/lib/dtrace/node.d</code></pre></li></ol><p>2024年06月27日09:14:20 使用nvm工具管理node。</p><ol><li>一行命令即可安装node和npm：curl -o- <a href="https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh">https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh</a> | bash</li><li>nvm install node</li></ol><p>2024-07-03 14:51:40 解决国内npm速度慢的问题</p><ol><li>npm config set registry <a href="https://mirrors.cloud.tencent.com/npm">https://mirrors.cloud.tencent.com/npm</a> 切换腾讯云</li><li>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org</a> 源站备份</li><li>npm config get registry 验证</li></ol><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><strong>mac系统自带vim不支持粘贴板</strong>，可以用vim –version 查看到-clipboard。这个时候使用brew install vim –with-lua –with-override-system-vi –with-python3安装第二个vim，不要动受系统监管的vim。然后使用alias将vim设置别名</p><blockquote><p>2024年07月03日14:05:00 mac自带的vim已支持剪切板</p></blockquote><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>2024-07-04 11:56:14 sh -c “$(curl -fsSL <a href="https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh">https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</a>)”</p><p>2024-07-04 11:57:29 git clone –depth 1 <a href="https://github.com/junegunn/fzf.git">https://github.com/junegunn/fzf.git</a> ~&#x2F;.fzf<br>~&#x2F;.fzf&#x2F;install<br>2. </p><h2 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h2><p>2024-07-03 14:05:38 设置时间格式。偏好设置&gt;高级&gt;输入扩展&gt; 自定义短语设置</p><blockquote><p>#$year-$month_mm-$day_dd $fullhour:$minute:$second<br>移动端好像做不到</p></blockquote><h2 id="密码本app"><a href="#密码本app" class="headerlink" title="密码本app"></a>密码本app</h2><p>2024年07月01日11:17:34 keepassium。使用onedrive中的文件达成多端自动同步</p><ol><li>应用解锁密码 1****6</li><li>文件锁密码 1****6</li></ol><h2 id="倒计时APP"><a href="#倒计时APP" class="headerlink" title="倒计时APP"></a>倒计时APP</h2><p>2024年06月06日10:32:33 我的需求是可以在状态栏显示剩余时间，并且直接操作启停，到时间有弱提醒</p><ol><li>Onigiri。App Store下载，能很好满足需求，但是过一段时间之后就强制购买</li><li><a href="https://github.com/ivoronin/TomatoBar">https://github.com/ivoronin/TomatoBar</a> 不能随意修改倒计时时间，而只能管理工作时间和间隔</li><li>focus work and study timer。只能使用25分钟的计时器，修改间隔另外收费</li><li>tomito。没有任务栏倒计时。</li><li>Timer Rh。没有任务栏倒计时</li><li>Horo。App Store下载，能很好满足需求，稍微美中不足的是很容易同时开启多个</li><li><strong>Smart CountDown Timer</strong>。App Store下载，能很好满足需求，图标比Horo好看，并且很容易复用同一个时钟</li></ol><h2 id="浏览器选择"><a href="#浏览器选择" class="headerlink" title="浏览器选择"></a>浏览器选择</h2><p>2021年11月22日12:23:25 </p><ol><li>【edge】。<strong>工作使用。标签分组，不活动网页省电，多端同步，极速打开</strong></li><li>【safari】，不跨平台；没有太大毛病，但是标签缩略图不如edge的标题好用；苹果系列的默认浏览器，<strong>手机上的标签可以左右滑动是个亮点</strong>，所以生活中临时使用；</li><li>【360chrome】。not bad。serve me well。360可能存在证书欺诈。没有linux版本。mac比较好用的国产浏览器，跟PC端基本一致，但是grafana已经不支持了。<strong>唯一还支持视频独立窗口播放的浏览器</strong></li><li>firefox。有linux版本，可以轻松同步。缺点：简陋，启动慢，页面渲染bug太多了。没有用武之地了</li><li>chrome：浏览器的代表。但是因为不能登录谷歌所以不能同步书签。只能调试用</li><li>世界之窗：速度超快，超简洁。已经许久不更新，不支持插件，内核版本已逐渐不被支持。360的儿子，不支持固定九宫格。简化版的360，不如说是360极速的前身</li></ol><p>2021年11月11日12:03:55 <strong>浏览器统一使用edge</strong>，分组功能非常好用。不能使用360极速了，已经不支持grafana了</p><p>2024年06月19日11:57:02 EDGE插件：</p><ol><li>smartUp手势</li><li>Web Highlights - PDF &amp; Web Highlighter</li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol><li>vs开发Python不要尝试了，不能自动补全、反应速度超慢、intellisense感知不全经常失误，没有pep8</li><li>eclipse + pydev连提示都没有</li><li><strong>IntelliJ Pycharm Community</strong>。最终选用pycharm 社区版，跨平台，可以商用。天下无双。不用再试其他的了</li><li>在官网下载安装到系统 <a href="https://www.python.org/downloads/macos/">https://www.python.org/downloads/macos/</a></li></ol><p>使用Anaconda管理python版本</p><h2 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul><li>visual studio 宇宙最强IDE，Windows下首选。结合远程调试，可以给Linux C++ 提供一种解决方案。</li><li>Visual C++ for Linux 有一个致命问题：项目管理经常崩溃，导致编译时总是找不到文件</li><li>codeblocks在windows下表现与visual C++ 不同，即使调用msvc，也会某些情况下出现编译失败，而且老出前期百怪的问题。。智能提示还好，感知基本没有，语法错误统统不检查；codeblocks只能使用cbp项目文件，不能使用autoconf、make或者cmake的项目文件，而且也没法转换</li><li><strong>现阶段使用vscode+插件可以很好的满足本地和远程开发的情况</strong></li><li>或者eclipse for C++。只能使用gcc编译。而且不是自带gdb。也是一种好的解决方案，但是问题繁多，曲线陡峭<br>CDT的智能感知太弱了，基本不可用的地步</li><li>Clion只支持mingw和cygwin. 只能使用cmake。而且收费</li><li>qt，跨平台C++ IDE。但是对一般性Cpp项目不太友善。qmake毕竟没有cbp通用好懂。没有自带编译环境，需要转接层</li><li>NetBeans和eclipse是基于虚拟机的</li></ul><h3 id="关于vscode"><a href="#关于vscode" class="headerlink" title="关于vscode"></a>关于vscode</h3><p>2018年11月22日09:42:41 配置vscode C++开发环境<br>遇到问题1：只能使用lldb不能使用gdb：<br>问题2：lldb调试不触发断点直接运行结束，可能与这个有关<br>error: No selected frame to use to find the default file.<br>error: No file supplied and no default file available.<br>问题2是因为没有设置编译选项-g</p><h3 id="vscode配置"><a href="#vscode配置" class="headerlink" title="vscode配置"></a>vscode配置</h3><p>2021年10月18日11:08:18 vscode myblog插件配置<br>milkdown<br>Markdown PDF<br>Snazzy Light<br>$ ll &#x2F;Users&#x2F;niuqiang&#x2F;.vscode&#x2F;extensions<br>total 0<br>gera2ld.markmap-vscode-0.0.10<br>loilo.snazzy-light-1.3.0<br>mirone.milkdown-0.0.12<br>yzhang.markdown-all-in-one-3.4.0</p><p>2021年10月18日11:38:11 vscode-insider 插件配置<br>$ ll &#x2F;Users&#x2F;niuqiang&#x2F;.vscode-insiders&#x2F;extensions<br>total 0<br>aaron-bond.better-comments-2.1.0<br>adamhartford.vscode-base64-0.1.0<br>alefragnani.bookmarks-13.2.2<br>alefragnani.project-manager-12.4.0<br>bbenoist.doxygen-1.0.0<br>coenraads.bracket-pair-colorizer-1.0.62<br>cschlosser.doxdocgen-1.3.2<br>eamodio.gitlens-11.7.0<br>foxundermoon.shell-format-7.2.2<br>github.vscode-pull-request-github-0.34.3<br>golang.go-0.30.0<br>golang.go-0.31.0<br>grapecity.gc-excelviewer-4.1.52<br>jeff-hykin.better-cpp-syntax-1.15.10<br>jeff-hykin.better-cpp-syntax-1.15.11<br>mohsen1.prettify-json-0.0.3<br>ms-vscode-remote.remote-containers-0.215.0<br>ms-vscode-remote.remote-containers-0.216.0<br>ms-vscode-remote.remote-ssh-0.70.0<br>ms-vscode-remote.remote-ssh-edit-0.70.0<br>ms-vscode-remote.remote-wsl-0.64.2<br>ms-vscode.cmake-tools-1.9.2<br>ms-vscode.cpptools-1.8.0<br>ms-vscode.cpptools-1.8.3<br>ms-vscode.cpptools-extension-pack-1.1.0<br>ms-vscode.cpptools-themes-1.0.0<br>ms-vsliveshare.vsliveshare-1.0.5273<br>ms-vsliveshare.vsliveshare-1.0.5330<br>ms-vsliveshare.vsliveshare-audio-0.1.91<br>msyrus.go-doc-1.0.1<br>teabyii.ayu-1.0.5<br>twxs.cmake-0.0.17<br>xaver.clang-format-1.9.0</p><h3 id="关于-xcode"><a href="#关于-xcode" class="headerlink" title="关于 xcode"></a>关于 xcode</h3><p>2018年11月25日15:08:27<br>xcode一样需要有专门的工程文件xcodeproject。使用Makefile的原理同vscode，也是调用外部构建工具。但是xcode自身不带有命令行工具<br>clion和pycharm都太占内存CPU了，如非必要尽量不用jetbrains<br>codeblocks可以认为没有mac版本</p><p>2018年12月05日21:57:13  尝试使用xcode管理makefile组织的代码</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>类似nvm之于nodejs，java同样有版本工具<a href="https://sdkman.io/">sdkman</a></p><blockquote><p>SDKMAN是一个用于管理软件开发工具的工具。它允许用户在他们的计算机上安装、管理和切换不同的软件开发工具，如Java、Gradle、Maven、Scala等。SDKMAN提供了一个简单易用的命令行界面，用户可以使用命令来安装、卸载、切换和更新不同的工具版本。SDKMAN还提供了一个广泛的软件工具列表，用户可以从中选择并安装他们所需的工具。<br>简单来说，如果你使用过python的anaconda，那么你可以将这玩意理解成一个java版本的anaconda，可以很方便的管理多个java版本。</p></blockquote><ol><li>所以没有必要再手动下载安装任何java（除了brew可能依赖的版本）</li><li>所以也不必再使用IDEA内置的SDK下载器了</li></ol><p>2024-08-21 10:20:21 截止目前IDE还是使用IntelliJ IDEA最全面靠谱。<a href="../resources/jetbrains_idea.zip">配置文件</a></p><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><ul><li>IntelliJ gogland。但是收费</li><li>现阶段先使用vscode，因为现在写Golang也不多。配置还是略显麻烦了</li><li>现阶段可以先使用fleet，限免期间基本上可以当做Goland用</li></ul><p>版本管理工具gvm<br>它允许您在同一台机器上轻松切换不同版本的 Go</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过curl安装GVM</span></span><br><span class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br></pre></td></tr></table></figure><ol><li>gvm listall</li><li>gvm install go1.16.5</li><li>gvm use go1.16.5 –default</li><li>gvm use go1.16.5</li><li>gvm uninstall go1.16.5</li></ol><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>首先要区分编辑器与IDE</p><ul><li><strong>visualstudiocode</strong>漂亮、启动速度慢。既是编辑器又是IDE。转码最强。不对C&#x2F;C++做语法分析</li><li>jetbrains fleet。对标visualstudiocode的插件式ide，同样有jb家软件高内存的毛病，而且对调试测试的支持还不完善。2024年05月11日</li><li>Atom：启动超级慢，不会自动转码。放弃。超级傻逼的编辑器</li><li>notepad++启动超级快，会自动转码，丑。插件辣鸡。不能跨平台</li><li>Sublime 命令插件自有体系，需要学习成本。跨平台，会自动转码。会对C&#x2F;C++做语法分析，能跳转</li><li>lighttable既不是编辑器又不是IDE的辣鸡。<blockquote><p>编辑器全面转向VSCode，自带功能加插件完爆sublime，而且最漂亮。其他更不在话下。但是真的是太慢了，而且对后端语言的支持比sublime差远了</p></blockquote></li><li>vim不值得深入学习，彻底完全放弃，不要有一丝疑虑。只需要尽量使用spf-13m插件或者simple.vimrc</li></ul><p>现在编辑器的唯一和最终解决方案已经锁死vscode了</p><h3 id="关于sublime"><a href="#关于sublime" class="headerlink" title="关于sublime"></a>关于sublime</h3><p>丰富的插件、漂亮、专业、快捷、高度定制、编辑器的最后解决方案 首先通过注册表把它加到右键菜单 [HKEY_CLASSES_ROOT*\shell\SublimeText3] @&#x3D;”用 SublimeText3 打开” “Icon”&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe,0”<br>[HKEY_CLASSES_ROOT*\shell\SublimeText3\command]<br>@&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe %1”</p><p>[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3]<br>@&#x3D;”用 SublimeText3 打开”<br>“Icon”&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe,0”</p><p>[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command]<br>@&#x3D;”C:\Program Files\Sublime Text 3\sublime_text.exe %1”</p><p>sublime插件与设置：<br>2018年1月18日11:03:38 prettyjson<br>converttoutf8<br>log highlight</p><p>2018年11月22日11:27:01 sublime要去中文官网下载，外文官网翻墙都打不开</p><h2 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h2><p>2019年10月28日14:16:54 导出spacevim配置</p><pre><code>原位置：~/.SpaceVim.d/init.toml文件名：spacevim.init.toml使用方式：内容复制，保存即可2023年04月16日10:21:41 仅复制vimrc即可，spacevim安装耗时，也没有太大必要</code></pre><p>2019年10月28日14:37:28 导出iterm2配置</p><pre><code>原位置：iTerm2 -&gt; Preferences -&gt; General -&gt; Settings -&gt; Export All Settings and Data文件名：iTerm2Settings.itermexport使用方式：iTerm2 -&gt; Preferences -&gt; General -&gt; Settings -&gt; Import All Settings and Data</code></pre><p>bash</p><pre><code>工作机：develop.zshrc跳板机：jump.bashrc编译测试机：compile.bashrciTerm2配置：iTerm2_Profiles.json</code></pre><p>vscode</p><pre><code>快捷键：vscodekeybindings.json  笔记设置：vscodesettings.json代码设置：vscodesettings2.jsonC++新文件模版配置：vscodetmpl.json  通过preference-&gt; Configure User Sniffets生效</code></pre><p>IDE</p><pre><code>Clion: clion-light.zipGoland: goland-light.zipPycharm: pycharm-light.zip</code></pre><h2 id="其他适配"><a href="#其他适配" class="headerlink" title="其他适配"></a>其他适配</h2><p>2021年03月03日23:09:39 解决macos更新big sur之后，vscode + source code pro显示全黑色的问题</p><ol><li>rm -rf &#x2F;Users&#x2F;didi&#x2F;Library&#x2F;Application\ Support&#x2F;Code\ -\ Insiders</li><li>移除source code pro字体，移除vscode</li><li>安装vscode，安装字体。配置字体</li></ol><p>2020年11月03日10:44:58 安全性与隐私-&gt;启用<strong>文件保险箱</strong><br>C3CO-OT24-OHVJ-TZMX-7P9J-OJGL</p><p>2020年09月16日18:03:11 <strong>ocenaudio</strong>有问题，偶尔会持续失真，表现类似打开错误的采样率，但是实际没错</p><p>2019年08月22日17:38:04 mac中按住control + 方向键上打开任务视图</p><p>2021年04月06日20:11:58 <strong>iterm2无法缩放</strong>，无法拖动<br>Preferences-&gt;Appearance-&gt;Tabs-&gt;勾选 show tab bar even when there is only one tab<br>终端使用iTerm2，选择主题为zenburn，spf13-vim同样。原来vim展示什么样不止取决于主题，也取决于终端主题</p><p>2021年04月12日20:23:23 配置rzsz传递文件<br><a href="https://www.cnblogs.com/limingluzhu/p/4818197.html">https://www.cnblogs.com/limingluzhu/p/4818197.html</a></p><p>2024年05月06日19:33:39 <strong>SourceTree</strong> macbook上 git可视化首选</p><ol><li>GitHubDesktop辣鸡。反应慢，功能少</li></ol><p>2023年04月17日11:29:44 <strong>配置休眠时关闭蓝牙和wifi</strong><br><a href="https://juejin.cn/post/7057723273827581959">https://juejin.cn/post/7057723273827581959</a><br><a href="https://github.com/Mintimate/SleepAndAutoBluetoothAndWifi">https://github.com/Mintimate/SleepAndAutoBluetoothAndWifi</a></p><p>2021年04月07日10:22:08 <strong>cherry mx 1.0 键盘 &amp; thinkplus M80 鼠标</strong></p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>2024-07-19 15:18:19 合盖休眠时自动关闭蓝牙，避免耳机自动连接合盖的电脑<br><a href="https://github.com/odlp/bluesnooze">https://github.com/odlp/bluesnooze</a></p><h1 id="Linux-Ubuntu-CentOS"><a href="#Linux-Ubuntu-CentOS" class="headerlink" title="Linux(Ubuntu&#x2F;CentOS)"></a>Linux(Ubuntu&#x2F;CentOS)</h1><p>ubuntu是最适合作为桌面操作系统的linux，但是服务端常用的是centos<br>Ubuntu和centos以及其他Linux发行版，他们的唯一区别在于包管理方式不同，使用的内核都是linus工作组在维护的内核，区别在于通常Ubuntu的内核版本比较高，而centos的内核版本比较低。Ubuntu 16.04&#x3D;3.8.0，centos7（1611build）&#x3D;3.1.0</p><p>ubuntu:<br>好吧，第一次更新系统后提示出现错误只能重启，重启后无限卡在登录页面也桌面环境之间。遂放弃</p><p>最终选用CentOS 7 Everything，其他版本不再考虑</p><pre><code>安装时选择安装设备，具体请搜索选择everything镜像，直接用UltraISO制作(不要用ultraiso preuim)，不要用UUI会有格式转换。选择安装develop station安装。此时请使用模拟声卡的声音接口内置了中文输入法、播放器等尽量尝试使用应用商店。应用商店其实就是yum源的可视化方式使用pkgs.org提供的rpm安装chrome，此后可以在网页使用云端工具了配置yum源，最少要有epel、rpmforgeyum upgrade ，升级系统</code></pre><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="自动关机"><a href="#自动关机" class="headerlink" title="自动关机"></a>自动关机</h2><p>@echo off<br>sc config Schedule start&#x3D;AUTO&gt;nul 2&gt;nul<br>net start Schedule<br>at 21:00 &#x2F;every:M,T,W,Th,F,S,Su cmd &#x2F;c Start %systemroot%\system32\shutdown.exe &#x2F;s &#x2F;f<br>at 22:00 &#x2F;every:M,T,W,Th,F,S,Su cmd &#x2F;c Start %systemroot%\system32\shutdown.exe &#x2F;s &#x2F;f<br>at 23:00 &#x2F;every:M,T,W,Th,F,S,Su cmd &#x2F;c Start %systemroot%\system32\shutdown.exe &#x2F;s &#x2F;f<br>windows 添加自动关机任务，最终的唯一的方式</p><h2 id="VMWare"><a href="#VMWare" class="headerlink" title="VMWare"></a>VMWare</h2><p>需求：模拟服务的发布，达到可以在不同主机的情况下访问。 解决方案：1.把服务用Windows系统发布 2.在虚拟机中同时运行多个虚拟主机，并组成不同网络 考虑到以后可能需要把Kubernetes等分布式应用工具先部署到测试环境，所以这里采用了2。 虚拟机三种组网方式 注意到：桥接方式可以认为虚拟出一台物理机在子网上，所以不能用于MAC绑定的子网（公司就是mac绑定的）；NAT方式可以实现主机虚拟机双向通信，但是虚拟机之间不能通信。那就只能用主机发布，相当于方案1.所以只能使用主机模式。 主机模式主机也有一块虚拟网卡，和虚拟机的网卡一起连接在虚拟交换机上组成子网。但是这个子网是绝缘的，只能与主机上的其他虚拟子网相连。<br>在VMware workstation Pro 12上，以下步骤应该能解决问题。如果不能，请直接移步VMware文档中心不用百度了<br>步骤：<br>1.右键需要组网的虚拟机，在配置》网络适配器中选择主机模式。然后在主机中使用配置有线网也好、命令行也好，保证ip变到主机模式的网段！！！（三种模式的网段在 编辑》虚拟网络编辑器 里可以看到）<br>2.在主机上控制面板里，配置VMnet1可共享，并且共享给VMnet8（为什么是这个虚拟网卡我也不知道，当时瞎选的）<br>3.这个时候如果虚拟机里的ipv4是DHCP自动，应该就可以了。反正最终效果是主机、虚拟机*n在同一子网中！<br>4.这时应该是能相互ping通了。在某个虚拟机中把服务发布，然后在其他机器访问试试？是不是会出现no route to host ？ 这是因为作为服务器的虚拟机的防火墙拒绝访问。centos7的防火墙服务是firewalld.service。<br>5.如果服务写的对，而且发布没有问题的话，这个时候就能正常访问了。<br>6.需要的时候逆向以上1、2，不然虚拟机不能上网。</p><h2 id="windows其他适配"><a href="#windows其他适配" class="headerlink" title="windows其他适配"></a>windows其他适配</h2><p>2018年1月16日09:53:52 如果安装了Visual Studio，务必修改注册表，在右键菜单里删除打开方式</p><p>2018年1月16日09:53:54 Win7版本，安装MacType，并且选用LCD。pycharm对于LCD和non-LCD屏的支持不同，如果不支持LCD，那么就会出现显示字符被截断的问题</p><p>2018年1月16日09:53:57 安装vsix.双击打开。卸载呢？在visualstudio里 工具》扩展与更新》已安装》选择该项》卸载</p><p>2018年1月16日09:54:33 添加任务计划。开始》程序》附件》系统工具》任务计划<br>2018年1月16日09:55:04 输出目录下所有文件目录树。tree loveit &#x2F;f &gt;&gt; output.txt</p><p>2018年1月16日09:55:17 Windows 查看命令手册。help 命令</p><p>2018年1月16日09:55:28 启动MySQL。作为系统服务需要在计算机》管理》服务和应用程序》服务 中开启，其他系统服务也是</p><p>2018年1月16日09:55:53 在浏览器中禁用stackoverflow的js可以明显加快速度</p><p>2018年1月16日09:55:56 禁用百度知道的js就可以避免日报的侵扰</p><p>2018年1月16日09:55:58 PowerShell中获取本机已安装软件列表 Get-WmiObject -Class Win32_Product</p><p>2018年1月16日09:56:03 添加和删除右键菜单<br>控制文件右键菜单的注册表项在HKEY_CLASSES_ROOT*\shell\ 。 注意添加command文件夹<br>控制文件夹右键菜单的注册表项在HKEY_CLASSES_ROOT\Directory\shell\ 。 注意添加command文件夹</p><p>2018年1月11日15:45:25 废止使用Visual Studio 2017作为Linux C++开发工具，目前尚不稳定</p><p>2018年1月16日10:05:27 <install> PicPick</p><p>2018年1月16日14:13:25 <install> [depracated]搜狗鼠标手势</p><p>2018年1月16日10:07:39 linux虚拟机跟windows主机之间拷贝东西就可能引起文件数据异常，典型的如压缩文件损坏，更好的方式是使用xshell的rz与sz命令</p><p>2018年1月18日15:25:48 安装tortoiseSVN和tortoiseGit时务必勾选命令行</p><p>2024年05月06日19:34:09 TortoiseGitgit可视化首选</p><p>reStructText富文本标记语言<br>使用终极编辑器Visualstudio。其他编辑器都不能完美展示reStructText<br>Markdown 过于简单了<br>ESET<br>JJmatch公司自带的杀毒软件。默认在用户登录时进行全盘扫描，极占CPU，甚至导致开机卡机。需要在ESET面板&gt;工具&gt;计划任务修改该项<br>Navicat 确实没有mysqlworkbench好使</p><p>远程调试通常是通过ftp或samba或git把源码同步到目标机，然后借助gdb远程调试技术，使用gdbserver调试，支持的ide有clion、vs、eclipse。但是这条路没有必要深入，只需要走通即可。可以在虚拟机中开发，然后在目标机上测试运行。如果需要，使用上述方式调试。所有对远程开发并调试的尝试就此打住。<br>绝不尝试vim开发+gdb原生调试<br>Foxmail 不能导出，所有东西都不能导出。不能同步<br>Dreammail 非常强大。可以备份<br>网易邮箱大师 功能太弱了。可以同步</p><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><p>2018年4月19日11:00:42</p><p>打开cmd命令行或PowerShell</p><p>查看端口占用情况</p><p>netstat -aon|findstr port</p><p>最后一列是pid</p><p>查看pid对应的进程详细情况</p><p>tasklist|findstr pid</p><p>同时得到进程映像名</p><p>根据pid或进程影响名杀死进程</p><p>taskkill &#x2F;f &#x2F;t &#x2F;im pid或程序名</p><p>&#x2F;im选项可能要改为&#x2F;pid选项</p><h2 id="软件及配置"><a href="#软件及配置" class="headerlink" title="软件及配置"></a>软件及配置</h2><p>2018年3月16日14:06:30 PDF桌面阅读使用福昕阅读器。注意首先在设置中将广告推送取消，然后在视图-页面设置中选择&lt;连续&gt;</p><p>2018年3月30日09:56:27 调整visual studio 配置以配色</p><blockquote><p>不再使用visual assist X</p></blockquote><p>2018年4月3日11:16:27 实现Windows CMD复制粘贴功能：</p><blockquote><p>Windows 命令行默认是不能选定的</p><ul><li>首先在窗口右键，选择编辑-&gt;标记</li><li>标记完成后回车确认</li><li>此时内容已在剪贴板。右键窗口选择粘贴</li></ul><p>在任何情况下都不能实现直接通过ctrl+cv复制粘贴</p></blockquote><p>2018年4月18日17:24:50 勾选cmd命令行的快速编辑模式和插入模式，可以实现选择之后右键快速复制，再右键快速粘贴</p><p>2018年4月3日17:39:21 使用clion三部曲：</p><blockquote><ul><li>配置toolchains。在settings&gt;Build,Execution,Deployment中配置Toolchains。注意如果是拷贝的配置，配置export时将toolchains清空，否则会导致导入时不能更改</li><li>配置Cmake。在settings&gt;Build,Execution,Deployment中配置cmake profiles</li><li>配置run configuration。如果前两部能正常完成，在打开了工程的情况下，第三步可自动完成。</li></ul></blockquote><p>2018年5月30日16:23:58 发现Clion的编译提示和变量类型、值提示没有VS完整</p><p>2018年8月3日15:34:54 windows上的mysql无法区分大小写！尽可能直接使用linux mysql</p><p>2019年12月23日19:06:00 按住option键，然后从窗口的下边缘开始缩放，这样上边缘也会同步缩放，以解决filezilla初始化窗口无法显示的问题</p><p>2020年02月24日10:11:41 破解beyondcompare作为文本对比工具</p><h1 id="跳板机"><a href="#跳板机" class="headerlink" title="跳板机"></a>跳板机</h1><p>2019年04月15日18:31:00 跳板机上的脚本都是sh脚本，使用个人登录凭证逐个登录到各机器<br>~&#x2F;lighttpdfinder 找到哪个集群的lighttpd在为某个端口转发<br>~&#x2F;logfilter 日志过滤器</p><p>2019年05月14日14:20:47 .bashrc<br>快速进入测试机</p><hr><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-22 11:02:49 很久以前还考虑过如何用Windows主机做开发机，选用什么系统，配置什么环境，现在基本上 macbook + docker + （vscode）统一天下了</p><h2 id="开发机"><a href="#开发机" class="headerlink" title="开发机"></a>开发机</h2><ul><li>Windows所见即所得确实厉害，软件丰富，优化不错，但是只能远程测试C++</li><li>Linux常作为服务端系统。但是不太友好<br>  因此除C++外其余在Windows。仅保留LInux Ultimate虚拟机和实验性真机<blockquote><p>最终选用 centos7 workstation版本，可定制化程度高，界面支持好，管理方便，大部分软件包都默认安装。Ubuntu根本不堪一击<br>2018年11月11日15:31:44 Ubuntu on Windows目前还漏洞百出，安装c++工具链遇到各种奇怪的问题无法解决</p></blockquote></li></ul><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><p>2020年12月09日14:14:16 源码安装</p><ol><li><p>vim8.1:</p><p>  .&#x2F;configure –with-features&#x3D;huge –enable-multibyte –enable-rubyinterp –enable-pythoninterp –with-python-config-dir&#x3D;&#x2F;usr&#x2F;lib64&#x2F;python3.4&#x2F;config –enable-luainterp –with-lua-prefix&#x3D;&#x2F;usr&#x2F;bin –enable-perlinterp –enable-gui&#x3D;gtk2 –enable-cscope –prefix&#x3D;&#x2F;home&#x2F;niuqiang&#x2F;vim81</p></li><li><p>cgdb</p></li><li><p>cmake</p></li><li><p>ffmpeg-static</p></li></ol><p>2020年12月10日11:15:20 源码安装python、golang<br>2020年01月06日23:24:36 源码安装python无法安装依赖的问题however the ssl module in Python is not available.</p><pre><code>    yum install openssl-devel    cd Python-3.6.2    ./configure    make altinstall</code></pre>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> macbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务系统设计参考-开篇</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8F%82%E8%80%83-%E5%BC%80%E7%AF%87/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8F%82%E8%80%83-%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务系统设计 </tag>
            
            <tag> 吴玲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题快速入门</title>
      <link href="/butterfly_quick_start/"/>
      <url>/butterfly_quick_start/</url>
      
        <content type="html"><![CDATA[<h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h1 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h1><p>修改主站配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>拷贝主题配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r themes/butterfly/_config.yml ./_config.butterfly.yml</span><br></pre></td></tr></table></figure><p>Hexo会自动合并主题中的_config.yml和 _config.butterfly.yml ，如果存在同名配置，会优先使用_config.butterfly.yml的配置</p><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><p>2024-08-15 11:28:12 butterfly主题设置参考：<a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">https://blog.csdn.net/mjh1667002013/article/details/129290903</a></p><blockquote><p>主要是修改主题配置，需要配合安装npm包</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-lazyload-image --save</span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h1 id="下一步工作"><a href="#下一步工作" class="headerlink" title="下一步工作"></a>下一步工作</h1><p>2024-08-15 11:28:22 魔改与美化未配置</p>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo快速入门</title>
      <link href="/hexo_quick_start/"/>
      <url>/hexo_quick_start/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>首先自行安装nvm、node.js、npm工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v  </span><br></pre></td></tr></table></figure><h3 id="Initialize-Book"><a href="#Initialize-Book" class="headerlink" title="Initialize Book"></a>Initialize Book</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p iBook &amp;&amp; <span class="built_in">cd</span> iBook</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo server -o</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Initialize-Github-Pages"><a href="#Initialize-Github-Pages" class="headerlink" title="Initialize Github Pages"></a>Initialize Github Pages</h3><p>创建一个名为{用户名}.github.io的仓库</p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>首先把通过git工具把生成的静态页面推送到github的流程，配置到站点配置文件；安装deployer</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graalvm+spring3快速入门</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/graalvm+spring3_quick_start/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/graalvm+spring3_quick_start/</url>
      
        <content type="html"><![CDATA[<p>2024-08-21 15:06:17 TODO 在读完</p><ol><li>Spring揭秘2023-02-23</li><li>深入理解Java虚拟机（第3版）2023-02-17</li></ol><p>之后，使用graalvm和spring3升级在使用的spring框架。</p><h1 id="快速试用"><a href="#快速试用" class="headerlink" title="快速试用"></a>快速试用</h1><ol><li>spring初始化 <a href="https://start.spring.io/">https://start.spring.io/</a></li><li><img src="/graalvm+spring3_quick_start/spring3_initializr.png" alt="选项"></li><li>项目初始化完成后，根目录会出现一个HELP.md文件对构建过程做简单指引，备份到 <a href="graalvm+spring3_quick_start/HELP">HELP.md</a></li><li>使用idea调通demo，可以直接启动，与其他spring应用没有区别</li><li>help.md里有介绍，额外两种构建方式<ol><li><code>./mvnw native:compile -Pnative</code> 生成本地可执行程序</li><li><code>./mvnw spring-boot:build-image -Pnative</code> 生成镜像。但是没有调试成功，暂时先放这</li></ol></li></ol><h1 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h1><p>graalvm原生支持的 build pack有点奇怪。在生产部署的时候，怎么能保证有可以用来执行构建命令的环境呢，所以需要在docker中执行，那么问题来了，既然在docker环境中，又怎么产出另一个docker呢？所以这个功能适用于直接推送镜像的场景，而这种操作正是需要避免的，所以更实用的还是生成本地可执行或者jar</p><p>回到贝壳，使用dockerfile构建支持，需要从dockerfile开始从零构建</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><ol><li>使用最新的ubuntu:24.04，升级的目的就是技术上不要落后，所以当然也要使用最新的lts了。这里不使用centos，因为包管理太落后了</li><li>更新apt到国内源遇到问题，出现不适配的问题。推测是版本太新了，国内支持比较弱，所以暂时没有更换国内源</li><li>设置 DEBIAN_FRONTEND&#x3D;noninteractive的作用是避免apt-get命令执行时，个别依赖包要求的交互</li><li>安装java环境的时候不要使用sdkman，下载网速非常慢，几乎不可行。所以使用直接下载jdk的方式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installing script cli archive...</span><br><span class="line">* Downloading...</span><br><span class="line">curl: (56) Failure when receiving data from the peer</span><br><span class="line"></span><br><span class="line">&#x27;curl --fail --location --progress-bar &quot;$&#123;SDKMAN_SERVICE&#125;/broker/download/sdkman/install/$&#123;SDKMAN_VERSION&#125;/$&#123;SDKMAN_PLATFORM&#125;&quot; &gt; &quot;$sdkman_zip_file&quot;&#x27;: command failed with exit code 56.</span><br><span class="line">The command &#x27;/bin/sh -c curl -s &quot;https://get.sdkman.io&quot; | bash&#x27; returned a non-zero code: 56</span><br></pre></td></tr></table></figure></li><li>基础镜像构建完成后上传到harbor.intra.ke.com&#x2F;speech&#x2F;base。因为云平台构建可以依赖到harbor，但是直接使用ubuntu:24.04就会报超时错误<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-08-23 16:48:11   #3 [internal] load metadata for docker.io/library/ubuntu:latest</span><br><span class="line">2024-08-23 16:48:11   #3 sha256:8c6bdfb121a69744f11ffa1fedfc68ec20085c2dcce567aac97a3ff72e53502d</span><br><span class="line">2024-08-23 16:48:49   #3 ERROR: failed to copy: httpReadSeeker: failed open: failed to do request: Get &quot;https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/ed/edbfe74c41f8a3501ce542e137cf28ea04dd03e6df8c9d66519b6ad761c2598a/data?verify=1724405893-6d9Q6dfHh0eXukAhn06q1Pstn38%3D&quot;: dial tcp 31.13.90.19:443: i/o timeout</span><br><span class="line">2024-08-23 16:48:49   ------</span><br><span class="line">2024-08-23 16:48:49    &gt; [internal] load metadata for docker.io/library/ubuntu:latest:</span><br><span class="line">2024-08-23 16:48:49   ------</span><br><span class="line">2024-08-23 16:48:49   ubuntu:latest: failed to copy: httpReadSeeker: failed open: failed to do request: Get &quot;https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/ed/edbfe74c41f8a3501ce542e137cf28ea04dd03e6df8c9d66519b6ad761c2598a/data?verify=1724405893-6d9Q6dfHh0eXukAhn06q1Pstn38%3D&quot;: dial tcp 31.13.90.19:443: i/o timeout</span><br></pre></td></tr></table></figure></li><li>提前创建日志目录&#x2F;data0&#x2F;www&#x2F;logs，线上日志采集会用，不创建启动前会crash</li><li>构建模块不再使用容器内下载代码的方式了，而是直接拷贝，避免不一致</li><li>现在的构建还是使用maven打包成jar，打包native image的方式暂时没有时间验证，等以后有时间吧</li><li>目前以这种方式终于算是阶段性完成了通路，待上线验证</li></ol><h2 id="官方镜像"><a href="#官方镜像" class="headerlink" title="官方镜像"></a>官方镜像</h2><p>2024-08-23 14:09:52 注意graalvm官方提供了打包好对应版本graalvm的镜像，可以直接依赖。但是问题是基础镜像是Oracle Linux Server，很可能是slim版本，没有包管理工具，也就是说完全没有可控性可言，所以尽量不要使用</p><blockquote><p>docker run -idt –name graalvm21 –entrypoint &#x2F;bin&#x2F;bash ghcr.io&#x2F;graalvm&#x2F;native-image-community:21</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash-5.1# cat /etc/os-release</span><br><span class="line">NAME=&quot;Oracle Linux Server&quot;</span><br><span class="line">VERSION=&quot;9.3&quot;</span><br><span class="line">ID=&quot;ol&quot;</span><br><span class="line">ID_LIKE=&quot;fedora&quot;</span><br><span class="line">VARIANT=&quot;Server&quot;</span><br><span class="line">VARIANT_ID=&quot;server&quot;</span><br><span class="line">VERSION_ID=&quot;9.3&quot;</span><br><span class="line">PLATFORM_ID=&quot;platform:el9&quot;</span><br><span class="line">PRETTY_NAME=&quot;Oracle Linux Server 9.3&quot;</span><br></pre></td></tr></table></figure><h2 id="Macbook"><a href="#Macbook" class="headerlink" title="Macbook"></a>Macbook</h2><p>2024-08-23 16:03:59 不要尝试在MacBook上构建镜像，会遇到各种各样奇奇怪怪的问题！，比如国内镜像源没有同步arm系列的依赖包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E: Failed to fetch http://mirrors.ustc.edu.cn/ubuntu/dists/noble/main/binary-arm64/Packages  404  Not Found [IP: 202.141.160.110 80]</span><br></pre></td></tr></table></figure><h1 id="构建启动"><a href="#构建启动" class="headerlink" title="构建启动"></a>构建启动</h1><p>构建过程同java8</p><ol><li>.&#x2F;mvnw -U clean package -Dmaven.test.skip&#x3D;true # 用于构建传统jar包模式</li><li>使用传统方式启动： java -jar xxx.jar</li></ol><p>方案2：</p><ol><li>.&#x2F;mvnw native:compile -Pnative # 用于构建native镜像</li><li>.&#x2F;target&#x2F;interact-universal-graalvm21 –gc&#x3D;G1 –pgo –strict-image-heap -march&#x3D;native -Dspring.profiles.active&#x3D;test<br>native image的方式同样支持-D等传入参数，需要重新整理start.sh</li></ol><h1 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h1><ol><li>首先在云平台创建环境</li><li>尝试直接把java8项目直接升级pom、maven、java版本，但是遇到各种奇奇怪怪的问题遥遥无期，所以最好还是反向迁移</li><li>先把graalvm21版本在云平台跑起来</li></ol>]]></content>
      
      
      <categories>
          
          <category> 方法与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp开发实战</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408uniapp%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202408uniapp%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>需求里至少三大模块：录音、webrtc传入传出音频、播放音频。其他的都是展示模块，没有技术难点</p><h1 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h1><h1 id="webrtc"><a href="#webrtc" class="headerlink" title="webrtc"></a>webrtc</h1><h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p>可以参考github搜索 vue+chat，实现相对复杂的功能</p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-28 10:31:24 TODO uni-app实现录音及播放功能 <a href="https://blog.csdn.net/a18792627168/article/details/109853394">https://blog.csdn.net/a18792627168/article/details/109853394</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端与小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用环境管理工具</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>Anaconda是一个用于科学计算的Python发行版，Anaconda支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。</p><p>Anaconda利用工具&#x2F;命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。在这里解释下conda、anaconda这些概念的差别：Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。</p><p>conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。</p><p>其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。Anaconda和Python的区别是：<br>1、安装包大小不同python自身缺少numpy、matplotlib、scipy、scikit-learn等一系列包，需要安装pip来导入这些包才能进行相应运算。Anaconda(开源的Python包管理器)是一个python发行版，包含了conda、Python等180多个科学包及其依赖项。包含了大量的包，使用anaconda无需再去额外安装所需包。<br>2、内置不同IPython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。而Anaconda Prompt 是一个Anaconda的终端，可以便捷的操作conda环境。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>macbook使用安装器安装 <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/install/macos.html">https://docs.conda.io/projects/conda/en/latest/user-guide/install/macos.html</a></p><p>安装后首先更新国内源，解决所有命令太慢的问题。编辑~&#x2F;.condarc为以下内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show_channel_urls: true</span><br><span class="line">remote_connect_timeout_secs: 30.0</span><br><span class="line">remote_read_timeout_secs: 60.0</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure><p>安装后，首先更新工具自身，避免各种奇奇怪怪的问题</p><ol><li>conda update conda</li><li>conda update anaconda</li><li>pip install –upgrade pip</li></ol><h2 id="命令实操"><a href="#命令实操" class="headerlink" title="命令实操"></a>命令实操</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. conda init</span><br><span class="line">2.1. conda create -n niuqiang_llama_0413 -- <span class="built_in">clone</span> llama  <span class="comment"># 根据已有环境创建</span></span><br><span class="line">2.2. conda create --name condamainpython python=3.12.4 <span class="comment"># 新建环境。2024-08-22最新版本</span></span><br><span class="line">2.3. conda create python=3.10 --prefix=/mnt/cfs/guestmodel/runtime</span><br><span class="line">3. <span class="built_in">source</span> activate condamainpython</span><br><span class="line">4. conda activate condamainpython</span><br><span class="line">5. python --version &amp;&amp; python3 --version</span><br><span class="line">6. conda list python</span><br><span class="line">7. conda search python</span><br><span class="line">8. conda info --envs</span><br><span class="line">9. conda remove --name python27 --all</span><br></pre></td></tr></table></figure><h1 id="Jupyter和Pycharm"><a href="#Jupyter和Pycharm" class="headerlink" title="Jupyter和Pycharm"></a>Jupyter和Pycharm</h1><blockquote><p>结论：Jupyter可以远程执行服务器上的代码。而Pycharm和vscode需要使用ssh等相关机制，所以微型项目远程开发时可能jupyter更简单。其他情况建议还是使用IDE</p></blockquote><p>Jupyter Notebook与PyCharm IDE运行逻辑对比分析</p><table><thead><tr><th>项目</th><th>Jupyter Notebook</th><th>PyCharm</th></tr></thead><tbody><tr><td>运行方式</td><td>基于Web的交互式笔记本</td><td>完整的集成开发环境（IDE）</td></tr><tr><td>执行逻辑</td><td>单元格逐一执行，可独立运行</td><td>文件整体执行，需运行整个脚本</td></tr><tr><td>实时反馈</td><td>实时显示变量和输出</td><td>需运行至相关代码行才能查看结果</td></tr><tr><td>数据可视化</td><td>内嵌可视化，方便展示</td><td>需借助额外工具或代码</td></tr><tr><td>调试功能</td><td>有限的调试支持</td><td>强大的调试工具集</td></tr><tr><td>适合场景</td><td>数据科学、机器学习、教学演示</td><td>软件开发、复杂项目、大型工程</td></tr><tr><td>集成性</td><td>可集成多种语言和环境</td><td>高度集成，适合多种语言和框架</td></tr><tr><td>社区支持</td><td>大量数据科学家和学者使用</td><td>广泛的开发者和企业用户支持</td></tr></tbody></table><p>相互关系总结：</p><ul><li>运行逻辑差异：Jupyter以单元格为单位执行代码，适合交互式探索；PyCharm则更适合传统的软件开发流程，需要整体运行脚本。</li><li>应用场景不同：Jupyter因其可视化和交互性，在数据科学和教学中更受欢迎；PyCharm则因其强大的开发和调试功能，在软件开发领域占有一席之地。</li><li>互补关系：两者各有千秋，可根据具体需求选择使用。对于需要快速原型设计和可视化的项目，Jupyter是更好的选择；对于需要高效开发和调试的复杂项目，PyCharm则更为合适。</li></ul><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><h3 id="静默安装anaconda"><a href="#静默安装anaconda" class="headerlink" title="静默安装anaconda"></a>静默安装anaconda</h3><p>wget <a href="https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh">https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh</a><br>bash Anaconda3-2021.05-Linux-x86_64.sh<br>source ~&#x2F;anaconda3&#x2F;bin&#x2F;activate</p><p>2024-08-22 14:16:43 anaconda部分的主要内容来自<br>作者：python小达<br>链接：<a href="https://www.zhihu.com/question/353409585/answer/1662315835">https://www.zhihu.com/question/353409585/answer/1662315835</a><br>来源：知乎  </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 研发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用awscli操作存储服务，非常好用！</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%A4%96%E5%AD%98/aws3/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%A4%96%E5%AD%98/aws3/</url>
      
        <content type="html"><![CDATA[<h1 id="awscli"><a href="#awscli" class="headerlink" title="awscli"></a>awscli</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>您可以使用 pip（一种适用于 Python 的程序包管理器）在大多数 Linux 发行版上安装 AWS Command Line Interface 及其依赖项。</p><blockquote><p>pip install awscli –upgrade</p></blockquote><p>Linux &amp; macOS详见：<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-linux.html">https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-linux.html</a></p><p>Windows 详见：<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-windows.html">https://docs.aws.amazon.com/zh_cn/cli/latest/userguide/awscli-install-windows.html</a></p><h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>AWS CLI 提供两个层级的命令来访问 Amazon S3。</p><p>第一个层级名为 s3，由高级别命令构成，这些命令用于频繁使用的操作，如创建、操作和删除对象及存储桶。</p><p>第二个层级名为 s3api，用于公开所有 Amazon S3 操作，包括修改存储桶访问控制列表 (ACL)、使用跨源的资源共享 (CORS) 或日志记录策略。它允许您执行单凭高级别命令无法完成的高级操作。</p><p>要获得每个层级中提供的所有命令的列表，请在 aws s3 或 aws s3api 命令中使用 help 参数：</p><blockquote><p>aws s3 help</p></blockquote><p>或者</p><blockquote><p>aws s3api help</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先进行配置</p><blockquote><p>aws configure</p></blockquote><p>输入如下</p><pre><code>AWS Access Key ID [None]: xxxAWS Secret Access Key [None]: yyyDefault region name [None]: cn-north-1Default output format [None]: json</code></pre><p><strong>在贝壳，生产环境和测试环境都需要使用生产的ak&amp; sk</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>endpoint选项</p><blockquote><p>生产环境：<a href="http://storage.lianjia.com/">http://storage.lianjia.com</a><br>测试环境：<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a></p></blockquote><p>上传单个文件</p><blockquote><p>aws s3 cp –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> &#x2F;Users&#x2F;niuqiang&#x2F;Documents&#x2F;demo.docx s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;demo.docx<br>或者<br>aws s3api –endpoint-url&#x3D;<endpoint> put-object –bucket&#x3D;test –key&#x3D;test.jpeg –body&#x3D;.&#x2F;test.jpeg</p></blockquote><p>上传目录</p><blockquote><p>aws s3 sync –endpoint-url&#x3D;<endpoint> . s3:&#x2F;&#x2F;test&#x2F;test-folder</p></blockquote><p>查看文件列表</p><blockquote><p>aws s3 ls –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;</p></blockquote><p>下载目录</p><blockquote><p> aws s3 sync –endpoint-url&#x3D;<a href="http://storage.lianjia.com/">http://storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F; .&#x2F;</p></blockquote><p>删除文件</p><blockquote><p>aws s3 rm –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;demo.docx</p></blockquote><p>预签名</p><blockquote><p>aws s3 presign –endpoint-url&#x3D;<a href="http://test-storage.lianjia.com/">http://test-storage.lianjia.com</a> s3:&#x2F;&#x2F;multimodal-interact-media&#x2F;E1Ydb0j5Jkg8f3838ab3c7b5bb714c2bcb3a4eb74aeb.docx</p></blockquote><h1 id="某壳实战"><a href="#某壳实战" class="headerlink" title="某壳实战"></a>某壳实战</h1><p>某次收到一个求助，通过aws s3 ls命令获取到的文件列表，最大只能获取到1000行，那么如何才能遍历一个bucket内的所有key</p><p>在网上经过一通调研，发现最终都指向list_objects_v2这个api  </p><ol><li><a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/client/list_objects_v2.html">aws的boto3.ListObjectsV2文档</a></li><li><a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/paginator/ListObjectsV2.html">aws的boto3.Paginator.ListObjectsV2文档</a>  </li><li><a href="https://help.aliyun.com/zh/oss/developer-reference/listobjectsv2">阿里云对象存储的listobjectsv2文档</a></li></ol><p>但是某壳的s3并不支持’ContinuationToken’和’NextContinuationToken’字段，这两个字段一直都是空字符串，而是通过’StartAfter’字段支持分页。秀！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;StartAfter&#x27;</span> <span class="keyword">in</span> response:  <span class="comment"># 通过StartAfter来分页，遍历所有的objects</span></span><br><span class="line">    start_after = response[<span class="string">&#x27;StartAfter&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(response[<span class="string">&#x27;Contents&#x27;</span>]) &lt; maxkey <span class="keyword">or</span> <span class="built_in">len</span>(start_after) == <span class="number">0</span>:  <span class="comment"># 终止条件</span></span><br><span class="line">    has_more_objects = <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库与外存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程面试模板</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/202407%E5%B7%A5%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%A8%A1%E6%9D%BF/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/202407%E5%B7%A5%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>2024年06月重新入职贝壳后，整个七月份安排了将近20场面试。</p><p>在面试的过程中发现自己其实缺少面试的方法，每次都重新准备问题，或者被人选的简历细节带着走，所以萌生了总结面试模板的想法。</p><p>换个角度想，自己作为人选时也需要考虑清楚这些问题，所以就有了这篇文章。</p><p>文章适用的对象是初级和中级的后端业务研发工程师。在现在这个资源高度发达的时代，几乎所有做业务的研发都需要具备的基本技能。</p><h1 id="面试模板"><a href="#面试模板" class="headerlink" title="面试模板"></a>面试模板</h1><ol><li>基本情况<ol><li>公司业务。目前是否在职 ；职级<br> 1. </li><li>换工作的原因<br> 1. </li><li>对自己工作方向的规划；对大模型和多模态的了解<br> 1. </li><li>面试进度</li></ol></li><li>项目经历<br> 1. </li><li>项目背景 S<ol><li>为什么要做这件事</li><li>受益对象是哪些；用户量和访问量</li><li>需要什么投入&amp;输入</li></ol></li><li>自己负责的部分 T<ol><li>职责边界在哪里<br> 1. </li><li>解决了什么问题；痛点问题及原因</li><li>达成了什么效果<ol><li></li></ol></li></ol></li><li>方案设计 A<ol><li>在整体中的位置</li><li>各模块的功能  – 你们项目的架构是什么样的，可以说一下数据流向和请求流向吗？</li><li>核心算法</li><li>技术选型；组件选型的考量，有什么优势和限制；无限制的情况下如何重新选型</li><li>每一个组件的工作流和实现原理</li><li>难点在哪；技术上最大的挑战和困难  – 列举一些你在项目中做的比较有挑战的事情或者业务，比如具体的技术细节体现，如何攻坚某个难点，怎么做技术选型的（几乎每个组件都要问一下，问什么要用这个组件，而不是其他的）？<br> 1. </li><li>需要哪些团队协作；有什么问题</li></ol></li><li>达成的效果 R<ol><li>性能测试<br> 1. </li><li>可用性保障和故障排查<ol><li>限流手段<br> 1. </li><li>分布式一致性如何实现<br> 1. </li><li>自动扩缩容策略</li><li>熔断降级策略</li></ol></li><li>项目最终体现的价值</li></ol></li><li>自己有什么思考</li><li>设计一款多模态交互产品的后端架构</li></ol><h1 id="问题环节"><a href="#问题环节" class="headerlink" title="问题环节"></a>问题环节</h1><ol><li>业务层面<ol><li>团队的使命和愿景</li><li>部门的工作横向纵向展开</li></ol></li><li>技术层面围<ol><li>核心能力</li><li>团队情况</li></ol></li></ol><h1 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h1><ol><li>发现候选人特长</li><li>根据贝壳职级标准给出评语</li><li>学习能力</li><li>沟通能力</li><li>团队协作</li><li>思考</li></ol><h1 id="技术工具"><a href="#技术工具" class="headerlink" title="技术工具"></a>技术工具</h1><ol><li>Java：虚拟机（内存管理）、容器、多线程、异常、网络框架线程和内存机制、ORM<ol><li>golang八股文速查 <a href="https://blog.csdn.net/qq_43716830/article/details/124405506">https://blog.csdn.net/qq_43716830/article/details/124405506</a></li><li>c++八股 onedrive中的 亮白风格-C++八股文-小贺-v1.0.pdf</li><li>Python 八股 <a href="https://blog.csdn.net/qq_37085158/article/details/126821933">https://blog.csdn.net/qq_37085158/article/details/126821933</a></li></ol></li><li>分布式原理。相关话题：一致性、高可用、故障恢复<ol><li>说一下 raft 的基本原理，有什么作用？</li><li>了解 zk 的 zab 协议吗？</li><li>paxos 之类的了解吗？</li></ol></li><li>mysql、redis、MongoDB、ES、Base<ol><li>它们的组件都有哪些，如何实现的，流程是怎么样的？</li></ol></li><li>mysql八股 <a href="https://mp.weixin.qq.com/s/L26rI11OV8hrfJVy5Yu78g">https://mp.weixin.qq.com/s/L26rI11OV8hrfJVy5Yu78g</a><ol><li>锁类型与使用</li><li>sql的执行过程</li><li>sql和库表优化</li><li>多副本数据同步方式、故障恢复</li><li>如何分库分表，以及如何解决跨表跨库查询的问题。如何分页</li><li>MySQL 中的事务你介绍下，隔离级别都有啥，怎么实现的？</li><li>MVCC 你说一下怎么实现的，如何解决幻读？</li><li>你们的数据库表是如何设计的？如何设计索引，索引的实现有哪几种方式，为什么要用 B+ 树？</li><li>说一说你项目中的反范式的设计，为什么要用反范式？</li><li>说一说你在使用 MySQL 过程中遇到的坑？</li></ol></li><li>redis八股 <a href="https://mp.weixin.qq.com/s/8-Lf5KiyclW77uQwrYDTCw">https://mp.weixin.qq.com/s/8-Lf5KiyclW77uQwrYDTCw</a><ol><li>zset数据结构的实现</li><li>缓存穿透的成因，危害和解决方案</li><li>redis实现分布式锁的方案和问题</li><li>Redis 的数据结构以及源码深究，为何高性能和快速？</li><li>数据一致性方案是怎么做的？如何做持久化？AOF 重写机制怎么做的？过期策略是怎么样的？</li><li>主从同步的流程是啥样的，什么情况下会触发全量和增量同步？如何解决？</li><li>如何利用 Redis 的数据结构设计一个符合业务需求的数据模型？</li><li>哨兵机制介绍一下？</li><li>I&#x2F;O 模型是啥样的？Redis 是单线程还是多线程？</li><li>如何解决大 Key、冷 Key、热 Key 的问题？</li><li>etcd 是用来干嘛的？怎么实现的？为什么选用 etcd 而不是 Redis？</li></ol></li><li>kafka八股 <a href="https://mp.weixin.qq.com/s/8UNtMIllJ03ULZwE9WtVdg">https://mp.weixin.qq.com/s/8UNtMIllJ03ULZwE9WtVdg</a><ol><li>消息队列的使用场景</li><li>rebalance机制</li><li>如何防止重复消费，如何处理消息丢失</li><li>如何避免消息积压以及挤压如何处理</li></ol></li><li>配置中心、消息队列、负载均衡、监控中心。相关话题：配置中心的同步机制、消息队列的partition机制、负载均衡的路由机制、监控中心的采点聚合机制<ol><li>Prometheus 是怎么做监控告警的？有哪些组件，实现流程是怎么样的？</li></ol></li><li>Http、quic、ws、rpc、graphql。相关话题：rpc的序列化、ws的开关机制、graphql的原理<ol><li>RPC 框架如何实现的，如果是你的话，你会怎么设计 RPC 框架？</li><li>GORM 框架中事务和迁移的实现，Hooks 如何实现？</li><li>你对 Jaeger 和 OpenTracing 怎么理解的？那你怎么理解 TraceID 和 SpanID 的定义的？Jaeger 的实现原理是怎么样的？</li></ol></li><li>测试分析工具</li><li>你如何使用copilot、GPT<ol><li>gpt技巧。</li></ol></li><li>如何做到可读性、可维护性和健壮性</li><li>Mvc和三层架构的区别，ddd的实践<ol><li>Ddd相对来说比较契合，有统一的格式输出</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 职业规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多模态交互产品调研</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BA%A4%E4%BA%92%E4%BA%A7%E5%93%81%E8%B0%83%E7%A0%94/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202408%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BA%A4%E4%BA%92%E4%BA%A7%E5%93%81%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>人机交互界面定义</p><pre><code>    人机交互界面（Human-Computer Interaction Interface, HMI）是指用户与计算机系统之间进行交互的界面。它包括用户通过输入设备（如键盘、鼠标、触摸屏等）与计算机系统的交互，以及计算机系统通过输出设备（如显示器、音响等）向用户提供反馈信息的过程。    主要类型    人机交互界面的主要类型包括：    1. 图形用户界面（GUI）：通过图形化的方式展示信息，用户可以通过点击图标、按钮等来进行操作。    2. 命令行界面（CLI）：用户通过输入命令来进行操作，适用于高级用户或特定场景。    3. 自然用户界面（NUI）：模拟人类自然交互方式，如手势、语音等，提供更加直观的操作体验。    4. 增强现实（AR）界面：结合现实世界与虚拟信息，提供沉浸式的交互体验。    设计原则    人机交互界面的设计原则包括：    5. 可见性：确保所有可操作的功能都容易被发现，以便用户能够轻松操作。    6. 用户中心设计：将用户的需求、期望和体验置于设计的核心位置。    7. 易用性和可控性：界面应易于使用、理解和控制，以提高工作效率和用户体验。    8. 反馈和响应速度：界面应能够及时给予用户反馈，并具有快速的响应速度。    9. 自适应性：界面应能够自适应不同的设备和屏幕尺寸。    设计技巧    人机交互界面的设计技巧包括：    10. 了解目标用户：通过用户调研、问卷调查等方式收集用户反馈和需求。    11. 简化操作流程：减少不必要的步骤，使用户能够快速完成任务。    12. 提供清晰的导航：帮助用户理解他们在哪里，以及如何到达他们想去的地方。    13. 使用一致的设计风格：保持界面元素的一致性，以减少用户的学习成本。    14. 灵活的布局：允许用户根据自己的喜好调整界面布局。    当前设计趋势    当前人机交互界面的设计趋势包括：    15. 融合科技创新：结合最新的科技，如人工智能、机器学习等，提升交互体验。    16. 人性化设计：注重用户的情感需求，提供更加个性化和人性化的交互体验。    17. 自然用户界面的发展：随着技术的进步，自然用户界面（NUI）的应用越来越广泛，提供了更加自然和直观的交互方式。    18. 跨平台和多模态交互：支持多种输入方式和设备，提供无缝的跨平台体验。    总结来说，人机交互界面是用户与计算机系统之间沟通的桥梁，其设计需要遵循一定的原则和技巧，以确保用户能够获得良好的体验。随着技术的发展，人机交互界面的设计也在不断进化，向着更加智能化、个性化和自然化的方向发展。</code></pre><h2 id="竞品调研"><a href="#竞品调研" class="headerlink" title="竞品调研"></a>竞品调研</h2><ol><li><p><a href="https://platform.sensenova.cn/home#/home?1=1&gioNav=1">商汤日日新开放平台</a></p><pre><code> 模型清单 日日新-商量大语言模型 日日新-商量图文多模态大模型 日日新-秒画文生图大模型 日日新-语音大模型 日日新-向量模型 并且额外支持了文件管理</code></pre></li><li></li></ol><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>B点画面：用户能够使用图片、视频、地图、语音、按键和触屏指令、以及各种传感器的多模态输入，得到针对同一个话题以相同的形式给出的回应。用户主要使用图片视频和语音的输入（尽量简化交互）；智能体需要理解输出形式、对话题有针对性地，及时给出反馈，注重用户的情感需求，必要时可以主动提问以挖掘用户需求。</p><ol><li>形式。图像、语音、文字</li><li>针对性。</li><li>响应及时。</li><li>私人助理。避免冷启动。希望有人设</li><li>专业性。能帮我解决问题</li><li>行动交互。视觉+听觉+行动。输入和输出</li><li>机器学会提问。主动挖掘需求，了解更多信息。陪伴和情绪价值</li><li>察言观色、行动敏捷、见机行事</li><li>像人。自洽，简洁，没有badcase</li><li>语音交互的口语化。全双工，反问澄清<br>总结：</li><li>以用户为中心</li><li>响应及时</li><li>多模态</li><li>自主性</li><li>界面。人和机达成的交互共识<br>刚哥</li><li>创建一种更新的交互形式</li><li>在已有形式的基础上做提效<br>首先需要有交互形式的成功，才能有业务的成功。我们要想的是能否通过技术创建新的交互形式，一种很cool的体验，后期再考虑效率的提升。<br>技术驱动和产品驱动本身是陷阱，不一定需要产品驱动，也不一定需要技术。</li></ol><h2 id="关键能力和指标"><a href="#关键能力和指标" class="headerlink" title="关键能力和指标"></a>关键能力和指标</h2><h3 id="豆包"><a href="#豆包" class="headerlink" title="豆包"></a>豆包</h3><ol><li>创建和发现智能体</li><li>语音交互</li><li>图片生成</li><li>写作生成</li><li>音乐生成</li><li>拍题答疑</li><li>订阅咨询</li><li>翻译</li><li>帮我回复</li><li>随便听听</li><li>文档阅读</li><li>网页阅读</li></ol><h3 id="海螺"><a href="#海螺" class="headerlink" title="海螺"></a>海螺</h3><ol><li>智能体</li><li>图片解读</li><li>写作生成</li><li>搜索信息</li><li>语音交互</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>2024-07-15 10:02:39 一些调研材料  </p><blockquote><p>集合了很多AI工具的介绍，可以用于发现竞品名录，如豆包 <a href="https://ai-bot.cn/sites/4189.html">AI工具集</a><br>机器之心的PR稿 <a href="https://www.jiqizhixin.com/articles/2020-12-22-7">人机交互新突破：百度发布主动多模态交互技术</a><br>第四范式的官网介绍 <a href="https://www.4paradigm.com/product/SageGPT.html?sem_sagegpt_pc_31&bd_vid=5051625044806563962">https://www.4paradigm.com/product/SageGPT.html?sem_sagegpt_pc_31&amp;bd_vid=5051625044806563962</a><br>看起来是做数字人的 <a href="https://www.youyan3d.com/platform/template?from=bingkw1635/pc&msclkid=bdcad53ee0fd139a0893b35c20f3f130">有言的作品中心</a><br><a href="https://cloud.tencent.com/product/ivh">腾讯云智能数智人</a><br>讯飞AIUI开放平台 <a href="https://aiui.xfyun.cn/">https://aiui.xfyun.cn/</a><br>一家传统软件公司的平台互联网行业解决方案 <a href="https://www.ti-net.com.cn/solution/internet/">天润融通</a><br>360AI基础服务平台 <a href="https://qycloud.360.cn/aiplatform.html">https://qycloud.360.cn/aiplatform.html</a><br>中关村科金 <a href="https://www.zkj.com/abilities">https://www.zkj.com/abilities</a>  </p></blockquote><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024-08-13 10:06:41 会议纪要 @邹伟 @韩阳<br>目标：未来一到两年，理想中的交互形式界面：更像人的交互，可能是什么样子。面向C端，可以是线下实体交互</p><p>关键能力和指标：拆分，需要什么能力</p><p>当前现状<br>业界标杆<br>我们</p><p>先实现标杆</p>]]></content>
      
      
      <categories>
          
          <category> 设计与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 能力与平台建设 </tag>
            
            <tag> 多模态应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金数据通关考试产品调研</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202406%E9%87%91%E6%95%B0%E6%8D%AE%E9%80%9A%E5%85%B3%E8%80%83%E8%AF%95%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/03.%E8%83%BD%E5%8A%9B%E5%8F%8A%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE/202406%E8%B4%9D%E5%A3%B3%E5%A4%9A%E6%A8%A1%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%93%E9%A1%B9/202406%E9%87%91%E6%95%B0%E6%8D%AE%E9%80%9A%E5%85%B3%E8%80%83%E8%AF%95%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>2024-07-03 14:11:22 帅江给出的大模型时代的培训平台设计，但是不够完善，可以参考<a href="https://lv3m6lva5yh.feishu.cn/docx/KLZRdSUk5oJl92xWi7ccoM5Onmb">多模态交互项目介绍</a></p><p>2024-07-03 14:13:45 邹伟给出的小贝训练场的整体情况，以及在大模型时代应该怎么做 <a href="https://lv3m6lva5yh.feishu.cn/docx/TWOTdPiGmo9vNKxfPcIcrSuInwf">小贝训练场</a></p><blockquote><p>已备份到文档</p></blockquote><p>2024-07-03 14:15:29 帅江给出的交互架构和计划，疑似已废弃 <a href="https://lv3m6lva5yh.feishu.cn/docx/ClKfdd245oHaTDxh9MLcURj0nkg">语音(多模态)交互一阶段计划 副本</a></p><p>2024-07-03 14:16:14 帅江给出的最新的多模态交互项目的文档 <a href="https://lv3m6lva5yh.feishu.cn/docx/XsI6dzT9AoVJavxzAOJcJ1PSnhd">多模态交互项目文档</a></p><h1 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h1><p>2024-07-15 10:00:53 金数据的网页版 <a href="https://5.jinshuju.net/exams/question_banks">https://5.jinshuju.net/exams/question_banks</a></p><p>2024年07月03日14:09:18 我做的产品设计，待完成原型后补充 <a href="https://dbu2emj6wk.feishu.cn/docx/WOj4dTXQ7oHKi5xKcTgcid8kneJ">通关训练系统调研与设计</a></p><blockquote><p>已给出金数据的H5页面设计</p></blockquote><p>2024年07月03日14:01:13 庭炜给出的通关考试AI部分的接口调用 <a href="https://lv3m6lva5yh.feishu.cn/docx/Iz3Idrco0oacVMx4WSBc7TYWnic">通关考试–AI模型调用</a></p><blockquote><p>应该根据文档提取知识点，再提取题目，以稳定提取的题目数</p></blockquote><p>2024-07-03 14:13:04 帅江给出的AI考试系统调研，纯调研 <a href="https://lv3m6lva5yh.feishu.cn/docx/FK08dQmLloCDSoxFCSkc2Z6xnxf">AI 考试系统调研</a></p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>202406通关训练项目</p><pre><code>1. 整理通关训练的工作分享。设计分享 https://dbu2emj6wk.feishu.cn/docx/NoVZdGU2DoKCWgxjYJicBfHhnhf2. 拆解金数据等竞品的产品设计和接口3. 了解企业微信中的壳劲学2.04. 调研使用uniapp做多端生成；学习vue5. 列举并画完所有的界面；调研题目模板问题6. 实现对接小程序的接口；调试小程序的https连接问题7. 暂时不需要登录鉴权cookie等8. 可选的，通过css调整界面美观度9. 和PE怎么协同 — 智能研发中心的方案是否可选10. 效率问题 — 九月版本不能出现问题11. 小程序和h5的选择，前端介入12. 对比 https://github.com/opendatalab/PDF-Extract-Kit 和Apache tika https://github.com/opendatalab/MinerU/tree/master13. </code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计与实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金数据 </tag>
            
            <tag> 小贝 </tag>
            
            <tag> 通关考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象建模方法</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202408_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202408_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-面向对象，这个对象到底是什么？"><a href="#一、-面向对象，这个对象到底是什么？" class="headerlink" title="一、 面向对象，这个对象到底是什么？"></a>一、 面向对象，这个对象到底是什么？</h1><p>　　这个对象不是C#中的实例，C#中我们把一个类的实例也叫做对象，这种对象严格的说应该是面向对象的编程实现(OOP)中的对象，面向对象编程，也不是面向类的实例编程。对象的定义是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。也有的定义为“一切都是对象”然而面向对象也不能简单的等价理解成面向任何事物编程，面对一切编程？开玩笑，呵呵。</p><p>　　因此<strong>面向对象这个对象，指的是客体。所谓客体是指客观存在的对象实体和主观抽象的概念</strong>。 </p><h1 id="二、-为什么要面向对象？"><a href="#二、-为什么要面向对象？" class="headerlink" title="二、 为什么要面向对象？"></a>二、 为什么要面向对象？</h1><p>　　<strong>面向对象是为了解决系统的可维护性，可扩展性，可重用性</strong>，我们再进一步思考，面向对象为什么能解决系统的可维护性，可扩展性，可重用性？ </p><p>　　面向对象产生的历史原因有下面两点： </p><p>　　1、 计算机是帮助人们解决问题的，然而计算机终究是个机器，他只会按照人所写的代码，一步一步的执行下去，最终得到了结果，因此无论程序多么的复杂，计算机总是能轻松应付。结构化编程，就是按照计算机的思维写出的代码，但是人看到这么复杂的逻辑，就无法维护和扩展了。</p><p>　　2、 结构化设计是以功能为目标来设计构造应用系统，这种做法导致我们设计程序时，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种转换过程，背离了人们观察和解决问题的基本思路。 </p><p>　　<strong>可见结构化设计在设计系统的时候，无法解决重用、维护、扩展的问题，而且会导致逻辑过于复杂，代码晦涩难懂</strong>。于是人们就想，能不能让计算机直接模拟现实的环境，用人类解决问题的思路、习惯、步骤来设计相应的应用程序？这样的程序，人们在读它的时候，会更容易理解，也不需要再把现实世界和程序世界之间来回做转换。 </p><p>　　与此同时，人们发现，<strong>在现实世界中存在的客体是问题域中的主角。所谓客体是指客观存在的对象实体和主观抽象的概念，这种客体具有属性和行为，而客体是稳定的，行为是不稳定的，同时客体之间具有各种联系，因此面向客体编程，比面向行为编程，系统会更稳定</strong>。在面对频繁的需求更改时，改变的往往是行为，而客体一般不需要改变，所以我们就把行为封装起来，这样改变时候只需要改变行为即可，主架构则保持了稳定。 </p><p>　　于是面向对象就产生了。 </p><p>　　然而人们追求的系统可维护性，可扩展性，可重用性又是怎么在面向对象中体现出来的呢？ </p><p>　　首先看看面向对象的三大特征： </p><p>　　封装：找到变化并且把它封装起来，你就可以在不影响其它部分的情况下修改或扩展被封装的变化部分（即定义客体的边界），这是所有设计模式的基础，就是封装变化，因此<strong>封装的作用，就解决了程序的可扩展性。</strong></p><p>　　继承：子类继承父类，可以继承父类的方法及属性，实现了多态以及代码的重用，因此也解决了系统的重用性和扩展性。但是<strong>继承破坏了封装</strong>，因为他是对子类开放的，修改父类会导致所有子类的改变，因此继承一定程度上又破坏了系统的可扩展性，所以继承需要慎用。只有明确的IS-A关系才能使用，同时继承在在程序开发过程中重构得到的，而不是程序设计之初就使用继承，<strong>很多面向对象开发者滥用继承，结果造成后期的代码解决不了需求的变化了。因此优先使用组合，而不是继承，是面向对象开发中一个重要的经验。</strong></p><p>　　多态：<strong>接口的多种不同的实现方式即为多态。接口是对行为的抽象</strong>，刚才在封装提到，找到变化部分并封装起来，但是封装起来后，怎么适应接下来的变化？这正是接口的作用，接口的主要目的是为不相关的类提供通用的处理服务，我们可以想象一下。比如鸟会飞，但是超人也会飞，通过飞这个接口，我们可以让鸟和超人，都实现这个接口，<strong>这就实现了系统的可维护性，可扩展性。</strong></p><p>　　因此面向对象能实现人们追求的系统可维护性，可扩展性，可重用性。面向对象是一种编程思想，起初，“面向对象”是专指在程序设计中采用封装、继承、多态等设计方法，但面向对象的思想已经涉及到软件开发的各个方面，比如现在细分为了面向对象的分析(OOA)，面向对象的设计(OOD)，面向对象的编程实现(OOP) </p><h1 id="三、面向对象编程，分为几个步骤？"><a href="#三、面向对象编程，分为几个步骤？" class="headerlink" title="三、面向对象编程，分为几个步骤？"></a>三、面向对象编程，分为几个步骤？</h1><p>　　面向对象是一种思想，他让我们在分析和解决问题时，把思维和重点转向现实中的客体中来，然后通过UML工具理清这些客体之间的联系，最后用面向对象的语言实现这种客体以及客体之间的联系。它分为面向对象的分析(OOA)，面向对象的设计(OOD)，面向对象的编程实现(OOP)三个大的步骤。</p><p>　　1、首先是分析需求，先不要思考怎么用程序实现它，先分析需求中稳定不变的客体都是些什么，这些客体之间的关系是什么。</p><p>　　2、把第一步分析出来的需求，通过进一步扩充模型，变成可实现的、符合成本的、模块化的、低耦合高内聚的模型。</p><p>　　3、使用面向对象的方式实现模型</p><h1 id="四、面向过程到面向对象思维如何转变？"><a href="#四、面向过程到面向对象思维如何转变？" class="headerlink" title="四、面向过程到面向对象思维如何转变？"></a>四、面向过程到面向对象思维如何转变？</h1><p>　　当我们习惯了面向过程编程时，发现在程序过程中到处找不到需要面向对象的地方，最主要的原因，是思维没有转变。程序员通常在拿到一个需求的时候，第一个反应就是如何实现这个需求，这是典型的面向过程的思维过程，而且很快可能就实现了它。而面向对象，面对的却是客体，第一步不是考虑如何实现需求，而是进行需求分析，就是根据需求找到其中的客体，再找到这些客体之间的联系。因此面向过程和面向对象的思维转变的关键点，就是在第一步设计，<strong>拿到需求后，一定先不要考虑如何实现它，而是通过UML建模，然后按照UML模型去实现它。这种思路的转变，可能需要个过程。</strong></p><h1 id="五、面向对象和基于对象的区别"><a href="#五、面向对象和基于对象的区别" class="headerlink" title="五、面向对象和基于对象的区别"></a>五、面向对象和基于对象的区别</h1><p>　　“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象实现了“继承和多态”，而“基于对象”没有实现这些。因此在我们进行Web开发，普通三层开发中，基本上是基于对象的实现，因为只是实现了封装，但是没有使用继承和多态。不过这也正常，Web开发，大部分功能就是简单的增删改查，中间的BLL层基本就是直接New一个DAL的实例就return了，关系数据库已经为我们做了很多工作，所以大部分的工作，就是简单读取然后显示了。因此没有复杂的需求的时候，基于过程也没什么不对，面向过程也没什么不对，实用是压倒一切的因素。</p><hr><h1 id="面向对象设计原则简述"><a href="#面向对象设计原则简述" class="headerlink" title="面向对象设计原则简述"></a>面向对象设计原则简述</h1><p>面向对象的设计原则有七个，包括：开闭原则、里氏代换原则、迪米特原则（最少知道原则）、单一职责原则、接口分隔原则、依赖倒置原则、组合&#x2F;聚合复用原则。</p><h1 id="七大原则之间的关系"><a href="#七大原则之间的关系" class="headerlink" title="七大原则之间的关系"></a>七大原则之间的关系</h1><p>七大原则之间并不是相互孤立的，彼此间存在着一定关联，一个可以是另一个原则的加强或是基础。违反其中的某一个，可能同时违反了其余的原则。</p><p>开闭原则是面向对象的可复用设计的基石。其他设计原则是实现开闭原则的手段和工具。</p><p>一般地，可以把这七个原则分成了以下两个部分：</p><pre><code>设计目标：开闭原则、里氏代换原则、迪米特原则设计方法：单一职责原则、接口分隔原则、依赖倒置原则、组合/聚合复用原则</code></pre><h1 id="一、开闭原则（The-Open-Closed-Principle-，OCP）"><a href="#一、开闭原则（The-Open-Closed-Principle-，OCP）" class="headerlink" title="一、开闭原则（The Open-Closed Principle ，OCP）"></a>一、开闭原则（The Open-Closed Principle ，OCP）</h1><p><strong>软件实体（模块，类，方法等）应该对扩展开放，对修改关闭。</strong></p><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p>开闭原则是指在进行面向对象设计中，设计类或其他程序单位时，应该遵循：</p><pre><code>对扩展开放（open）对修改关闭（closed） 的设计原则。</code></pre><p>开闭原则是判断面向对象设计是否正确的最基本的原理之一。</p><p>根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</p><pre><code>扩展开放：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。修改关闭：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。</code></pre><p>系统设计需要遵循开闭原则的原因</p><ul><li>稳定性。开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。</li><li>扩展性。开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。</li><li>遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。</li></ul><h2 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h2><p>为了满足开闭原则的对修改关闭原则以及扩展开放原则，应该对软件系统中的不变的部分加以抽象，在面向对象的设计中，</p><pre><code>1. 可以把这些不变的部分加以抽象成不变的接口，这些不变的接口可以应对未来的扩展；2. 接口的最小功能设计原则。根据这个原则，原有的接口要么可以应对未来的扩展；不足的部分可以通过定义新的接口来实现；3. 模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。4. 接口可以被复用，但接口的实现却不一定能被复用。5. 接口是稳定的，关闭的，但接口的实现是可变的，开放的。6. 可以通过对接口的不同实现以及类的继承行为等为系统增加新的或改变系统原来的功能，实现软件系统的柔性扩展。</code></pre><p>好处：提高系统的可复用性和可维护性。</p><p>简单地说，软件系统是否有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。现在多把开闭原则等同于面向接口的软件设计。</p><h2 id="开闭原则的相对性"><a href="#开闭原则的相对性" class="headerlink" title="开闭原则的相对性"></a>开闭原则的相对性</h2><p>软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建100%满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。</p><p>但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。</p><h1 id="二、-里氏替换原则（Liskov-Substitution-Principle-，LSP）"><a href="#二、-里氏替换原则（Liskov-Substitution-Principle-，LSP）" class="headerlink" title="二、 里氏替换原则（Liskov Substitution Principle ，LSP）"></a>二、 里氏替换原则（Liskov Substitution Principle ，LSP）</h1><p>所有引用基类的地方必须能透明地使用其派生类的对象。</p><h2 id="概念理解-1"><a href="#概念理解-1" class="headerlink" title="概念理解"></a>概念理解</h2><p>也就是说，只有满足以下2个条件的OO设计才可被认为是满足了LSP原则：</p><p>不应该在代码中出现if&#x2F;else之类对派生类类型进行判断的条件。</p><p>派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。<br>LSP体现了：</p><ul><li>类的继承原则：如果一个派生类的对象可能会在基类出现的地方出现运行错误，则该派生类不应该从该基类继承，或者说，应该重新设计它们之间的关系。</li><li>动作正确性保证：从另一个侧面上保证了符合LSP设计原则的类的扩展不会给已有的系统引入新的错误。</li></ul><p><strong>里式替换原则为我们是否应该使用继承提供了判断的依据</strong>，不再是简单地根据两者之间是否有相同之处来说使用继承。</p><p>里式替换原则的引申意义：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能含义。</strong></p><p>具体来说：</p><ol><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的方法时（重载&#x2F;重写或实现抽象方法）的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或相等。</li></ol><p>里式替换原则的优点</p><ul><li>约束继承泛滥，是开闭原则的一种体现。</li><li>加强程序的健壮性，同时变更时也可以做到非常好地提高程序的维护性、扩展性。降低需求变更时引入的风险。</li></ul><p>重构违反LSP的设计</p><p>如果两个具体的类A，B之间的关系违反了LSP 的设计，（假设是从B到A的继承关系），那么根据具体的情况可以在下面的两种重构方案中选择一种：</p><ol><li>创建一个新的抽象类C，作为两个具体类的基类，将A，B的共同行为移动到C中来解决问题。</li><li>从B到A的继承关系改为关联关系。</li></ol><p>在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。</p><h1 id="迪米特原则（最少知道原则）（Law-of-Demeter-，LoD）"><a href="#迪米特原则（最少知道原则）（Law-of-Demeter-，LoD）" class="headerlink" title="迪米特原则（最少知道原则）（Law of Demeter ，LoD）"></a>迪米特原则（最少知道原则）（Law of Demeter ，LoD）</h1><p>对于面向OOD来说，又被解释为下面两种方式：</p><ol><li><strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></li><li><strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</strong></li></ol><p>“朋友”条件：</p><ul><li>当前对象本身（this）</li><li>以参量形式传入到当前对象方法中的对象</li><li>当前对象的实例变量直接引用的对象</li><li>当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友<br>当前对象所创建的对象</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</p><p>迪米特原则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特原则不希望类直接建立直接的接触。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特原则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系，这在一定程度上增加了系统的复杂度。</p><p>方法是类的一个行为，类竟然不知道自己的行为与其他类产生了依赖关系，这种情况是严重违反迪米特原则的</p><h2 id="使用迪米特原则时要考虑的"><a href="#使用迪米特原则时要考虑的" class="headerlink" title="使用迪米特原则时要考虑的"></a>使用迪米特原则时要考虑的</h2><p>朋友间也是有距离的</p><p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private等。</p><p>注意： 迪米特原则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、protected等访问权限。</p><h1 id="四、单一职责原则"><a href="#四、单一职责原则" class="headerlink" title="四、单一职责原则"></a>四、单一职责原则</h1><p>永远不要让一个类存在多个改变的理由。</p><p>换句话说，如果一个类需要改变，改变它的理由永远只有一个。如果存在多个改变它的理由，就需要重新设计该类。</p><p><strong>单一职责原则原则的核心含意是：只能让一个类&#x2F;接口&#x2F;方法有且仅有一个职责。</strong></p><p>为什么一个类不能有多于一个以上的职责？</p><pre><code>如果一个类具有一个以上的职责，那么就会有多个不同的原因引起该类变化，而这种变化将影响到该类不同职责的使用者（不同用户）：</code></pre><ul><li>一方面，如果一个职责使用了外部类库，则使用另外一个职责的用户却也不得不包含这个未被使用的外部类库。</li><li>另一方面，某个用户由于某个原因需要修改其中一个职责，另外一个职责的用户也将受到影响，他将不得不重新编译和配置。</li></ul><p>这违反了设计的开闭原则，也不是我们所期望的。</p><h2 id="职责的划分"><a href="#职责的划分" class="headerlink" title="职责的划分"></a>职责的划分</h2><p>既然一个类不能有多个职责，那么怎么划分职责呢？</p><p>Robert.C Martin给出了一个著名的定义：所谓一个类的一个职责是指引起该类变化的一个原因。</p><p>如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责。</p><h2 id="使用单一职责原则的理由"><a href="#使用单一职责原则的理由" class="headerlink" title="使用单一职责原则的理由"></a>使用单一职责原则的理由</h2><p><strong>单一职责原则从职责（改变理由）的侧面上为我们对类（接口）的抽象的颗粒度建立了判断基准：在为系统设计类（接口）的时候应该保证它们的单一职责性。</strong></p><p>降低了类的复杂度、提高类的可读性，提高系统的可维护性、降低变更引起的风险</p><h1 id="五、-接口分隔原则（Interface-Segregation-Principle-，ISP）"><a href="#五、-接口分隔原则（Interface-Segregation-Principle-，ISP）" class="headerlink" title="五、 接口分隔原则（Interface Segregation Principle ，ISP）"></a>五、 接口分隔原则（Interface Segregation Principle ，ISP）</h1><p>不能强迫用户去依赖那些他们不使用的接口。</p><p>概念理解<br>换句话说，使用多个专门的接口比使用单一的总接口总要好。</p><p>它包含了2层意思：</p><p><strong>接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。</strong>如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。</p><p>接口的依赖（继承）原则：如果一个接口a继承另一个接口b，则接口a相当于继承了接口b的方法，那么继承了接口b后的接口a也应该遵循上述原则：不应该包含用户不使用的方法。 反之，则说明接口a被b给污染了，应该重新设计它们的关系。</p><p>如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。</p><p>接口分隔原则指导我们：</p><ul><li>一个类对一个类的依赖应该建立在最小的接口上</li><li>建立单一接口，不要建立庞大臃肿的接口</li><li>尽量细化接口，接口中的方法尽量少</li></ul><p>接口分隔原则的优点和适度原则</p><pre><code>接口分隔原则从对接口的使用上为我们对接口抽象的颗粒度建立了判断基准：在为系统设计接口的时候，使用多个专门的接口代替单一的胖接口。</code></pre><p>符合高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。</p><p>注意适度原则，接口分隔要适度，避免产生大量的细小接口。</p><h2 id="单一职责原则和接口分隔原则的区别"><a href="#单一职责原则和接口分隔原则的区别" class="headerlink" title="单一职责原则和接口分隔原则的区别"></a>单一职责原则和接口分隔原则的区别</h2><p>单一职责强调的是接口、类、方法的职责是单一的，强调职责，方法可以多，针对程序中实现的细节；</p><p>接口分隔原则主要是约束接口，针对抽象、整体框架。</p><h1 id="六、-依赖倒置原则（Dependency-Inversion-Principle-，DIP）"><a href="#六、-依赖倒置原则（Dependency-Inversion-Principle-，DIP）" class="headerlink" title="六、 依赖倒置原则（Dependency Inversion Principle ，DIP）"></a>六、 依赖倒置原则（Dependency Inversion Principle ，DIP）</h1><ol><li><strong>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong></li><li>抽象不应该依赖于细节，细节应该依赖于抽象 </li><li><strong>针对接口编程，不要针对实现编程。</strong></li></ol><h2 id="概念理解-2"><a href="#概念理解-2" class="headerlink" title="概念理解"></a>概念理解</h2><p>依赖：在程序设计中，如果一个模块a使用&#x2F;调用了另一个模块b，我们称模块a依赖模块b。</p><p>高层模块与低层模块：往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块。</p><p>依赖倒置（Dependency Inversion）：</p><pre><code>面向对象程序设计相对于面向过程（结构化）程序设计而言，依赖关系被倒置了。因为传统的结构化程序设计中，高层模块总是依赖于低层模块。</code></pre><p>Robert C. Martin氏在原文中给出了“Bad Design”的定义：</p><pre><code>系统很难改变，因为每个改变都会影响其他很多部分。当你对某地方做一修改，系统的看似无关的其他部分都不工作了。系统很难被另外一个应用重用，因为很难将要重用的部分从系统中分离开来。导致“Bad Design”的很大原因是“高层模块”过分依赖“低层模块”。</code></pre><p>一个良好的设计应该是系统的每一部分都是可替换的。如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难可以重用。<br>类与类之间都通过抽象接口层来建立关系。</p><p>怎么使用依赖倒置原则</p><pre><code>1. 依赖于抽象    任何变量都不应该持有一个指向具体类的指针或引用。    任何类都不应该从具体类派生。2. 设计接口而非设计实现    使用继承避免对类的直接绑定    抽象类/接口： 倾向于较少的变化；抽象是关键点，它易于修改和扩展；不要强制修改那些抽象接口/类</code></pre><p>例外：</p><p>有些类不可能变化，在可以直接使用具体类的情况下，不需要插入抽象层，如：字符串类</p><p>使用继承和抽象类来有效地消除传递依赖</p><h2 id="依赖倒置原则的优点"><a href="#依赖倒置原则的优点" class="headerlink" title="依赖倒置原则的优点"></a>依赖倒置原则的优点</h2><p>可以减少类间的耦合性、提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险。</p><h1 id="七、-组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-，CARP）"><a href="#七、-组合-聚合复用原则（Composite-Aggregate-Reuse-Principle-，CARP）" class="headerlink" title="七、 组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle ，CARP）"></a>七、 组合&#x2F;聚合复用原则（Composite&#x2F;Aggregate Reuse Principle ，CARP）</h1><p><strong>尽量使用组合&#x2F;聚合，不要使用类继承。</strong></p><h2 id="概念理解-3"><a href="#概念理解-3" class="headerlink" title="概念理解"></a>概念理解</h2><p>即在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。就是说要尽量的使用合成和聚合，而不是继承关系达到复用的目的。</p><p>组合和聚合都是关联的特殊种类。</p><p>聚合表示整体和部分的关系，表示“拥有”。组合则是一种更强的“拥有”，部分和整体的生命周期一样。</p><p>组合的新的对象完全支配其组成部分，包括它们的创建和湮灭等。一个组合关系的成分对象是不能与另一个组合关系共享的。</p><p>组合是值的聚合（Aggregation by Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。</p><p>在面向对象设计中，有两种基本的办法可以实现复用：第一种是通过组合&#x2F;聚合，第二种就是通过继承。<br>什么时候才应该使用继承</p><h2 id="只有当以下的条件全部被满足时，才应当使用继承关系："><a href="#只有当以下的条件全部被满足时，才应当使用继承关系：" class="headerlink" title="只有当以下的条件全部被满足时，才应当使用继承关系："></a>只有当以下的条件全部被满足时，才应当使用继承关系：</h2><ol><li>派生类是基类的一个特殊种类，而不是基类的一个角色，也就是区分”Has-A”和”Is-A”。只有”Is-A”关系才符合继承关系，”Has-A”关系应当用聚合来描述。</li><li>永远不会出现需要将派生类换成另外一个类的派生类的情况。如果不能肯定将来是否会变成另外一个派生类的话，就不要使用继承。</li><li>派生类具有扩展基类的责任，而不是具有置换掉（override）或注销掉（Nullify）基类的责任。如果一个派生类需要大量的置换掉基类的行为，那么这个类就不应该是这个基类的派生类。</li><li>只有在分类学角度上有意义时，才可以使用继承。</li></ol><h2 id="组合-聚合复用的优缺点"><a href="#组合-聚合复用的优缺点" class="headerlink" title="组合&#x2F;聚合复用的优缺点"></a>组合&#x2F;聚合复用的优缺点</h2><p>优点：</p><ol><li>新对象存取子对象的唯一方法是通过子对象的接口。</li><li>这种复用是黑箱复用，因为子对象的内部细节是新对象所看不见的。</li><li>这种复用更好地支持封装性。</li><li>这种复用实现上的相互依赖性比较小。</li><li>每一个新的类可以将焦点集中在一个任务上。</li><li>这种复用可以在运行时间内动态进行，新对象可以动态的引用与子对象类型相同的对象。</li><li>作为复用手段可以应用到几乎任何环境中去。<br>缺点: 就是系统中会有较多的对象需要管理。</li></ol><h2 id="通过继承来进行复用的优缺点"><a href="#通过继承来进行复用的优缺点" class="headerlink" title="通过继承来进行复用的优缺点"></a>通过继承来进行复用的优缺点</h2><p>优点：</p><ol><li>新的实现较为容易，因为基类的大部分功能可以通过继承的关系自动进入派生类。</li><li>修改和扩展继承而来的实现较为容易。<br>缺点：</li><li>继承复用破坏封装性，因为继承将基类的实现细节暴露给派生类。由于基类的内部细节常常是对于派生类透明的，所以这种复用是透明的复用，又称“白箱”复用。</li><li>如果基类发生改变，那么派生类的实现也不得不发生改变。</li><li>从基类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。</li></ol><hr><p>所谓的设计模式，其实最终都是遵循OOP七大原则而在特定场合的抽象。设计原则是目标，设计模式是方法</p><h1 id="跟进记录归档"><a href="#跟进记录归档" class="headerlink" title="跟进记录归档"></a>跟进记录归档</h1><p>2024年06月13日17:53:43 <a href="https://blog.csdn.net/qq_34760445/article/details/82931002">面向对象设计的七大设计原则详解</a></p><p>2024年06月14日09:50:41 <a href="https://kb.cnblogs.com/page/137715/">什么是对象，为什么要面向对象，怎么才能面向对象？</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试驱动编程</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202409_%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202409_%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>2022年04月26日10:41:33 测试和profile先行。实际交付没有人会关注你的测试用例、profile建设、研发工具怎么样，只会看最终结果是不是又快又好，而这些会帮助我们达到又快又好</p><ol><li>事前高效的研发工具</li></ol><p>2018年6月6日17:24:39 TODO：了解测试框架robot framework</p><h1 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h1><p>2020年04月18日18:31:26 在测试机上安装jmeter perfmon metric collector的服务端ServerAgent-2.2.3，解压即用<br>.&#x2F;startAgent.sh –udp-port 8016 –tcp-port 8016</p><p>2020年12月11日16:18:22 下载启动jmeter-server<br>配置supervisor：<br>sh &#x2F;home&#x2F;niuqiang&#x2F;toolkits&#x2F;ServerAgent-2.2.3&#x2F;startAgent.sh –udp-port 8016 –tcp-port 8016</p><p>2018年12月13日11:29:44 学习使用jmeter做接口测试</p><p>2020年04月16日20:02:50 jmeter中设置变量<br>${__StringFromFile(&#x2F;Users&#x2F;didi&#x2F;projects&#x2F;speech-util&#x2F;model_deployer_for_mobile&#x2F;testset.input,post_body,,)}</p><p>2020年04月18日18:31:26 在测试机上安装jmeter perfmon metric collector的服务端ServerAgent-2.2.3，解压即用<br>.&#x2F;startAgent.sh –udp-port 8016 –tcp-port 8016</p><p>2020年04月16日20:02:50 jmeter中设置变量<br>${__StringFromFile(&#x2F;Users&#x2F;didi&#x2F;projects&#x2F;speech-util&#x2F;model_deployer_for_mobile&#x2F;testset.input,post_body,,)}<br><em>2018年12月13日11:30:02</em> 自动化测试jmeter所做的主要工作？是不是可以和robotframework结合，后者有什么优势</p><p><em>2018年12月20日20:39:48</em> 升级jmeter测试工具</p><h3 id="jmeter使用goreplay的流量文件压测"><a href="#jmeter使用goreplay的流量文件压测" class="headerlink" title="jmeter使用goreplay的流量文件压测"></a>jmeter使用goreplay的流量文件压测</h3><p>awk ‘NR%4&#x3D;&#x3D;3’ attention_requests_j.gor &gt; attention_requests_j_body.gor</p><p>$ find . -type f -name “*.jmx” | xargs grep -rn “StringFromFile”</p><p>${__StringFromFile(&#x2F;home&#x2F;niuqiang&#x2F;projects&#x2F;nlu-journey-shenfang&#x2F;test-input&#x2F;shenfang.gbk,post_body,,)}</p><p>2019年01月08日10:44:39 复制线上流量：</p><ol><li>使用sftp工具将goreplay复制到ftp中转位置，然后再复制到线上Lighttpd机器。因为speech-asr-attention接受的是fastcgi请求，所以不能直接复制流量</li></ol><p>2019年11月20日14:32:29 详细学习jmeter的使用</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试驱动， 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Git的版本管理规范</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202410_%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/202410_%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>2018年2月2日10:57:44 托管所有联系项目到gitee<br>2018年2月7日10:08:12 上传所有配置到gitee</p>]]></content>
      
      
      <categories>
          
          <category> 技术与工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp技术调研</title>
      <link href="/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202407uniapp%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E5%85%B7/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/202407uniapp%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信&#x2F;支付宝&#x2F;百度&#x2F;头条&#x2F;飞书&#x2F;QQ&#x2F;快手&#x2F;钉钉&#x2F;淘宝）、快应用等多个平台。</p><p>DCloud的初心是什么？</p><pre><code>为开发者提供免费、高效的开发工具，让天下没有难做的应用改进应用形态，让用户更方便地获取数字服务</code></pre><p><strong>DCloud也再次承诺不会对uni-app、HBuilderX等工具收费</strong>，感谢数百万开发者的一路陪伴，也请一直监督我们不忘初心！</p><blockquote><p>但是使用过程中，打包环节强行要求与dcloud账号绑定，即使未来出现某种形式的收费也不意外</p></blockquote><h1 id="uni-app组成和跨端原理"><a href="#uni-app组成和跨端原理" class="headerlink" title="uni-app组成和跨端原理"></a>uni-app组成和跨端原理</h1><h1 id="基本语言和开发规范"><a href="#基本语言和开发规范" class="headerlink" title="基本语言和开发规范"></a>基本语言和开发规范</h1><p>uni-app代码编写，基本语言包括js、vue、css。以及ts、scss等css预编译器。</p><p>为了实现多端兼容，综合考虑编译速度、运行性能等因素，uni-app 约定了如下开发规范：</p><pre><code>页面文件遵循 Vue 单文件组件 (SFC) 规范，即每个页面是一个.vue文件组件标签靠近小程序规范，详见uni-app 组件规范接口能力（JS API）靠近小程序规范，但需将前缀 wx、my 等替换为 uni，详见uni-app接口规范数据绑定及事件处理同 Vue.js 规范，同时补充了应用生命周期及页面的生命周期如需兼容app-nvue平台，建议使用flex布局进行开发</code></pre><p>uni-app分编译器和运行时（runtime）。uni-app能实现一套代码、多端运行，是通过这2部分配合完成的。</p><p>编译器将开发者的代码进行编译，编译的输出物由各个终端的runtime进行解析，每个平台（Web、Android App、iOS App、各家小程序）都有各自的runtime。</p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器运行在电脑开发环境。一般是内置在HBuilderX工具中，也可以使用独立的cli版。<br>开发者按uni-app规范编写代码，由编译器将开发者的代码编译生成每个平台支持的特有代码</p><p>编译器支持条件编译，即可以指定某部分代码只编译到特定的终端平台。从而将公用和个性化融合在一个工程中。</p><h1 id="uni-app-runtime"><a href="#uni-app-runtime" class="headerlink" title="uni-app runtime"></a>uni-app runtime</h1><p>包括3部分：基础框架、组件、API。</p><h2 id="基础框架："><a href="#基础框架：" class="headerlink" title="基础框架："></a>基础框架：</h2><p>包括语法、数据驱动、全局文件、应用管理、页面管理、js引擎、渲染和排版引擎等<br>在web和小程序上，不需要uni-app提供js引擎和排版引擎，直接使用浏览器和小程序的即可。但app上需要uni-app提供<br>App的js引擎：App-Android上，uni-app的js引擎是v8，App-iOS是jscore<br>App的渲染引擎：同时提供了2套渲染引擎，.vue页面文件由webview渲染，原理与小程序相同；.nvue页面文件由原生渲染，原理与react native相同</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>runtime中包括的组件只有基础组件，如&lt;view&gt;、&lt;button&gt;等。扩展组件不包含在uni-app的runtime中，而是下载到用户的项目代码中。（这些组件都是vue组件）<br>为了降低开发者的学习成本，uni-app的内置基础组件命名规范与小程序基本相同。<br>这几十个组件不管在哪个平台，已被处理为均有一致表现。<br>在小程序端，uni-app基础组件会直接转义为小程序自己的内置组件。在小程序的runtime中不占体积。<br>在web和android、iOS端，这几十个组件都在uni-app的runtime中，会占用一定体积，相当于内置了一套ui库。<br>组件的扩展：<br>有了几十个基础组件，大多数扩展组件也都是基于这些基础组件封装的。比如官方提供的扩展ui库uni ui。<br>在web平台，for web的各种ui库（如elementUI）也可以使用，但这些库由于操作了dom，无法跨端在app和小程序中使用。<br>在App平台，uni-app也支持使用原生编程语言来自行扩展原生组件，比如原生的地图、ar等。<br>uni-app同时支持将微信自定义组件运行到微信小程序、web、app这3个平台。注意微信自定义组件不是vue组件。  </p><h2 id="API："><a href="#API：" class="headerlink" title="API："></a>API：</h2><p>uni-app runtime内置了大量常见的、跨端的 API，比如联网(uni.request)、读取存储(uni.getStorage)<br>同时uni-app不限制各端原生平台的API调用。开发者可以在uni-app框架中无限制的调用该平台所有能使用的API。即，在小程序平台，小程序的所有API都可以使用；在web平台，浏览器的所有API都可使用；在iOS和Android平台，os的所有API都可以使用。<br>也就是说，使用uni-app的标准API，可以跨端使用。但对于不跨端的部分，仍可以调用该端的专有API。由于常见的API都已经被封装内置，所以日常开发时，开发者只需关注uni标准API，当需要调用特色端能力时在条件编译里编写特色API调用代码。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>一个uni-app工程，默认包含如下目录及文件：</p><pre><code>┌─uniCloud 云空间目录，支付宝小程序云为uniCloud-alipay，阿里云为uniCloud-aliyun，腾讯云为uniCloud-tcb（详见uniCloud）│─components 符合vue组件规范的uni-app组件目录│ └─comp-a.vue 可复用的a组件├─utssdk 存放uts文件├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源都应存放于此目录├─uni_modules 存放uni_module 详见├─platforms 存放各平台专用页面的目录，详见├─nativeplugins App原生语言插件 详见├─nativeResources App端原生资源目录│ ├─android Android原生资源目录 详见| └─ios iOS原生资源目录 详见├─hybrid App端存放本地html文件的目录，详见├─wxcomponents 存放小程序组件的目录，详见├─unpackage 非工程代码，一般存放运行或发行的编译结果├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期├─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见├─AndroidManifest.xml Android原生应用清单文件 详见├─Info.plist iOS原生应用配置文件 详见└─uni.scss 内置的常用样式变量</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>注意事项，如果static里有一些没有使用的废文件，也会被打包到编译包里，造成体积变大。</p><p>另外注意，static目录支持特殊的平台子目录，比如web、app、mp-weixin等，这些目录存放专有平台的文件，这些平台的文件在打包其他平台时不会被包含。</p><p>非 static 目录下的文件（vue组件、js、css 等）只有被引用时，才会被打包编译。</p><p>css、less&#x2F;scss 等资源不要放在 static 目录下，建议这些公用的资源放在自建的 common 目录下。</p><h1 id="页面内容构成"><a href="#页面内容构成" class="headerlink" title="页面内容构成"></a>页面内容构成</h1><p>uni-app 页面基于 vue 规范。一个页面内，有3个根节点标签：</p><pre><code>模板组件区 template脚本区 script样式区 style</code></pre><p>在vue的选项式（option）规范中，script下包含 export default {}。除了选项式，还有 组合式 写法。</p><p>页面级的代码大多写在 export default {} 中。写在里面的代码，会随着页面关闭而关闭。</p><h2 id="export-default-外的代码"><a href="#export-default-外的代码" class="headerlink" title="export default 外的代码"></a>export default 外的代码</h2><p>写在 export default {} 外面的代码，一般有几种情况：</p><pre><code>引入第三方 js/ts 模块引入非 easycom 的组件（一般组件推荐使用easycom，无需导入注册）在 ts/uts 中，对 data 进行类型定义定义作用域更大的变量</code></pre><p>开发者应谨慎编写 export default {} 外面的代码，这里的代码有2个注意事项：</p><pre><code>影响应用性能。这部分代码在应用启动时执行，而不是页面加载。如果这里的代码写的太复杂，会影响应用启动速度，占用更多内存。不跟随组件、页面关闭而回收。在外层的静态变量不会跟随页面关闭而回收。如果必要你需要手动处理。比如 beforeDestroy 或 destroyed 生命周期进行处理。</code></pre><h2 id="export-default-里的代码"><a href="#export-default-里的代码" class="headerlink" title="export default 里的代码"></a>export default 里的代码</h2><p>export default {} 里的内容，是页面的主要逻辑代码。包括几部分：</p><p>data：template模板中需要使用的数据。具体 另见<br>页面生命周期：如页面加载、隐藏、关闭，具体 见下<br>methods方法，如按钮点击、屏幕滚动</p><h2 id="style样式区"><a href="#style样式区" class="headerlink" title="style样式区"></a>style样式区</h2><p>style的写法与web的css基本相同</p><h2 id="页面加载时序介绍"><a href="#页面加载时序介绍" class="headerlink" title="页面加载时序介绍"></a>页面加载时序介绍</h2><p>接下来我们介绍onLoad、onReady、onShow的先后关系，页面加载的详细流程。</p><ol><li><p>uni-app框架，首先根据pages.json的配置，创建页面<br>所以原生导航栏是最快显示的。页面背景色也应该在这里配置。</p></li><li><p>根据页面template里的组件，创建dom。<br>这里的dom创建仅包含第一批处理的静态dom。对于通过js&#x2F;uts更新data然后通过v-for再创建的列表数据，不在第一批处理。</p></li><li><p>触发onLoad<br>此时页面还未显示，没有开始进入的转场动画，页面dom还不存在。</p></li></ol><p>所以这里不能直接操作dom（可以修改data，因为vue框架会等待dom准备后再更新界面）</p><p>onLoad比较适合的操作是：接受上页的参数，联网取数据，更新data。</p><p>手机都是多核的，uni.request或云开发联网，在子线程运行，不会干扰UI线程的入场动画，并行处理可以更快的拿到数据、渲染界面。</p><p>但onLoad里不适合进行大量同步耗时运算，因为此时转场动画还没开始。</p><ol start="4"><li><p>转场动画开始<br>新页面开始进入的转场动画，动画默认耗时300ms，可以在路由API中调节时长。</p></li><li><p>页面onReady<br>第2步创建dom是虚拟dom，dom创建后需要经历一段时间，UI层才能完成了页面上真实元素的创建，即触发了onReady。</p></li></ol><p>onReady后，页面元素就可以自由操作了，比如ref获取节点。同时首批界面也渲染了。</p><p>注意：onReady和转场动画开始、结束之间，没有必然的先后顺序，完全取决于dom的数量和复杂度。</p><p>如果元素排版和渲染够快，转场动画刚开始就渲染好了；</p><h2 id="getApp"><a href="#getApp" class="headerlink" title="getApp()"></a>getApp()</h2><p>getApp() 函数用于获取当前应用实例，一般用于获取globalData。也可通过应用实例调用 App.vue methods 中定义的方法。</p><p>不要在定义于 App() 内的函数中，或调用 App 前调用 getApp() ，可以通过 this.$scope 获取对应的app实例<br>通过 getApp() 获取实例之后，不要私自调用生命周期函数。<br>当在首页nvue中使用getApp()不一定可以获取真正的App对象。对此提供了const app &#x3D; getApp({allowDefault: true})用来获取原始的App对象，可以用来在首页对globalData等初始化</p><h2 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a>getCurrentPages()</h2><p>getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，数组中的元素为页面实例，第一个元素为首页，最后一个元素为当前页面。</p><p>getCurrentPages() 仅用于展示页面栈的情况，请勿修改页面栈，以免造成页面状态错误。</p><p>**navigateTo, redirectTo 只能打开非 tabBar 页面。<br>switchTab 只能打开 tabBar 页面。  **<br>&#96;reLaunch&#96;&#96; 可以打开任意页面。<br>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。<br>不能在首页 onReady 之前进行页面跳转。</p><h2 id="页面通讯"><a href="#页面通讯" class="headerlink" title="页面通讯"></a>页面通讯</h2><p>uni.$emit(eventName,OBJECT)<br>触发全局的自定义事件。附加参数都会传给监听器回调。</p><p>uni.$on(eventName,callback)<br>监听全局的自定义事件。事件可以由 uni.$emit 触发，回调函数会接收所有传入事件触发函数的额外参数。</p><p>uni.$once(eventName,callback)<br>监听全局的自定义事件。事件可以由 uni.$emit 触发，但是只触发一次，在第一次触发之后移除监听器。</p><p>uni.$off([eventName, callback])<br>移除全局自定义事件监听器。</p><p>uni.$emit、 uni.$on 、 uni.$once 、uni.$off 触发的事件都是 App 全局级别的，跨任意组件，页面，nvue，vue 等<br>使用时，注意及时销毁事件监听，比如，页面 onLoad 里边 uni.$on 注册监听，onUnload 里边 uni.$off 移除，或者一次性的事件，直接使用 uni.$once 监听</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>uni-app 有两种页面路由跳转方式：使用navigator组件跳转、调用API跳转。</p><p>页面返回时会自动关闭 loading 及 toast, modal 及 actionSheet 不会自动关闭。<br>页面关闭时，只是销毁了页面实例，未完成的网络请求、计时器等副作用需开发者自行处理。</p><p>uni-app 支持在 template 模板中嵌套 template 和 block，用来进行 条件渲染 和 列表渲染。</p><h1 id="js-语法支持"><a href="#js-语法支持" class="headerlink" title="js 语法支持"></a>js 语法支持</h1><h2 id="标准js和浏览器js的区别"><a href="#标准js和浏览器js的区别" class="headerlink" title="标准js和浏览器js的区别"></a>标准js和浏览器js的区别</h2><p>uni-app的js代码，h5端运行于浏览器中。非h5端（包含小程序和App），Android平台运行在v8引擎中，iOS平台运行在iOS自带的jscore引擎中，都没有运行在浏览器或webview里。</p><p>所以uni-app的非H5端，一样支持标准js，支持if、for等语法，支持字符串、数字、时间、布尔值、数组、自定义对象等变量类型及各种处理方法。仅仅是不支持window、document、navigator等浏览器专用对象。</p><h2 id="APP端"><a href="#APP端" class="headerlink" title="APP端"></a>APP端</h2><ol><li>Android<br>JS脚本运行在独立Google V8引擎中，版本与Chrome83一致，因此支持的语法与Android系统版本无关</li></ol><p>vue页面渲染在系统Webview中，受Android系统版本影响，在Android低端机上存在css浏览器兼容性问题，太新的css语法在低版本不支持<br>2. IOS<br>JS脚本运行在iOS操作系统提供的JavaScriptCore 引擎，因此支持的语法与iOS系统有关，跟iOS系统的Safari浏览器一致</p><p>vue页面渲染在系统WKWebview中，受iOS系统版本影响，兼容性与iOS系统的Safari浏览器一致</p><h1 id="页面样式与布局"><a href="#页面样式与布局" class="headerlink" title="页面样式与布局"></a>页面样式与布局</h1><p>uni-app 有 vue 页面、nvue 页面、uvue页面。<br>vue 页面是 webview 渲染的</p><h2 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h2><p>框架组件上支持使用 style、class 属性来控制组件的样式。</p><p>style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</p><p>class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>目前支持的选择器有：</p><table><thead><tr><th>选择器</th><th>样例</th><th>样例描述</th></tr></thead><tbody><tr><td>.class</td><td>.intro</td><td>选择所有拥有 class&#x3D;”intro” 的组件</td></tr><tr><td>#id</td><td>#firstname</td><td>选择拥有 id&#x3D;”firstname” 的组件</td></tr><tr><td>element</td><td>view</td><td>选择所有 view 组件</td></tr><tr><td>element, element</td><td>view, checkbox</td><td>选择所有文档的 view 组件和所有的 checkbox 组件</td></tr><tr><td>::after</td><td>view::after</td><td>在 view 组件后边插入内容，仅 vue 页面生效</td></tr><tr><td>::before</td><td>view::before</td><td>在 view 组件前边插入内容，仅 vue 页面生效</td></tr></tbody></table><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><p>2024年07月03日20:06:57 官方给的hello uni-app可以直接h5和weapp启动，并且提供了组件模版，快速开发就它了</p><h2 id="Recorder-core"><a href="#Recorder-core" class="headerlink" title="Recorder-core"></a>Recorder-core</h2><p>2024-08-05 10:08:27 跨平台Recorder录音插件：支持多种格式、音频可视化、实时上传、语音识别 <a href="https://ext.dcloud.net.cn/plugin?name=Recorder-UniCore">https://ext.dcloud.net.cn/plugin?name=Recorder-UniCore</a></p><blockquote><p>在安卓端试用时疑似有音爆问题。时间上也来不及，所以暂时先用android native实现<br><img src="/./resources/uniapp-recordercore%E5%9C%A8android%E7%AB%AF%E5%BD%95%E9%9F%B3%E9%9F%B3%E7%88%86%E9%97%AE%E9%A2%98.png"></p></blockquote><h2 id="uniapp集成android原生sdk"><a href="#uniapp集成android原生sdk" class="headerlink" title="uniapp集成android原生sdk"></a>uniapp集成android原生sdk</h2><p>2024-08-05 10:12:21 TODO 需要探索的路径，估计有很多模块都需要这么实现 <a href="https://blog.csdn.net/cuper_/article/details/127993632">https://blog.csdn.net/cuper_/article/details/127993632</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>2024-07-12 14:59:06 什么是uni-app <a href="https://uniapp.dcloud.net.cn/">https://uniapp.dcloud.net.cn/</a></p><blockquote><p>比较有用的选型指南，解答为什么使用uniapp的问题</p></blockquote><p>2024-07-15 09:56:56 基础概念和学习vue3 <a href="https://uniapp.dcloud.net.cn/tutorial/vue3-basics.html">https://uniapp.dcloud.net.cn/tutorial/vue3-basics.html</a></p><blockquote><p>vue3的内容比较丰富，可能需要经常回顾，就不往这个文档里摘抄了</p></blockquote><p>2024-07-15 09:57:12 小程序转uniapp指南 <a href="https://ask.dcloud.net.cn/article/35786">https://ask.dcloud.net.cn/article/35786</a></p><p>2024-07-15 09:57:28 uniapp官方教程 <a href="https://ke.qq.com/course/3169971#term_id=103296764">https://ke.qq.com/course/3169971#term_id=103296764</a></p><blockquote><p>没有太多有效的内容</p></blockquote><p>2024-07-15 10:01:43 vue3官方简明教程 <a href="https://cn.vuejs.org/guide/introduction.html">https://cn.vuejs.org/guide/introduction.html</a></p><p>2024-08-01 15:12:36 使用vscode开发 uniapp<br><a href="https://ask.dcloud.net.cn/article/36286">https://ask.dcloud.net.cn/article/36286</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端与小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
